var C1 = Object.defineProperty;
var Ji = (le) => {
	throw TypeError(le);
};
var R1 = (le, ce, A) =>
	ce in le
		? C1(le, ce, { enumerable: !0, configurable: !0, writable: !0, value: A })
		: (le[ce] = A);
var ye = (le, ce, A) => R1(le, typeof ce != "symbol" ? ce + "" : ce, A),
	I1 = (le, ce, A) => ce.has(le) || Ji("Cannot " + A);
var ji = (le, ce, A) =>
	ce.has(le)
		? Ji("Cannot add the same private member more than once")
		: ce instanceof WeakSet
			? ce.add(le)
			: ce.set(le, A);
var h0 = (le, ce, A) => (I1(le, ce, "access private method"), A);
(function () {
	"use strict";
	var Ut, _n, es;
	class le {
		constructor(e, t, n) {
			(this.lexer = void 0),
				(this.start = void 0),
				(this.end = void 0),
				(this.lexer = e),
				(this.start = t),
				(this.end = n);
		}
		static range(e, t) {
			return t
				? !e || !e.loc || !t.loc || e.loc.lexer !== t.loc.lexer
					? null
					: new le(e.loc.lexer, e.loc.start, t.loc.end)
				: e && e.loc;
		}
	}
	class ce {
		constructor(e, t) {
			(this.text = void 0),
				(this.loc = void 0),
				(this.noexpand = void 0),
				(this.treatAsRelax = void 0),
				(this.text = e),
				(this.loc = t);
		}
		range(e, t) {
			return new ce(t, le.range(this, e));
		}
	}
	class A {
		constructor(e, t) {
			(this.name = void 0),
				(this.position = void 0),
				(this.length = void 0),
				(this.rawMessage = void 0);
			var n = "KaTeX parse error: " + e,
				a,
				i,
				s = t && t.loc;
			if (s && s.start <= s.end) {
				var l = s.lexer.input;
				(a = s.start),
					(i = s.end),
					a === l.length ? (n += " at end of input: ") : (n += " at position " + (a + 1) + ": ");
				var u = l.slice(a, i).replace(/[^]/g, "$&̲"),
					d;
				a > 15 ? (d = "…" + l.slice(a - 15, a)) : (d = l.slice(0, a));
				var p;
				i + 15 < l.length ? (p = l.slice(i, i + 15) + "…") : (p = l.slice(i)), (n += d + u + p);
			}
			var f = new Error(n);
			return (
				(f.name = "ParseError"),
				(f.__proto__ = A.prototype),
				(f.position = a),
				a != null && i != null && (f.length = i - a),
				(f.rawMessage = e),
				f
			);
		}
	}
	A.prototype.__proto__ = Error.prototype;
	var ts = function (e, t) {
			return e.indexOf(t) !== -1;
		},
		rs = function (e, t) {
			return e === void 0 ? t : e;
		},
		ns = /([A-Z])/g,
		as = function (e) {
			return e.replace(ns, "-$1").toLowerCase();
		},
		is = { "&": "&amp;", ">": "&gt;", "<": "&lt;", '"': "&quot;", "'": "&#x27;" },
		ss = /[&><"']/g;
	function os(r) {
		return String(r).replace(ss, (e) => is[e]);
	}
	var Sn = function r(e) {
			return e.type === "ordgroup" || e.type === "color"
				? e.body.length === 1
					? r(e.body[0])
					: e
				: e.type === "font"
					? r(e.body)
					: e;
		},
		ls = function (e) {
			var t = Sn(e);
			return t.type === "mathord" || t.type === "textord" || t.type === "atom";
		},
		cs = function (e) {
			if (!e) throw new Error("Expected non-null, but got " + String(e));
			return e;
		},
		us = function (e) {
			var t = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(e);
			return t
				? t[2] !== ":" || !/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(t[1])
					? null
					: t[1].toLowerCase()
				: "_relative";
		},
		V = {
			contains: ts,
			deflt: rs,
			escape: os,
			hyphenate: as,
			getBaseElem: Sn,
			isCharacterBox: ls,
			protocolFromUrl: us,
		},
		_r = {
			displayMode: {
				type: "boolean",
				description:
					"Render math in display mode, which puts the math in display style (so \\int and \\sum are large, for example), and centers the math on the page on its own line.",
				cli: "-d, --display-mode",
			},
			output: {
				type: { enum: ["htmlAndMathml", "html", "mathml"] },
				description: "Determines the markup language of the output.",
				cli: "-F, --format <type>",
			},
			leqno: {
				type: "boolean",
				description: "Render display math in leqno style (left-justified tags).",
			},
			fleqn: { type: "boolean", description: "Render display math flush left." },
			throwOnError: {
				type: "boolean",
				default: !0,
				cli: "-t, --no-throw-on-error",
				cliDescription:
					"Render errors (in the color given by --error-color) instead of throwing a ParseError exception when encountering an error.",
			},
			errorColor: {
				type: "string",
				default: "#cc0000",
				cli: "-c, --error-color <color>",
				cliDescription:
					"A color string given in the format 'rgb' or 'rrggbb' (no #). This option determines the color of errors rendered by the -t option.",
				cliProcessor: (r) => "#" + r,
			},
			macros: {
				type: "object",
				cli: "-m, --macro <def>",
				cliDescription:
					"Define custom macro of the form '\\foo:expansion' (use multiple -m arguments for multiple macros).",
				cliDefault: [],
				cliProcessor: (r, e) => (e.push(r), e),
			},
			minRuleThickness: {
				type: "number",
				description:
					"Specifies a minimum thickness, in ems, for fraction lines, `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, `\\hdashline`, `\\underline`, `\\overline`, and the borders of `\\fbox`, `\\boxed`, and `\\fcolorbox`.",
				processor: (r) => Math.max(0, r),
				cli: "--min-rule-thickness <size>",
				cliProcessor: parseFloat,
			},
			colorIsTextColor: {
				type: "boolean",
				description:
					"Makes \\color behave like LaTeX's 2-argument \\textcolor, instead of LaTeX's one-argument \\color mode change.",
				cli: "-b, --color-is-text-color",
			},
			strict: {
				type: [{ enum: ["warn", "ignore", "error"] }, "boolean", "function"],
				description:
					"Turn on strict / LaTeX faithfulness mode, which throws an error if the input uses features that are not supported by LaTeX.",
				cli: "-S, --strict",
				cliDefault: !1,
			},
			trust: {
				type: ["boolean", "function"],
				description: "Trust the input, enabling all HTML features such as \\url.",
				cli: "-T, --trust",
			},
			maxSize: {
				type: "number",
				default: 1 / 0,
				description:
					"If non-zero, all user-specified sizes, e.g. in \\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, elements and spaces can be arbitrarily large",
				processor: (r) => Math.max(0, r),
				cli: "-s, --max-size <n>",
				cliProcessor: parseInt,
			},
			maxExpand: {
				type: "number",
				default: 1e3,
				description:
					"Limit the number of macro expansions to the specified number, to prevent e.g. infinite macro loops. If set to Infinity, the macro expander will try to fully expand as in LaTeX.",
				processor: (r) => Math.max(0, r),
				cli: "-e, --max-expand <n>",
				cliProcessor: (r) => (r === "Infinity" ? 1 / 0 : parseInt(r)),
			},
			globalGroup: { type: "boolean", cli: !1 },
		};
	function hs(r) {
		if (r.default) return r.default;
		var e = r.type,
			t = Array.isArray(e) ? e[0] : e;
		if (typeof t != "string") return t.enum[0];
		switch (t) {
			case "boolean":
				return !1;
			case "string":
				return "";
			case "number":
				return 0;
			case "object":
				return {};
		}
	}
	class d0 {
		constructor(e) {
			(this.displayMode = void 0),
				(this.output = void 0),
				(this.leqno = void 0),
				(this.fleqn = void 0),
				(this.throwOnError = void 0),
				(this.errorColor = void 0),
				(this.macros = void 0),
				(this.minRuleThickness = void 0),
				(this.colorIsTextColor = void 0),
				(this.strict = void 0),
				(this.trust = void 0),
				(this.maxSize = void 0),
				(this.maxExpand = void 0),
				(this.globalGroup = void 0),
				(e = e || {});
			for (var t in _r)
				if (_r.hasOwnProperty(t)) {
					var n = _r[t];
					this[t] = e[t] !== void 0 ? (n.processor ? n.processor(e[t]) : e[t]) : hs(n);
				}
		}
		reportNonstrict(e, t, n) {
			var a = this.strict;
			if ((typeof a == "function" && (a = a(e, t, n)), !(!a || a === "ignore"))) {
				if (a === !0 || a === "error")
					throw new A(
						"LaTeX-incompatible input and strict mode is set to 'error': " + (t + " [" + e + "]"),
						n
					);
				a === "warn"
					? typeof console < "u" &&
						console.warn(
							"LaTeX-incompatible input and strict mode is set to 'warn': " + (t + " [" + e + "]")
						)
					: typeof console < "u" &&
						console.warn(
							"LaTeX-incompatible input and strict mode is set to " +
								("unrecognized '" + a + "': " + t + " [" + e + "]")
						);
			}
		}
		useStrictBehavior(e, t, n) {
			var a = this.strict;
			if (typeof a == "function")
				try {
					a = a(e, t, n);
				} catch {
					a = "error";
				}
			return !a || a === "ignore"
				? !1
				: a === !0 || a === "error"
					? !0
					: a === "warn"
						? (typeof console < "u" &&
								console.warn(
									"LaTeX-incompatible input and strict mode is set to 'warn': " +
										(t + " [" + e + "]")
								),
							!1)
						: (typeof console < "u" &&
								console.warn(
									"LaTeX-incompatible input and strict mode is set to " +
										("unrecognized '" + a + "': " + t + " [" + e + "]")
								),
							!1);
		}
		isTrusted(e) {
			if (e.url && !e.protocol) {
				var t = V.protocolFromUrl(e.url);
				if (t == null) return !1;
				e.protocol = t;
			}
			var n = typeof this.trust == "function" ? this.trust(e) : this.trust;
			return !!n;
		}
	}
	class Tt {
		constructor(e, t, n) {
			(this.id = void 0),
				(this.size = void 0),
				(this.cramped = void 0),
				(this.id = e),
				(this.size = t),
				(this.cramped = n);
		}
		sup() {
			return ot[ds[this.id]];
		}
		sub() {
			return ot[ms[this.id]];
		}
		fracNum() {
			return ot[ps[this.id]];
		}
		fracDen() {
			return ot[fs[this.id]];
		}
		cramp() {
			return ot[gs[this.id]];
		}
		text() {
			return ot[bs[this.id]];
		}
		isTight() {
			return this.size >= 2;
		}
	}
	var m0 = 0,
		Sr = 1,
		Vt = 2,
		gt = 3,
		rr = 4,
		et = 5,
		Wt = 6,
		Ue = 7,
		ot = [
			new Tt(m0, 0, !1),
			new Tt(Sr, 0, !0),
			new Tt(Vt, 1, !1),
			new Tt(gt, 1, !0),
			new Tt(rr, 2, !1),
			new Tt(et, 2, !0),
			new Tt(Wt, 3, !1),
			new Tt(Ue, 3, !0),
		],
		ds = [rr, et, rr, et, Wt, Ue, Wt, Ue],
		ms = [et, et, et, et, Ue, Ue, Ue, Ue],
		ps = [Vt, gt, rr, et, Wt, Ue, Wt, Ue],
		fs = [gt, gt, et, et, Ue, Ue, Ue, Ue],
		gs = [Sr, Sr, gt, gt, et, et, Ue, Ue],
		bs = [m0, Sr, Vt, gt, Vt, gt, Vt, gt],
		Z = { DISPLAY: ot[m0], TEXT: ot[Vt], SCRIPT: ot[rr], SCRIPTSCRIPT: ot[Wt] },
		p0 = [
			{
				name: "latin",
				blocks: [
					[256, 591],
					[768, 879],
				],
			},
			{ name: "cyrillic", blocks: [[1024, 1279]] },
			{ name: "armenian", blocks: [[1328, 1423]] },
			{ name: "brahmic", blocks: [[2304, 4255]] },
			{ name: "georgian", blocks: [[4256, 4351]] },
			{
				name: "cjk",
				blocks: [
					[12288, 12543],
					[19968, 40879],
					[65280, 65376],
				],
			},
			{ name: "hangul", blocks: [[44032, 55215]] },
		];
	function vs(r) {
		for (var e = 0; e < p0.length; e++)
			for (var t = p0[e], n = 0; n < t.blocks.length; n++) {
				var a = t.blocks[n];
				if (r >= a[0] && r <= a[1]) return t.name;
			}
		return null;
	}
	var Er = [];
	p0.forEach((r) => r.blocks.forEach((e) => Er.push(...e)));
	function En(r) {
		for (var e = 0; e < Er.length; e += 2) if (r >= Er[e] && r <= Er[e + 1]) return !0;
		return !1;
	}
	var Zt = 80,
		ys = function (e, t) {
			return (
				"M95," +
				(622 + e + t) +
				`
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l` +
				e / 2.075 +
				" -" +
				e +
				`
c5.3,-9.3,12,-14,20,-14
H400000v` +
				(40 + e) +
				`H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M` +
				(834 + e) +
				" " +
				t +
				"h400000v" +
				(40 + e) +
				"h-400000z"
			);
		},
		xs = function (e, t) {
			return (
				"M263," +
				(601 + e + t) +
				`c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l` +
				e / 2.084 +
				" -" +
				e +
				`
c4.7,-7.3,11,-11,19,-11
H40000v` +
				(40 + e) +
				`H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M` +
				(1001 + e) +
				" " +
				t +
				"h400000v" +
				(40 + e) +
				"h-400000z"
			);
		},
		ws = function (e, t) {
			return (
				"M983 " +
				(10 + e + t) +
				`
l` +
				e / 3.13 +
				" -" +
				e +
				`
c4,-6.7,10,-10,18,-10 H400000v` +
				(40 + e) +
				`
H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7
s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744
c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30
c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722
c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5
c53.7,-170.3,84.5,-266.8,92.5,-289.5z
M` +
				(1001 + e) +
				" " +
				t +
				"h400000v" +
				(40 + e) +
				"h-400000z"
			);
		},
		ks = function (e, t) {
			return (
				"M424," +
				(2398 + e + t) +
				`
c-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514
c0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20
s-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121
s209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081
l` +
				e / 4.223 +
				" -" +
				e +
				`c4,-6.7,10,-10,18,-10 H400000
v` +
				(40 + e) +
				`H1014.6
s-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185
c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2z M` +
				(1001 + e) +
				" " +
				t +
				`
h400000v` +
				(40 + e) +
				"h-400000z"
			);
		},
		_s = function (e, t) {
			return (
				"M473," +
				(2713 + e + t) +
				`
c339.3,-1799.3,509.3,-2700,510,-2702 l` +
				e / 5.298 +
				" -" +
				e +
				`
c3.3,-7.3,9.3,-11,18,-11 H400000v` +
				(40 + e) +
				`H1017.7
s-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200
c0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26
s76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,
606zM` +
				(1001 + e) +
				" " +
				t +
				"h400000v" +
				(40 + e) +
				"H1017.7z"
			);
		},
		Ss = function (e) {
			var t = e / 2;
			return "M400000 " + e + " H0 L" + t + " 0 l65 45 L145 " + (e - 80) + " H400000z";
		},
		Es = function (e, t, n) {
			var a = n - 54 - t - e;
			return (
				"M702 " +
				(e + t) +
				"H400000" +
				(40 + e) +
				`
H742v` +
				a +
				`l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1
h-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170
c-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667
219 661 l218 661zM702 ` +
				t +
				"H400000v" +
				(40 + e) +
				"H742z"
			);
		},
		Ts = function (e, t, n) {
			t = 1e3 * t;
			var a = "";
			switch (e) {
				case "sqrtMain":
					a = ys(t, Zt);
					break;
				case "sqrtSize1":
					a = xs(t, Zt);
					break;
				case "sqrtSize2":
					a = ws(t, Zt);
					break;
				case "sqrtSize3":
					a = ks(t, Zt);
					break;
				case "sqrtSize4":
					a = _s(t, Zt);
					break;
				case "sqrtTall":
					a = Es(t, Zt, n);
			}
			return a;
		},
		Ms = function (e, t) {
			switch (e) {
				case "⎜":
					return "M291 0 H417 V" + t + " H291z M291 0 H417 V" + t + " H291z";
				case "∣":
					return "M145 0 H188 V" + t + " H145z M145 0 H188 V" + t + " H145z";
				case "∥":
					return (
						"M145 0 H188 V" +
						t +
						" H145z M145 0 H188 V" +
						t +
						" H145z" +
						("M367 0 H410 V" + t + " H367z M367 0 H410 V" + t + " H367z")
					);
				case "⎟":
					return "M457 0 H583 V" + t + " H457z M457 0 H583 V" + t + " H457z";
				case "⎢":
					return "M319 0 H403 V" + t + " H319z M319 0 H403 V" + t + " H319z";
				case "⎥":
					return "M263 0 H347 V" + t + " H263z M263 0 H347 V" + t + " H263z";
				case "⎪":
					return "M384 0 H504 V" + t + " H384z M384 0 H504 V" + t + " H384z";
				case "⏐":
					return "M312 0 H355 V" + t + " H312z M312 0 H355 V" + t + " H312z";
				case "‖":
					return (
						"M257 0 H300 V" +
						t +
						" H257z M257 0 H300 V" +
						t +
						" H257z" +
						("M478 0 H521 V" + t + " H478z M478 0 H521 V" + t + " H478z")
					);
				default:
					return "";
			}
		},
		Tn = {
			doubleleftarrow: `M262 157
l10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3
 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28
 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5
c2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5
 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87
-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7
-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z
m8 0v40h399730v-40zm0 194v40h399730v-40z`,
			doublerightarrow: `M399738 392l
-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5
 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88
-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68
-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18
-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782
c-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3
-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z`,
			leftarrow: `M400000 241H110l3-3c68.7-52.7 113.7-120
 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8
-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247
c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208
 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3
 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202
 l-3-3h399890zM100 241v40h399900v-40z`,
			leftbrace: `M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117
-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7
 5-6 9-10 13-.7 1-7.3 1-20 1H6z`,
			leftbraceunder: `M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z`,
			leftgroup: `M400000 80
H435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0
 435 0h399565z`,
			leftgroupunder: `M400000 262
H435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219
 435 219h399565z`,
			leftharpoon: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3
-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5
-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7
-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z`,
			leftharpoonplus: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5
 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3
-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7
-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z
m0 0v40h400000v-40z`,
			leftharpoondown: `M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333
 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5
 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667
-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z`,
			leftharpoondownplus: `M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12
 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7
-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0
v40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z`,
			lefthook: `M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5
-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3
-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21
 71.5 23h399859zM103 281v-40h399897v40z`,
			leftlinesegment: `M40 281 V428 H0 V94 H40 V241 H400000 v40z
M40 281 V428 H0 V94 H40 V241 H400000 v40z`,
			leftmapsto: `M40 281 V448H0V74H40V241H400000v40z
M40 281 V448H0V74H40V241H400000v40z`,
			leftToFrom: `M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23
-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8
c28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3
 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z`,
			longequal: `M0 50 h400000 v40H0z m0 194h40000v40H0z
M0 50 h400000 v40H0z m0 194h40000v40H0z`,
			midbrace: `M200428 334
c-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14
-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7
 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11
 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z`,
			midbraceunder: `M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z`,
			oiintSize1: `M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6
-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z
m368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8
60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z`,
			oiintSize2: `M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8
-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z
m502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2
c0 110 84 276 504 276s502.4-166 502.4-276z`,
			oiiintSize1: `M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6
-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z
m525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0
85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z`,
			oiiintSize2: `M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8
-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z
m770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1
c0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z`,
			rightarrow: `M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z`,
			rightbrace: `M400000 542l
-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5
s-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1
c124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z`,
			rightbraceunder: `M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z`,
			rightgroup: `M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0
 3-1 3-3v-38c-76-158-257-219-435-219H0z`,
			rightgroupunder: `M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18
 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z`,
			rightharpoon: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3
-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2
-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58
 69.2 92 94.5zm0 0v40h399900v-40z`,
			rightharpoonplus: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11
-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7
 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z
m0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z`,
			rightharpoondown: `M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8
 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5
-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95
-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z`,
			rightharpoondownplus: `M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8
 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3
 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3
-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z
m0-194v40h400000v-40zm0 0v40h400000v-40z`,
			righthook: `M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3
 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0
-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21
 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z`,
			rightlinesegment: `M399960 241 V94 h40 V428 h-40 V281 H0 v-40z
M399960 241 V94 h40 V428 h-40 V281 H0 v-40z`,
			rightToFrom: `M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23
 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32
-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142
-167z M100 147v40h399900v-40zM0 341v40h399900v-40z`,
			twoheadleftarrow: `M0 167c68 40
 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69
-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3
-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19
-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101
 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z`,
			twoheadrightarrow: `M400000 167
c-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3
 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42
 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333
-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70
 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z`,
			tilde1: `M200 55.538c-77 0-168 73.953-177 73.953-3 0-7
-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0
 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0
 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128
-68.267.847-113-73.952-191-73.952z`,
			tilde2: `M344 55.266c-142 0-300.638 81.316-311.5 86.418
-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9
 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114
c1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751
 181.476 676 181.476c-149 0-189-126.21-332-126.21z`,
			tilde3: `M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457
-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0
 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697
 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696
 -338 0-409-156.573-744-156.573z`,
			tilde4: `M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345
-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409
 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9
 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409
 -175.236-744-175.236z`,
			vec: `M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z`,
			widehat1: `M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z`,
			widehat2: `M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
			widehat3: `M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
			widehat4: `M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
			widecheck1: `M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,
-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z`,
			widecheck2: `M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
			widecheck3: `M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
			widecheck4: `M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
			baraboveleftarrow: `M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202
c4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5
c-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130
s-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47
121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6
s2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11
c0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z
M100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z`,
			rightarrowabovebar: `M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32
-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0
13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39
-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5
-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z`,
			baraboveshortleftharpoon: `M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17
c2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21
c-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40
c-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z
M0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z`,
			rightharpoonaboveshortbar: `M0,241 l0,40c399126,0,399993,0,399993,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z`,
			shortbaraboveleftharpoon: `M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,
1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,
-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z
M93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z`,
			shortrightharpoonabovebar: `M53,241l0,40c398570,0,399437,0,399437,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z`,
		},
		As = function (e, t) {
			switch (e) {
				case "lbrack":
					return (
						"M403 1759 V84 H666 V0 H319 V1759 v" +
						t +
						` v1759 h347 v-84
H403z M403 1759 V0 H319 V1759 v` +
						t +
						" v1759 h84z"
					);
				case "rbrack":
					return (
						"M347 1759 V0 H0 V84 H263 V1759 v" +
						t +
						` v1759 H0 v84 H347z
M347 1759 V0 H263 V1759 v` +
						t +
						" v1759 h84z"
					);
				case "vert":
					return (
						"M145 15 v585 v" +
						t +
						` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` +
						-t +
						` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` +
						t +
						" v585 h43z"
					);
				case "doublevert":
					return (
						"M145 15 v585 v" +
						t +
						` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` +
						-t +
						` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` +
						t +
						` v585 h43z
M367 15 v585 v` +
						t +
						` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` +
						-t +
						` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M410 15 H367 v585 v` +
						t +
						" v585 h43z"
					);
				case "lfloor":
					return (
						"M319 602 V0 H403 V602 v" +
						t +
						` v1715 h263 v84 H319z
MM319 602 V0 H403 V602 v` +
						t +
						" v1715 H319z"
					);
				case "rfloor":
					return (
						"M319 602 V0 H403 V602 v" +
						t +
						` v1799 H0 v-84 H319z
MM319 602 V0 H403 V602 v` +
						t +
						" v1715 H319z"
					);
				case "lceil":
					return (
						"M403 1759 V84 H666 V0 H319 V1759 v" +
						t +
						` v602 h84z
M403 1759 V0 H319 V1759 v` +
						t +
						" v602 h84z"
					);
				case "rceil":
					return (
						"M347 1759 V0 H0 V84 H263 V1759 v" +
						t +
						` v602 h84z
M347 1759 V0 h-84 V1759 v` +
						t +
						" v602 h84z"
					);
				case "lparen":
					return (
						`M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1
c-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,
-36,557 l0,` +
						(t + 84) +
						`c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,
949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9
c0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,
-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189
l0,-` +
						(t + 92) +
						`c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,
-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z`
					);
				case "rparen":
					return (
						`M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,
63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5
c11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0,` +
						(t + 9) +
						`
c-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664
c-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11
c0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17
c242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558
l0,-` +
						(t + 144) +
						`c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,
-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z`
					);
				default:
					throw new Error("Unknown stretchy delimiter.");
			}
		};
	class nr {
		constructor(e) {
			(this.children = void 0),
				(this.classes = void 0),
				(this.height = void 0),
				(this.depth = void 0),
				(this.maxFontSize = void 0),
				(this.style = void 0),
				(this.children = e),
				(this.classes = []),
				(this.height = 0),
				(this.depth = 0),
				(this.maxFontSize = 0),
				(this.style = {});
		}
		hasClass(e) {
			return V.contains(this.classes, e);
		}
		toNode() {
			for (var e = document.createDocumentFragment(), t = 0; t < this.children.length; t++)
				e.appendChild(this.children[t].toNode());
			return e;
		}
		toMarkup() {
			for (var e = "", t = 0; t < this.children.length; t++) e += this.children[t].toMarkup();
			return e;
		}
		toText() {
			var e = (t) => t.toText();
			return this.children.map(e).join("");
		}
	}
	var lt = {
			"AMS-Regular": {
				32: [0, 0, 0, 0, 0.25],
				65: [0, 0.68889, 0, 0, 0.72222],
				66: [0, 0.68889, 0, 0, 0.66667],
				67: [0, 0.68889, 0, 0, 0.72222],
				68: [0, 0.68889, 0, 0, 0.72222],
				69: [0, 0.68889, 0, 0, 0.66667],
				70: [0, 0.68889, 0, 0, 0.61111],
				71: [0, 0.68889, 0, 0, 0.77778],
				72: [0, 0.68889, 0, 0, 0.77778],
				73: [0, 0.68889, 0, 0, 0.38889],
				74: [0.16667, 0.68889, 0, 0, 0.5],
				75: [0, 0.68889, 0, 0, 0.77778],
				76: [0, 0.68889, 0, 0, 0.66667],
				77: [0, 0.68889, 0, 0, 0.94445],
				78: [0, 0.68889, 0, 0, 0.72222],
				79: [0.16667, 0.68889, 0, 0, 0.77778],
				80: [0, 0.68889, 0, 0, 0.61111],
				81: [0.16667, 0.68889, 0, 0, 0.77778],
				82: [0, 0.68889, 0, 0, 0.72222],
				83: [0, 0.68889, 0, 0, 0.55556],
				84: [0, 0.68889, 0, 0, 0.66667],
				85: [0, 0.68889, 0, 0, 0.72222],
				86: [0, 0.68889, 0, 0, 0.72222],
				87: [0, 0.68889, 0, 0, 1],
				88: [0, 0.68889, 0, 0, 0.72222],
				89: [0, 0.68889, 0, 0, 0.72222],
				90: [0, 0.68889, 0, 0, 0.66667],
				107: [0, 0.68889, 0, 0, 0.55556],
				160: [0, 0, 0, 0, 0.25],
				165: [0, 0.675, 0.025, 0, 0.75],
				174: [0.15559, 0.69224, 0, 0, 0.94666],
				240: [0, 0.68889, 0, 0, 0.55556],
				295: [0, 0.68889, 0, 0, 0.54028],
				710: [0, 0.825, 0, 0, 2.33334],
				732: [0, 0.9, 0, 0, 2.33334],
				770: [0, 0.825, 0, 0, 2.33334],
				771: [0, 0.9, 0, 0, 2.33334],
				989: [0.08167, 0.58167, 0, 0, 0.77778],
				1008: [0, 0.43056, 0.04028, 0, 0.66667],
				8245: [0, 0.54986, 0, 0, 0.275],
				8463: [0, 0.68889, 0, 0, 0.54028],
				8487: [0, 0.68889, 0, 0, 0.72222],
				8498: [0, 0.68889, 0, 0, 0.55556],
				8502: [0, 0.68889, 0, 0, 0.66667],
				8503: [0, 0.68889, 0, 0, 0.44445],
				8504: [0, 0.68889, 0, 0, 0.66667],
				8513: [0, 0.68889, 0, 0, 0.63889],
				8592: [-0.03598, 0.46402, 0, 0, 0.5],
				8594: [-0.03598, 0.46402, 0, 0, 0.5],
				8602: [-0.13313, 0.36687, 0, 0, 1],
				8603: [-0.13313, 0.36687, 0, 0, 1],
				8606: [0.01354, 0.52239, 0, 0, 1],
				8608: [0.01354, 0.52239, 0, 0, 1],
				8610: [0.01354, 0.52239, 0, 0, 1.11111],
				8611: [0.01354, 0.52239, 0, 0, 1.11111],
				8619: [0, 0.54986, 0, 0, 1],
				8620: [0, 0.54986, 0, 0, 1],
				8621: [-0.13313, 0.37788, 0, 0, 1.38889],
				8622: [-0.13313, 0.36687, 0, 0, 1],
				8624: [0, 0.69224, 0, 0, 0.5],
				8625: [0, 0.69224, 0, 0, 0.5],
				8630: [0, 0.43056, 0, 0, 1],
				8631: [0, 0.43056, 0, 0, 1],
				8634: [0.08198, 0.58198, 0, 0, 0.77778],
				8635: [0.08198, 0.58198, 0, 0, 0.77778],
				8638: [0.19444, 0.69224, 0, 0, 0.41667],
				8639: [0.19444, 0.69224, 0, 0, 0.41667],
				8642: [0.19444, 0.69224, 0, 0, 0.41667],
				8643: [0.19444, 0.69224, 0, 0, 0.41667],
				8644: [0.1808, 0.675, 0, 0, 1],
				8646: [0.1808, 0.675, 0, 0, 1],
				8647: [0.1808, 0.675, 0, 0, 1],
				8648: [0.19444, 0.69224, 0, 0, 0.83334],
				8649: [0.1808, 0.675, 0, 0, 1],
				8650: [0.19444, 0.69224, 0, 0, 0.83334],
				8651: [0.01354, 0.52239, 0, 0, 1],
				8652: [0.01354, 0.52239, 0, 0, 1],
				8653: [-0.13313, 0.36687, 0, 0, 1],
				8654: [-0.13313, 0.36687, 0, 0, 1],
				8655: [-0.13313, 0.36687, 0, 0, 1],
				8666: [0.13667, 0.63667, 0, 0, 1],
				8667: [0.13667, 0.63667, 0, 0, 1],
				8669: [-0.13313, 0.37788, 0, 0, 1],
				8672: [-0.064, 0.437, 0, 0, 1.334],
				8674: [-0.064, 0.437, 0, 0, 1.334],
				8705: [0, 0.825, 0, 0, 0.5],
				8708: [0, 0.68889, 0, 0, 0.55556],
				8709: [0.08167, 0.58167, 0, 0, 0.77778],
				8717: [0, 0.43056, 0, 0, 0.42917],
				8722: [-0.03598, 0.46402, 0, 0, 0.5],
				8724: [0.08198, 0.69224, 0, 0, 0.77778],
				8726: [0.08167, 0.58167, 0, 0, 0.77778],
				8733: [0, 0.69224, 0, 0, 0.77778],
				8736: [0, 0.69224, 0, 0, 0.72222],
				8737: [0, 0.69224, 0, 0, 0.72222],
				8738: [0.03517, 0.52239, 0, 0, 0.72222],
				8739: [0.08167, 0.58167, 0, 0, 0.22222],
				8740: [0.25142, 0.74111, 0, 0, 0.27778],
				8741: [0.08167, 0.58167, 0, 0, 0.38889],
				8742: [0.25142, 0.74111, 0, 0, 0.5],
				8756: [0, 0.69224, 0, 0, 0.66667],
				8757: [0, 0.69224, 0, 0, 0.66667],
				8764: [-0.13313, 0.36687, 0, 0, 0.77778],
				8765: [-0.13313, 0.37788, 0, 0, 0.77778],
				8769: [-0.13313, 0.36687, 0, 0, 0.77778],
				8770: [-0.03625, 0.46375, 0, 0, 0.77778],
				8774: [0.30274, 0.79383, 0, 0, 0.77778],
				8776: [-0.01688, 0.48312, 0, 0, 0.77778],
				8778: [0.08167, 0.58167, 0, 0, 0.77778],
				8782: [0.06062, 0.54986, 0, 0, 0.77778],
				8783: [0.06062, 0.54986, 0, 0, 0.77778],
				8785: [0.08198, 0.58198, 0, 0, 0.77778],
				8786: [0.08198, 0.58198, 0, 0, 0.77778],
				8787: [0.08198, 0.58198, 0, 0, 0.77778],
				8790: [0, 0.69224, 0, 0, 0.77778],
				8791: [0.22958, 0.72958, 0, 0, 0.77778],
				8796: [0.08198, 0.91667, 0, 0, 0.77778],
				8806: [0.25583, 0.75583, 0, 0, 0.77778],
				8807: [0.25583, 0.75583, 0, 0, 0.77778],
				8808: [0.25142, 0.75726, 0, 0, 0.77778],
				8809: [0.25142, 0.75726, 0, 0, 0.77778],
				8812: [0.25583, 0.75583, 0, 0, 0.5],
				8814: [0.20576, 0.70576, 0, 0, 0.77778],
				8815: [0.20576, 0.70576, 0, 0, 0.77778],
				8816: [0.30274, 0.79383, 0, 0, 0.77778],
				8817: [0.30274, 0.79383, 0, 0, 0.77778],
				8818: [0.22958, 0.72958, 0, 0, 0.77778],
				8819: [0.22958, 0.72958, 0, 0, 0.77778],
				8822: [0.1808, 0.675, 0, 0, 0.77778],
				8823: [0.1808, 0.675, 0, 0, 0.77778],
				8828: [0.13667, 0.63667, 0, 0, 0.77778],
				8829: [0.13667, 0.63667, 0, 0, 0.77778],
				8830: [0.22958, 0.72958, 0, 0, 0.77778],
				8831: [0.22958, 0.72958, 0, 0, 0.77778],
				8832: [0.20576, 0.70576, 0, 0, 0.77778],
				8833: [0.20576, 0.70576, 0, 0, 0.77778],
				8840: [0.30274, 0.79383, 0, 0, 0.77778],
				8841: [0.30274, 0.79383, 0, 0, 0.77778],
				8842: [0.13597, 0.63597, 0, 0, 0.77778],
				8843: [0.13597, 0.63597, 0, 0, 0.77778],
				8847: [0.03517, 0.54986, 0, 0, 0.77778],
				8848: [0.03517, 0.54986, 0, 0, 0.77778],
				8858: [0.08198, 0.58198, 0, 0, 0.77778],
				8859: [0.08198, 0.58198, 0, 0, 0.77778],
				8861: [0.08198, 0.58198, 0, 0, 0.77778],
				8862: [0, 0.675, 0, 0, 0.77778],
				8863: [0, 0.675, 0, 0, 0.77778],
				8864: [0, 0.675, 0, 0, 0.77778],
				8865: [0, 0.675, 0, 0, 0.77778],
				8872: [0, 0.69224, 0, 0, 0.61111],
				8873: [0, 0.69224, 0, 0, 0.72222],
				8874: [0, 0.69224, 0, 0, 0.88889],
				8876: [0, 0.68889, 0, 0, 0.61111],
				8877: [0, 0.68889, 0, 0, 0.61111],
				8878: [0, 0.68889, 0, 0, 0.72222],
				8879: [0, 0.68889, 0, 0, 0.72222],
				8882: [0.03517, 0.54986, 0, 0, 0.77778],
				8883: [0.03517, 0.54986, 0, 0, 0.77778],
				8884: [0.13667, 0.63667, 0, 0, 0.77778],
				8885: [0.13667, 0.63667, 0, 0, 0.77778],
				8888: [0, 0.54986, 0, 0, 1.11111],
				8890: [0.19444, 0.43056, 0, 0, 0.55556],
				8891: [0.19444, 0.69224, 0, 0, 0.61111],
				8892: [0.19444, 0.69224, 0, 0, 0.61111],
				8901: [0, 0.54986, 0, 0, 0.27778],
				8903: [0.08167, 0.58167, 0, 0, 0.77778],
				8905: [0.08167, 0.58167, 0, 0, 0.77778],
				8906: [0.08167, 0.58167, 0, 0, 0.77778],
				8907: [0, 0.69224, 0, 0, 0.77778],
				8908: [0, 0.69224, 0, 0, 0.77778],
				8909: [-0.03598, 0.46402, 0, 0, 0.77778],
				8910: [0, 0.54986, 0, 0, 0.76042],
				8911: [0, 0.54986, 0, 0, 0.76042],
				8912: [0.03517, 0.54986, 0, 0, 0.77778],
				8913: [0.03517, 0.54986, 0, 0, 0.77778],
				8914: [0, 0.54986, 0, 0, 0.66667],
				8915: [0, 0.54986, 0, 0, 0.66667],
				8916: [0, 0.69224, 0, 0, 0.66667],
				8918: [0.0391, 0.5391, 0, 0, 0.77778],
				8919: [0.0391, 0.5391, 0, 0, 0.77778],
				8920: [0.03517, 0.54986, 0, 0, 1.33334],
				8921: [0.03517, 0.54986, 0, 0, 1.33334],
				8922: [0.38569, 0.88569, 0, 0, 0.77778],
				8923: [0.38569, 0.88569, 0, 0, 0.77778],
				8926: [0.13667, 0.63667, 0, 0, 0.77778],
				8927: [0.13667, 0.63667, 0, 0, 0.77778],
				8928: [0.30274, 0.79383, 0, 0, 0.77778],
				8929: [0.30274, 0.79383, 0, 0, 0.77778],
				8934: [0.23222, 0.74111, 0, 0, 0.77778],
				8935: [0.23222, 0.74111, 0, 0, 0.77778],
				8936: [0.23222, 0.74111, 0, 0, 0.77778],
				8937: [0.23222, 0.74111, 0, 0, 0.77778],
				8938: [0.20576, 0.70576, 0, 0, 0.77778],
				8939: [0.20576, 0.70576, 0, 0, 0.77778],
				8940: [0.30274, 0.79383, 0, 0, 0.77778],
				8941: [0.30274, 0.79383, 0, 0, 0.77778],
				8994: [0.19444, 0.69224, 0, 0, 0.77778],
				8995: [0.19444, 0.69224, 0, 0, 0.77778],
				9416: [0.15559, 0.69224, 0, 0, 0.90222],
				9484: [0, 0.69224, 0, 0, 0.5],
				9488: [0, 0.69224, 0, 0, 0.5],
				9492: [0, 0.37788, 0, 0, 0.5],
				9496: [0, 0.37788, 0, 0, 0.5],
				9585: [0.19444, 0.68889, 0, 0, 0.88889],
				9586: [0.19444, 0.74111, 0, 0, 0.88889],
				9632: [0, 0.675, 0, 0, 0.77778],
				9633: [0, 0.675, 0, 0, 0.77778],
				9650: [0, 0.54986, 0, 0, 0.72222],
				9651: [0, 0.54986, 0, 0, 0.72222],
				9654: [0.03517, 0.54986, 0, 0, 0.77778],
				9660: [0, 0.54986, 0, 0, 0.72222],
				9661: [0, 0.54986, 0, 0, 0.72222],
				9664: [0.03517, 0.54986, 0, 0, 0.77778],
				9674: [0.11111, 0.69224, 0, 0, 0.66667],
				9733: [0.19444, 0.69224, 0, 0, 0.94445],
				10003: [0, 0.69224, 0, 0, 0.83334],
				10016: [0, 0.69224, 0, 0, 0.83334],
				10731: [0.11111, 0.69224, 0, 0, 0.66667],
				10846: [0.19444, 0.75583, 0, 0, 0.61111],
				10877: [0.13667, 0.63667, 0, 0, 0.77778],
				10878: [0.13667, 0.63667, 0, 0, 0.77778],
				10885: [0.25583, 0.75583, 0, 0, 0.77778],
				10886: [0.25583, 0.75583, 0, 0, 0.77778],
				10887: [0.13597, 0.63597, 0, 0, 0.77778],
				10888: [0.13597, 0.63597, 0, 0, 0.77778],
				10889: [0.26167, 0.75726, 0, 0, 0.77778],
				10890: [0.26167, 0.75726, 0, 0, 0.77778],
				10891: [0.48256, 0.98256, 0, 0, 0.77778],
				10892: [0.48256, 0.98256, 0, 0, 0.77778],
				10901: [0.13667, 0.63667, 0, 0, 0.77778],
				10902: [0.13667, 0.63667, 0, 0, 0.77778],
				10933: [0.25142, 0.75726, 0, 0, 0.77778],
				10934: [0.25142, 0.75726, 0, 0, 0.77778],
				10935: [0.26167, 0.75726, 0, 0, 0.77778],
				10936: [0.26167, 0.75726, 0, 0, 0.77778],
				10937: [0.26167, 0.75726, 0, 0, 0.77778],
				10938: [0.26167, 0.75726, 0, 0, 0.77778],
				10949: [0.25583, 0.75583, 0, 0, 0.77778],
				10950: [0.25583, 0.75583, 0, 0, 0.77778],
				10955: [0.28481, 0.79383, 0, 0, 0.77778],
				10956: [0.28481, 0.79383, 0, 0, 0.77778],
				57350: [0.08167, 0.58167, 0, 0, 0.22222],
				57351: [0.08167, 0.58167, 0, 0, 0.38889],
				57352: [0.08167, 0.58167, 0, 0, 0.77778],
				57353: [0, 0.43056, 0.04028, 0, 0.66667],
				57356: [0.25142, 0.75726, 0, 0, 0.77778],
				57357: [0.25142, 0.75726, 0, 0, 0.77778],
				57358: [0.41951, 0.91951, 0, 0, 0.77778],
				57359: [0.30274, 0.79383, 0, 0, 0.77778],
				57360: [0.30274, 0.79383, 0, 0, 0.77778],
				57361: [0.41951, 0.91951, 0, 0, 0.77778],
				57366: [0.25142, 0.75726, 0, 0, 0.77778],
				57367: [0.25142, 0.75726, 0, 0, 0.77778],
				57368: [0.25142, 0.75726, 0, 0, 0.77778],
				57369: [0.25142, 0.75726, 0, 0, 0.77778],
				57370: [0.13597, 0.63597, 0, 0, 0.77778],
				57371: [0.13597, 0.63597, 0, 0, 0.77778],
			},
			"Caligraphic-Regular": {
				32: [0, 0, 0, 0, 0.25],
				65: [0, 0.68333, 0, 0.19445, 0.79847],
				66: [0, 0.68333, 0.03041, 0.13889, 0.65681],
				67: [0, 0.68333, 0.05834, 0.13889, 0.52653],
				68: [0, 0.68333, 0.02778, 0.08334, 0.77139],
				69: [0, 0.68333, 0.08944, 0.11111, 0.52778],
				70: [0, 0.68333, 0.09931, 0.11111, 0.71875],
				71: [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
				72: [0, 0.68333, 0.00965, 0.11111, 0.84452],
				73: [0, 0.68333, 0.07382, 0, 0.54452],
				74: [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
				75: [0, 0.68333, 0.01445, 0.05556, 0.76195],
				76: [0, 0.68333, 0, 0.13889, 0.68972],
				77: [0, 0.68333, 0, 0.13889, 1.2009],
				78: [0, 0.68333, 0.14736, 0.08334, 0.82049],
				79: [0, 0.68333, 0.02778, 0.11111, 0.79611],
				80: [0, 0.68333, 0.08222, 0.08334, 0.69556],
				81: [0.09722, 0.68333, 0, 0.11111, 0.81667],
				82: [0, 0.68333, 0, 0.08334, 0.8475],
				83: [0, 0.68333, 0.075, 0.13889, 0.60556],
				84: [0, 0.68333, 0.25417, 0, 0.54464],
				85: [0, 0.68333, 0.09931, 0.08334, 0.62583],
				86: [0, 0.68333, 0.08222, 0, 0.61278],
				87: [0, 0.68333, 0.08222, 0.08334, 0.98778],
				88: [0, 0.68333, 0.14643, 0.13889, 0.7133],
				89: [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
				90: [0, 0.68333, 0.07944, 0.13889, 0.72473],
				160: [0, 0, 0, 0, 0.25],
			},
			"Fraktur-Regular": {
				32: [0, 0, 0, 0, 0.25],
				33: [0, 0.69141, 0, 0, 0.29574],
				34: [0, 0.69141, 0, 0, 0.21471],
				38: [0, 0.69141, 0, 0, 0.73786],
				39: [0, 0.69141, 0, 0, 0.21201],
				40: [0.24982, 0.74947, 0, 0, 0.38865],
				41: [0.24982, 0.74947, 0, 0, 0.38865],
				42: [0, 0.62119, 0, 0, 0.27764],
				43: [0.08319, 0.58283, 0, 0, 0.75623],
				44: [0, 0.10803, 0, 0, 0.27764],
				45: [0.08319, 0.58283, 0, 0, 0.75623],
				46: [0, 0.10803, 0, 0, 0.27764],
				47: [0.24982, 0.74947, 0, 0, 0.50181],
				48: [0, 0.47534, 0, 0, 0.50181],
				49: [0, 0.47534, 0, 0, 0.50181],
				50: [0, 0.47534, 0, 0, 0.50181],
				51: [0.18906, 0.47534, 0, 0, 0.50181],
				52: [0.18906, 0.47534, 0, 0, 0.50181],
				53: [0.18906, 0.47534, 0, 0, 0.50181],
				54: [0, 0.69141, 0, 0, 0.50181],
				55: [0.18906, 0.47534, 0, 0, 0.50181],
				56: [0, 0.69141, 0, 0, 0.50181],
				57: [0.18906, 0.47534, 0, 0, 0.50181],
				58: [0, 0.47534, 0, 0, 0.21606],
				59: [0.12604, 0.47534, 0, 0, 0.21606],
				61: [-0.13099, 0.36866, 0, 0, 0.75623],
				63: [0, 0.69141, 0, 0, 0.36245],
				65: [0, 0.69141, 0, 0, 0.7176],
				66: [0, 0.69141, 0, 0, 0.88397],
				67: [0, 0.69141, 0, 0, 0.61254],
				68: [0, 0.69141, 0, 0, 0.83158],
				69: [0, 0.69141, 0, 0, 0.66278],
				70: [0.12604, 0.69141, 0, 0, 0.61119],
				71: [0, 0.69141, 0, 0, 0.78539],
				72: [0.06302, 0.69141, 0, 0, 0.7203],
				73: [0, 0.69141, 0, 0, 0.55448],
				74: [0.12604, 0.69141, 0, 0, 0.55231],
				75: [0, 0.69141, 0, 0, 0.66845],
				76: [0, 0.69141, 0, 0, 0.66602],
				77: [0, 0.69141, 0, 0, 1.04953],
				78: [0, 0.69141, 0, 0, 0.83212],
				79: [0, 0.69141, 0, 0, 0.82699],
				80: [0.18906, 0.69141, 0, 0, 0.82753],
				81: [0.03781, 0.69141, 0, 0, 0.82699],
				82: [0, 0.69141, 0, 0, 0.82807],
				83: [0, 0.69141, 0, 0, 0.82861],
				84: [0, 0.69141, 0, 0, 0.66899],
				85: [0, 0.69141, 0, 0, 0.64576],
				86: [0, 0.69141, 0, 0, 0.83131],
				87: [0, 0.69141, 0, 0, 1.04602],
				88: [0, 0.69141, 0, 0, 0.71922],
				89: [0.18906, 0.69141, 0, 0, 0.83293],
				90: [0.12604, 0.69141, 0, 0, 0.60201],
				91: [0.24982, 0.74947, 0, 0, 0.27764],
				93: [0.24982, 0.74947, 0, 0, 0.27764],
				94: [0, 0.69141, 0, 0, 0.49965],
				97: [0, 0.47534, 0, 0, 0.50046],
				98: [0, 0.69141, 0, 0, 0.51315],
				99: [0, 0.47534, 0, 0, 0.38946],
				100: [0, 0.62119, 0, 0, 0.49857],
				101: [0, 0.47534, 0, 0, 0.40053],
				102: [0.18906, 0.69141, 0, 0, 0.32626],
				103: [0.18906, 0.47534, 0, 0, 0.5037],
				104: [0.18906, 0.69141, 0, 0, 0.52126],
				105: [0, 0.69141, 0, 0, 0.27899],
				106: [0, 0.69141, 0, 0, 0.28088],
				107: [0, 0.69141, 0, 0, 0.38946],
				108: [0, 0.69141, 0, 0, 0.27953],
				109: [0, 0.47534, 0, 0, 0.76676],
				110: [0, 0.47534, 0, 0, 0.52666],
				111: [0, 0.47534, 0, 0, 0.48885],
				112: [0.18906, 0.52396, 0, 0, 0.50046],
				113: [0.18906, 0.47534, 0, 0, 0.48912],
				114: [0, 0.47534, 0, 0, 0.38919],
				115: [0, 0.47534, 0, 0, 0.44266],
				116: [0, 0.62119, 0, 0, 0.33301],
				117: [0, 0.47534, 0, 0, 0.5172],
				118: [0, 0.52396, 0, 0, 0.5118],
				119: [0, 0.52396, 0, 0, 0.77351],
				120: [0.18906, 0.47534, 0, 0, 0.38865],
				121: [0.18906, 0.47534, 0, 0, 0.49884],
				122: [0.18906, 0.47534, 0, 0, 0.39054],
				160: [0, 0, 0, 0, 0.25],
				8216: [0, 0.69141, 0, 0, 0.21471],
				8217: [0, 0.69141, 0, 0, 0.21471],
				58112: [0, 0.62119, 0, 0, 0.49749],
				58113: [0, 0.62119, 0, 0, 0.4983],
				58114: [0.18906, 0.69141, 0, 0, 0.33328],
				58115: [0.18906, 0.69141, 0, 0, 0.32923],
				58116: [0.18906, 0.47534, 0, 0, 0.50343],
				58117: [0, 0.69141, 0, 0, 0.33301],
				58118: [0, 0.62119, 0, 0, 0.33409],
				58119: [0, 0.47534, 0, 0, 0.50073],
			},
			"Main-Bold": {
				32: [0, 0, 0, 0, 0.25],
				33: [0, 0.69444, 0, 0, 0.35],
				34: [0, 0.69444, 0, 0, 0.60278],
				35: [0.19444, 0.69444, 0, 0, 0.95833],
				36: [0.05556, 0.75, 0, 0, 0.575],
				37: [0.05556, 0.75, 0, 0, 0.95833],
				38: [0, 0.69444, 0, 0, 0.89444],
				39: [0, 0.69444, 0, 0, 0.31944],
				40: [0.25, 0.75, 0, 0, 0.44722],
				41: [0.25, 0.75, 0, 0, 0.44722],
				42: [0, 0.75, 0, 0, 0.575],
				43: [0.13333, 0.63333, 0, 0, 0.89444],
				44: [0.19444, 0.15556, 0, 0, 0.31944],
				45: [0, 0.44444, 0, 0, 0.38333],
				46: [0, 0.15556, 0, 0, 0.31944],
				47: [0.25, 0.75, 0, 0, 0.575],
				48: [0, 0.64444, 0, 0, 0.575],
				49: [0, 0.64444, 0, 0, 0.575],
				50: [0, 0.64444, 0, 0, 0.575],
				51: [0, 0.64444, 0, 0, 0.575],
				52: [0, 0.64444, 0, 0, 0.575],
				53: [0, 0.64444, 0, 0, 0.575],
				54: [0, 0.64444, 0, 0, 0.575],
				55: [0, 0.64444, 0, 0, 0.575],
				56: [0, 0.64444, 0, 0, 0.575],
				57: [0, 0.64444, 0, 0, 0.575],
				58: [0, 0.44444, 0, 0, 0.31944],
				59: [0.19444, 0.44444, 0, 0, 0.31944],
				60: [0.08556, 0.58556, 0, 0, 0.89444],
				61: [-0.10889, 0.39111, 0, 0, 0.89444],
				62: [0.08556, 0.58556, 0, 0, 0.89444],
				63: [0, 0.69444, 0, 0, 0.54305],
				64: [0, 0.69444, 0, 0, 0.89444],
				65: [0, 0.68611, 0, 0, 0.86944],
				66: [0, 0.68611, 0, 0, 0.81805],
				67: [0, 0.68611, 0, 0, 0.83055],
				68: [0, 0.68611, 0, 0, 0.88194],
				69: [0, 0.68611, 0, 0, 0.75555],
				70: [0, 0.68611, 0, 0, 0.72361],
				71: [0, 0.68611, 0, 0, 0.90416],
				72: [0, 0.68611, 0, 0, 0.9],
				73: [0, 0.68611, 0, 0, 0.43611],
				74: [0, 0.68611, 0, 0, 0.59444],
				75: [0, 0.68611, 0, 0, 0.90138],
				76: [0, 0.68611, 0, 0, 0.69166],
				77: [0, 0.68611, 0, 0, 1.09166],
				78: [0, 0.68611, 0, 0, 0.9],
				79: [0, 0.68611, 0, 0, 0.86388],
				80: [0, 0.68611, 0, 0, 0.78611],
				81: [0.19444, 0.68611, 0, 0, 0.86388],
				82: [0, 0.68611, 0, 0, 0.8625],
				83: [0, 0.68611, 0, 0, 0.63889],
				84: [0, 0.68611, 0, 0, 0.8],
				85: [0, 0.68611, 0, 0, 0.88472],
				86: [0, 0.68611, 0.01597, 0, 0.86944],
				87: [0, 0.68611, 0.01597, 0, 1.18888],
				88: [0, 0.68611, 0, 0, 0.86944],
				89: [0, 0.68611, 0.02875, 0, 0.86944],
				90: [0, 0.68611, 0, 0, 0.70277],
				91: [0.25, 0.75, 0, 0, 0.31944],
				92: [0.25, 0.75, 0, 0, 0.575],
				93: [0.25, 0.75, 0, 0, 0.31944],
				94: [0, 0.69444, 0, 0, 0.575],
				95: [0.31, 0.13444, 0.03194, 0, 0.575],
				97: [0, 0.44444, 0, 0, 0.55902],
				98: [0, 0.69444, 0, 0, 0.63889],
				99: [0, 0.44444, 0, 0, 0.51111],
				100: [0, 0.69444, 0, 0, 0.63889],
				101: [0, 0.44444, 0, 0, 0.52708],
				102: [0, 0.69444, 0.10903, 0, 0.35139],
				103: [0.19444, 0.44444, 0.01597, 0, 0.575],
				104: [0, 0.69444, 0, 0, 0.63889],
				105: [0, 0.69444, 0, 0, 0.31944],
				106: [0.19444, 0.69444, 0, 0, 0.35139],
				107: [0, 0.69444, 0, 0, 0.60694],
				108: [0, 0.69444, 0, 0, 0.31944],
				109: [0, 0.44444, 0, 0, 0.95833],
				110: [0, 0.44444, 0, 0, 0.63889],
				111: [0, 0.44444, 0, 0, 0.575],
				112: [0.19444, 0.44444, 0, 0, 0.63889],
				113: [0.19444, 0.44444, 0, 0, 0.60694],
				114: [0, 0.44444, 0, 0, 0.47361],
				115: [0, 0.44444, 0, 0, 0.45361],
				116: [0, 0.63492, 0, 0, 0.44722],
				117: [0, 0.44444, 0, 0, 0.63889],
				118: [0, 0.44444, 0.01597, 0, 0.60694],
				119: [0, 0.44444, 0.01597, 0, 0.83055],
				120: [0, 0.44444, 0, 0, 0.60694],
				121: [0.19444, 0.44444, 0.01597, 0, 0.60694],
				122: [0, 0.44444, 0, 0, 0.51111],
				123: [0.25, 0.75, 0, 0, 0.575],
				124: [0.25, 0.75, 0, 0, 0.31944],
				125: [0.25, 0.75, 0, 0, 0.575],
				126: [0.35, 0.34444, 0, 0, 0.575],
				160: [0, 0, 0, 0, 0.25],
				163: [0, 0.69444, 0, 0, 0.86853],
				168: [0, 0.69444, 0, 0, 0.575],
				172: [0, 0.44444, 0, 0, 0.76666],
				176: [0, 0.69444, 0, 0, 0.86944],
				177: [0.13333, 0.63333, 0, 0, 0.89444],
				184: [0.17014, 0, 0, 0, 0.51111],
				198: [0, 0.68611, 0, 0, 1.04166],
				215: [0.13333, 0.63333, 0, 0, 0.89444],
				216: [0.04861, 0.73472, 0, 0, 0.89444],
				223: [0, 0.69444, 0, 0, 0.59722],
				230: [0, 0.44444, 0, 0, 0.83055],
				247: [0.13333, 0.63333, 0, 0, 0.89444],
				248: [0.09722, 0.54167, 0, 0, 0.575],
				305: [0, 0.44444, 0, 0, 0.31944],
				338: [0, 0.68611, 0, 0, 1.16944],
				339: [0, 0.44444, 0, 0, 0.89444],
				567: [0.19444, 0.44444, 0, 0, 0.35139],
				710: [0, 0.69444, 0, 0, 0.575],
				711: [0, 0.63194, 0, 0, 0.575],
				713: [0, 0.59611, 0, 0, 0.575],
				714: [0, 0.69444, 0, 0, 0.575],
				715: [0, 0.69444, 0, 0, 0.575],
				728: [0, 0.69444, 0, 0, 0.575],
				729: [0, 0.69444, 0, 0, 0.31944],
				730: [0, 0.69444, 0, 0, 0.86944],
				732: [0, 0.69444, 0, 0, 0.575],
				733: [0, 0.69444, 0, 0, 0.575],
				915: [0, 0.68611, 0, 0, 0.69166],
				916: [0, 0.68611, 0, 0, 0.95833],
				920: [0, 0.68611, 0, 0, 0.89444],
				923: [0, 0.68611, 0, 0, 0.80555],
				926: [0, 0.68611, 0, 0, 0.76666],
				928: [0, 0.68611, 0, 0, 0.9],
				931: [0, 0.68611, 0, 0, 0.83055],
				933: [0, 0.68611, 0, 0, 0.89444],
				934: [0, 0.68611, 0, 0, 0.83055],
				936: [0, 0.68611, 0, 0, 0.89444],
				937: [0, 0.68611, 0, 0, 0.83055],
				8211: [0, 0.44444, 0.03194, 0, 0.575],
				8212: [0, 0.44444, 0.03194, 0, 1.14999],
				8216: [0, 0.69444, 0, 0, 0.31944],
				8217: [0, 0.69444, 0, 0, 0.31944],
				8220: [0, 0.69444, 0, 0, 0.60278],
				8221: [0, 0.69444, 0, 0, 0.60278],
				8224: [0.19444, 0.69444, 0, 0, 0.51111],
				8225: [0.19444, 0.69444, 0, 0, 0.51111],
				8242: [0, 0.55556, 0, 0, 0.34444],
				8407: [0, 0.72444, 0.15486, 0, 0.575],
				8463: [0, 0.69444, 0, 0, 0.66759],
				8465: [0, 0.69444, 0, 0, 0.83055],
				8467: [0, 0.69444, 0, 0, 0.47361],
				8472: [0.19444, 0.44444, 0, 0, 0.74027],
				8476: [0, 0.69444, 0, 0, 0.83055],
				8501: [0, 0.69444, 0, 0, 0.70277],
				8592: [-0.10889, 0.39111, 0, 0, 1.14999],
				8593: [0.19444, 0.69444, 0, 0, 0.575],
				8594: [-0.10889, 0.39111, 0, 0, 1.14999],
				8595: [0.19444, 0.69444, 0, 0, 0.575],
				8596: [-0.10889, 0.39111, 0, 0, 1.14999],
				8597: [0.25, 0.75, 0, 0, 0.575],
				8598: [0.19444, 0.69444, 0, 0, 1.14999],
				8599: [0.19444, 0.69444, 0, 0, 1.14999],
				8600: [0.19444, 0.69444, 0, 0, 1.14999],
				8601: [0.19444, 0.69444, 0, 0, 1.14999],
				8636: [-0.10889, 0.39111, 0, 0, 1.14999],
				8637: [-0.10889, 0.39111, 0, 0, 1.14999],
				8640: [-0.10889, 0.39111, 0, 0, 1.14999],
				8641: [-0.10889, 0.39111, 0, 0, 1.14999],
				8656: [-0.10889, 0.39111, 0, 0, 1.14999],
				8657: [0.19444, 0.69444, 0, 0, 0.70277],
				8658: [-0.10889, 0.39111, 0, 0, 1.14999],
				8659: [0.19444, 0.69444, 0, 0, 0.70277],
				8660: [-0.10889, 0.39111, 0, 0, 1.14999],
				8661: [0.25, 0.75, 0, 0, 0.70277],
				8704: [0, 0.69444, 0, 0, 0.63889],
				8706: [0, 0.69444, 0.06389, 0, 0.62847],
				8707: [0, 0.69444, 0, 0, 0.63889],
				8709: [0.05556, 0.75, 0, 0, 0.575],
				8711: [0, 0.68611, 0, 0, 0.95833],
				8712: [0.08556, 0.58556, 0, 0, 0.76666],
				8715: [0.08556, 0.58556, 0, 0, 0.76666],
				8722: [0.13333, 0.63333, 0, 0, 0.89444],
				8723: [0.13333, 0.63333, 0, 0, 0.89444],
				8725: [0.25, 0.75, 0, 0, 0.575],
				8726: [0.25, 0.75, 0, 0, 0.575],
				8727: [-0.02778, 0.47222, 0, 0, 0.575],
				8728: [-0.02639, 0.47361, 0, 0, 0.575],
				8729: [-0.02639, 0.47361, 0, 0, 0.575],
				8730: [0.18, 0.82, 0, 0, 0.95833],
				8733: [0, 0.44444, 0, 0, 0.89444],
				8734: [0, 0.44444, 0, 0, 1.14999],
				8736: [0, 0.69224, 0, 0, 0.72222],
				8739: [0.25, 0.75, 0, 0, 0.31944],
				8741: [0.25, 0.75, 0, 0, 0.575],
				8743: [0, 0.55556, 0, 0, 0.76666],
				8744: [0, 0.55556, 0, 0, 0.76666],
				8745: [0, 0.55556, 0, 0, 0.76666],
				8746: [0, 0.55556, 0, 0, 0.76666],
				8747: [0.19444, 0.69444, 0.12778, 0, 0.56875],
				8764: [-0.10889, 0.39111, 0, 0, 0.89444],
				8768: [0.19444, 0.69444, 0, 0, 0.31944],
				8771: [0.00222, 0.50222, 0, 0, 0.89444],
				8773: [0.027, 0.638, 0, 0, 0.894],
				8776: [0.02444, 0.52444, 0, 0, 0.89444],
				8781: [0.00222, 0.50222, 0, 0, 0.89444],
				8801: [0.00222, 0.50222, 0, 0, 0.89444],
				8804: [0.19667, 0.69667, 0, 0, 0.89444],
				8805: [0.19667, 0.69667, 0, 0, 0.89444],
				8810: [0.08556, 0.58556, 0, 0, 1.14999],
				8811: [0.08556, 0.58556, 0, 0, 1.14999],
				8826: [0.08556, 0.58556, 0, 0, 0.89444],
				8827: [0.08556, 0.58556, 0, 0, 0.89444],
				8834: [0.08556, 0.58556, 0, 0, 0.89444],
				8835: [0.08556, 0.58556, 0, 0, 0.89444],
				8838: [0.19667, 0.69667, 0, 0, 0.89444],
				8839: [0.19667, 0.69667, 0, 0, 0.89444],
				8846: [0, 0.55556, 0, 0, 0.76666],
				8849: [0.19667, 0.69667, 0, 0, 0.89444],
				8850: [0.19667, 0.69667, 0, 0, 0.89444],
				8851: [0, 0.55556, 0, 0, 0.76666],
				8852: [0, 0.55556, 0, 0, 0.76666],
				8853: [0.13333, 0.63333, 0, 0, 0.89444],
				8854: [0.13333, 0.63333, 0, 0, 0.89444],
				8855: [0.13333, 0.63333, 0, 0, 0.89444],
				8856: [0.13333, 0.63333, 0, 0, 0.89444],
				8857: [0.13333, 0.63333, 0, 0, 0.89444],
				8866: [0, 0.69444, 0, 0, 0.70277],
				8867: [0, 0.69444, 0, 0, 0.70277],
				8868: [0, 0.69444, 0, 0, 0.89444],
				8869: [0, 0.69444, 0, 0, 0.89444],
				8900: [-0.02639, 0.47361, 0, 0, 0.575],
				8901: [-0.02639, 0.47361, 0, 0, 0.31944],
				8902: [-0.02778, 0.47222, 0, 0, 0.575],
				8968: [0.25, 0.75, 0, 0, 0.51111],
				8969: [0.25, 0.75, 0, 0, 0.51111],
				8970: [0.25, 0.75, 0, 0, 0.51111],
				8971: [0.25, 0.75, 0, 0, 0.51111],
				8994: [-0.13889, 0.36111, 0, 0, 1.14999],
				8995: [-0.13889, 0.36111, 0, 0, 1.14999],
				9651: [0.19444, 0.69444, 0, 0, 1.02222],
				9657: [-0.02778, 0.47222, 0, 0, 0.575],
				9661: [0.19444, 0.69444, 0, 0, 1.02222],
				9667: [-0.02778, 0.47222, 0, 0, 0.575],
				9711: [0.19444, 0.69444, 0, 0, 1.14999],
				9824: [0.12963, 0.69444, 0, 0, 0.89444],
				9825: [0.12963, 0.69444, 0, 0, 0.89444],
				9826: [0.12963, 0.69444, 0, 0, 0.89444],
				9827: [0.12963, 0.69444, 0, 0, 0.89444],
				9837: [0, 0.75, 0, 0, 0.44722],
				9838: [0.19444, 0.69444, 0, 0, 0.44722],
				9839: [0.19444, 0.69444, 0, 0, 0.44722],
				10216: [0.25, 0.75, 0, 0, 0.44722],
				10217: [0.25, 0.75, 0, 0, 0.44722],
				10815: [0, 0.68611, 0, 0, 0.9],
				10927: [0.19667, 0.69667, 0, 0, 0.89444],
				10928: [0.19667, 0.69667, 0, 0, 0.89444],
				57376: [0.19444, 0.69444, 0, 0, 0],
			},
			"Main-BoldItalic": {
				32: [0, 0, 0, 0, 0.25],
				33: [0, 0.69444, 0.11417, 0, 0.38611],
				34: [0, 0.69444, 0.07939, 0, 0.62055],
				35: [0.19444, 0.69444, 0.06833, 0, 0.94444],
				37: [0.05556, 0.75, 0.12861, 0, 0.94444],
				38: [0, 0.69444, 0.08528, 0, 0.88555],
				39: [0, 0.69444, 0.12945, 0, 0.35555],
				40: [0.25, 0.75, 0.15806, 0, 0.47333],
				41: [0.25, 0.75, 0.03306, 0, 0.47333],
				42: [0, 0.75, 0.14333, 0, 0.59111],
				43: [0.10333, 0.60333, 0.03306, 0, 0.88555],
				44: [0.19444, 0.14722, 0, 0, 0.35555],
				45: [0, 0.44444, 0.02611, 0, 0.41444],
				46: [0, 0.14722, 0, 0, 0.35555],
				47: [0.25, 0.75, 0.15806, 0, 0.59111],
				48: [0, 0.64444, 0.13167, 0, 0.59111],
				49: [0, 0.64444, 0.13167, 0, 0.59111],
				50: [0, 0.64444, 0.13167, 0, 0.59111],
				51: [0, 0.64444, 0.13167, 0, 0.59111],
				52: [0.19444, 0.64444, 0.13167, 0, 0.59111],
				53: [0, 0.64444, 0.13167, 0, 0.59111],
				54: [0, 0.64444, 0.13167, 0, 0.59111],
				55: [0.19444, 0.64444, 0.13167, 0, 0.59111],
				56: [0, 0.64444, 0.13167, 0, 0.59111],
				57: [0, 0.64444, 0.13167, 0, 0.59111],
				58: [0, 0.44444, 0.06695, 0, 0.35555],
				59: [0.19444, 0.44444, 0.06695, 0, 0.35555],
				61: [-0.10889, 0.39111, 0.06833, 0, 0.88555],
				63: [0, 0.69444, 0.11472, 0, 0.59111],
				64: [0, 0.69444, 0.09208, 0, 0.88555],
				65: [0, 0.68611, 0, 0, 0.86555],
				66: [0, 0.68611, 0.0992, 0, 0.81666],
				67: [0, 0.68611, 0.14208, 0, 0.82666],
				68: [0, 0.68611, 0.09062, 0, 0.87555],
				69: [0, 0.68611, 0.11431, 0, 0.75666],
				70: [0, 0.68611, 0.12903, 0, 0.72722],
				71: [0, 0.68611, 0.07347, 0, 0.89527],
				72: [0, 0.68611, 0.17208, 0, 0.8961],
				73: [0, 0.68611, 0.15681, 0, 0.47166],
				74: [0, 0.68611, 0.145, 0, 0.61055],
				75: [0, 0.68611, 0.14208, 0, 0.89499],
				76: [0, 0.68611, 0, 0, 0.69777],
				77: [0, 0.68611, 0.17208, 0, 1.07277],
				78: [0, 0.68611, 0.17208, 0, 0.8961],
				79: [0, 0.68611, 0.09062, 0, 0.85499],
				80: [0, 0.68611, 0.0992, 0, 0.78721],
				81: [0.19444, 0.68611, 0.09062, 0, 0.85499],
				82: [0, 0.68611, 0.02559, 0, 0.85944],
				83: [0, 0.68611, 0.11264, 0, 0.64999],
				84: [0, 0.68611, 0.12903, 0, 0.7961],
				85: [0, 0.68611, 0.17208, 0, 0.88083],
				86: [0, 0.68611, 0.18625, 0, 0.86555],
				87: [0, 0.68611, 0.18625, 0, 1.15999],
				88: [0, 0.68611, 0.15681, 0, 0.86555],
				89: [0, 0.68611, 0.19803, 0, 0.86555],
				90: [0, 0.68611, 0.14208, 0, 0.70888],
				91: [0.25, 0.75, 0.1875, 0, 0.35611],
				93: [0.25, 0.75, 0.09972, 0, 0.35611],
				94: [0, 0.69444, 0.06709, 0, 0.59111],
				95: [0.31, 0.13444, 0.09811, 0, 0.59111],
				97: [0, 0.44444, 0.09426, 0, 0.59111],
				98: [0, 0.69444, 0.07861, 0, 0.53222],
				99: [0, 0.44444, 0.05222, 0, 0.53222],
				100: [0, 0.69444, 0.10861, 0, 0.59111],
				101: [0, 0.44444, 0.085, 0, 0.53222],
				102: [0.19444, 0.69444, 0.21778, 0, 0.4],
				103: [0.19444, 0.44444, 0.105, 0, 0.53222],
				104: [0, 0.69444, 0.09426, 0, 0.59111],
				105: [0, 0.69326, 0.11387, 0, 0.35555],
				106: [0.19444, 0.69326, 0.1672, 0, 0.35555],
				107: [0, 0.69444, 0.11111, 0, 0.53222],
				108: [0, 0.69444, 0.10861, 0, 0.29666],
				109: [0, 0.44444, 0.09426, 0, 0.94444],
				110: [0, 0.44444, 0.09426, 0, 0.64999],
				111: [0, 0.44444, 0.07861, 0, 0.59111],
				112: [0.19444, 0.44444, 0.07861, 0, 0.59111],
				113: [0.19444, 0.44444, 0.105, 0, 0.53222],
				114: [0, 0.44444, 0.11111, 0, 0.50167],
				115: [0, 0.44444, 0.08167, 0, 0.48694],
				116: [0, 0.63492, 0.09639, 0, 0.385],
				117: [0, 0.44444, 0.09426, 0, 0.62055],
				118: [0, 0.44444, 0.11111, 0, 0.53222],
				119: [0, 0.44444, 0.11111, 0, 0.76777],
				120: [0, 0.44444, 0.12583, 0, 0.56055],
				121: [0.19444, 0.44444, 0.105, 0, 0.56166],
				122: [0, 0.44444, 0.13889, 0, 0.49055],
				126: [0.35, 0.34444, 0.11472, 0, 0.59111],
				160: [0, 0, 0, 0, 0.25],
				168: [0, 0.69444, 0.11473, 0, 0.59111],
				176: [0, 0.69444, 0, 0, 0.94888],
				184: [0.17014, 0, 0, 0, 0.53222],
				198: [0, 0.68611, 0.11431, 0, 1.02277],
				216: [0.04861, 0.73472, 0.09062, 0, 0.88555],
				223: [0.19444, 0.69444, 0.09736, 0, 0.665],
				230: [0, 0.44444, 0.085, 0, 0.82666],
				248: [0.09722, 0.54167, 0.09458, 0, 0.59111],
				305: [0, 0.44444, 0.09426, 0, 0.35555],
				338: [0, 0.68611, 0.11431, 0, 1.14054],
				339: [0, 0.44444, 0.085, 0, 0.82666],
				567: [0.19444, 0.44444, 0.04611, 0, 0.385],
				710: [0, 0.69444, 0.06709, 0, 0.59111],
				711: [0, 0.63194, 0.08271, 0, 0.59111],
				713: [0, 0.59444, 0.10444, 0, 0.59111],
				714: [0, 0.69444, 0.08528, 0, 0.59111],
				715: [0, 0.69444, 0, 0, 0.59111],
				728: [0, 0.69444, 0.10333, 0, 0.59111],
				729: [0, 0.69444, 0.12945, 0, 0.35555],
				730: [0, 0.69444, 0, 0, 0.94888],
				732: [0, 0.69444, 0.11472, 0, 0.59111],
				733: [0, 0.69444, 0.11472, 0, 0.59111],
				915: [0, 0.68611, 0.12903, 0, 0.69777],
				916: [0, 0.68611, 0, 0, 0.94444],
				920: [0, 0.68611, 0.09062, 0, 0.88555],
				923: [0, 0.68611, 0, 0, 0.80666],
				926: [0, 0.68611, 0.15092, 0, 0.76777],
				928: [0, 0.68611, 0.17208, 0, 0.8961],
				931: [0, 0.68611, 0.11431, 0, 0.82666],
				933: [0, 0.68611, 0.10778, 0, 0.88555],
				934: [0, 0.68611, 0.05632, 0, 0.82666],
				936: [0, 0.68611, 0.10778, 0, 0.88555],
				937: [0, 0.68611, 0.0992, 0, 0.82666],
				8211: [0, 0.44444, 0.09811, 0, 0.59111],
				8212: [0, 0.44444, 0.09811, 0, 1.18221],
				8216: [0, 0.69444, 0.12945, 0, 0.35555],
				8217: [0, 0.69444, 0.12945, 0, 0.35555],
				8220: [0, 0.69444, 0.16772, 0, 0.62055],
				8221: [0, 0.69444, 0.07939, 0, 0.62055],
			},
			"Main-Italic": {
				32: [0, 0, 0, 0, 0.25],
				33: [0, 0.69444, 0.12417, 0, 0.30667],
				34: [0, 0.69444, 0.06961, 0, 0.51444],
				35: [0.19444, 0.69444, 0.06616, 0, 0.81777],
				37: [0.05556, 0.75, 0.13639, 0, 0.81777],
				38: [0, 0.69444, 0.09694, 0, 0.76666],
				39: [0, 0.69444, 0.12417, 0, 0.30667],
				40: [0.25, 0.75, 0.16194, 0, 0.40889],
				41: [0.25, 0.75, 0.03694, 0, 0.40889],
				42: [0, 0.75, 0.14917, 0, 0.51111],
				43: [0.05667, 0.56167, 0.03694, 0, 0.76666],
				44: [0.19444, 0.10556, 0, 0, 0.30667],
				45: [0, 0.43056, 0.02826, 0, 0.35778],
				46: [0, 0.10556, 0, 0, 0.30667],
				47: [0.25, 0.75, 0.16194, 0, 0.51111],
				48: [0, 0.64444, 0.13556, 0, 0.51111],
				49: [0, 0.64444, 0.13556, 0, 0.51111],
				50: [0, 0.64444, 0.13556, 0, 0.51111],
				51: [0, 0.64444, 0.13556, 0, 0.51111],
				52: [0.19444, 0.64444, 0.13556, 0, 0.51111],
				53: [0, 0.64444, 0.13556, 0, 0.51111],
				54: [0, 0.64444, 0.13556, 0, 0.51111],
				55: [0.19444, 0.64444, 0.13556, 0, 0.51111],
				56: [0, 0.64444, 0.13556, 0, 0.51111],
				57: [0, 0.64444, 0.13556, 0, 0.51111],
				58: [0, 0.43056, 0.0582, 0, 0.30667],
				59: [0.19444, 0.43056, 0.0582, 0, 0.30667],
				61: [-0.13313, 0.36687, 0.06616, 0, 0.76666],
				63: [0, 0.69444, 0.1225, 0, 0.51111],
				64: [0, 0.69444, 0.09597, 0, 0.76666],
				65: [0, 0.68333, 0, 0, 0.74333],
				66: [0, 0.68333, 0.10257, 0, 0.70389],
				67: [0, 0.68333, 0.14528, 0, 0.71555],
				68: [0, 0.68333, 0.09403, 0, 0.755],
				69: [0, 0.68333, 0.12028, 0, 0.67833],
				70: [0, 0.68333, 0.13305, 0, 0.65277],
				71: [0, 0.68333, 0.08722, 0, 0.77361],
				72: [0, 0.68333, 0.16389, 0, 0.74333],
				73: [0, 0.68333, 0.15806, 0, 0.38555],
				74: [0, 0.68333, 0.14028, 0, 0.525],
				75: [0, 0.68333, 0.14528, 0, 0.76888],
				76: [0, 0.68333, 0, 0, 0.62722],
				77: [0, 0.68333, 0.16389, 0, 0.89666],
				78: [0, 0.68333, 0.16389, 0, 0.74333],
				79: [0, 0.68333, 0.09403, 0, 0.76666],
				80: [0, 0.68333, 0.10257, 0, 0.67833],
				81: [0.19444, 0.68333, 0.09403, 0, 0.76666],
				82: [0, 0.68333, 0.03868, 0, 0.72944],
				83: [0, 0.68333, 0.11972, 0, 0.56222],
				84: [0, 0.68333, 0.13305, 0, 0.71555],
				85: [0, 0.68333, 0.16389, 0, 0.74333],
				86: [0, 0.68333, 0.18361, 0, 0.74333],
				87: [0, 0.68333, 0.18361, 0, 0.99888],
				88: [0, 0.68333, 0.15806, 0, 0.74333],
				89: [0, 0.68333, 0.19383, 0, 0.74333],
				90: [0, 0.68333, 0.14528, 0, 0.61333],
				91: [0.25, 0.75, 0.1875, 0, 0.30667],
				93: [0.25, 0.75, 0.10528, 0, 0.30667],
				94: [0, 0.69444, 0.06646, 0, 0.51111],
				95: [0.31, 0.12056, 0.09208, 0, 0.51111],
				97: [0, 0.43056, 0.07671, 0, 0.51111],
				98: [0, 0.69444, 0.06312, 0, 0.46],
				99: [0, 0.43056, 0.05653, 0, 0.46],
				100: [0, 0.69444, 0.10333, 0, 0.51111],
				101: [0, 0.43056, 0.07514, 0, 0.46],
				102: [0.19444, 0.69444, 0.21194, 0, 0.30667],
				103: [0.19444, 0.43056, 0.08847, 0, 0.46],
				104: [0, 0.69444, 0.07671, 0, 0.51111],
				105: [0, 0.65536, 0.1019, 0, 0.30667],
				106: [0.19444, 0.65536, 0.14467, 0, 0.30667],
				107: [0, 0.69444, 0.10764, 0, 0.46],
				108: [0, 0.69444, 0.10333, 0, 0.25555],
				109: [0, 0.43056, 0.07671, 0, 0.81777],
				110: [0, 0.43056, 0.07671, 0, 0.56222],
				111: [0, 0.43056, 0.06312, 0, 0.51111],
				112: [0.19444, 0.43056, 0.06312, 0, 0.51111],
				113: [0.19444, 0.43056, 0.08847, 0, 0.46],
				114: [0, 0.43056, 0.10764, 0, 0.42166],
				115: [0, 0.43056, 0.08208, 0, 0.40889],
				116: [0, 0.61508, 0.09486, 0, 0.33222],
				117: [0, 0.43056, 0.07671, 0, 0.53666],
				118: [0, 0.43056, 0.10764, 0, 0.46],
				119: [0, 0.43056, 0.10764, 0, 0.66444],
				120: [0, 0.43056, 0.12042, 0, 0.46389],
				121: [0.19444, 0.43056, 0.08847, 0, 0.48555],
				122: [0, 0.43056, 0.12292, 0, 0.40889],
				126: [0.35, 0.31786, 0.11585, 0, 0.51111],
				160: [0, 0, 0, 0, 0.25],
				168: [0, 0.66786, 0.10474, 0, 0.51111],
				176: [0, 0.69444, 0, 0, 0.83129],
				184: [0.17014, 0, 0, 0, 0.46],
				198: [0, 0.68333, 0.12028, 0, 0.88277],
				216: [0.04861, 0.73194, 0.09403, 0, 0.76666],
				223: [0.19444, 0.69444, 0.10514, 0, 0.53666],
				230: [0, 0.43056, 0.07514, 0, 0.71555],
				248: [0.09722, 0.52778, 0.09194, 0, 0.51111],
				338: [0, 0.68333, 0.12028, 0, 0.98499],
				339: [0, 0.43056, 0.07514, 0, 0.71555],
				710: [0, 0.69444, 0.06646, 0, 0.51111],
				711: [0, 0.62847, 0.08295, 0, 0.51111],
				713: [0, 0.56167, 0.10333, 0, 0.51111],
				714: [0, 0.69444, 0.09694, 0, 0.51111],
				715: [0, 0.69444, 0, 0, 0.51111],
				728: [0, 0.69444, 0.10806, 0, 0.51111],
				729: [0, 0.66786, 0.11752, 0, 0.30667],
				730: [0, 0.69444, 0, 0, 0.83129],
				732: [0, 0.66786, 0.11585, 0, 0.51111],
				733: [0, 0.69444, 0.1225, 0, 0.51111],
				915: [0, 0.68333, 0.13305, 0, 0.62722],
				916: [0, 0.68333, 0, 0, 0.81777],
				920: [0, 0.68333, 0.09403, 0, 0.76666],
				923: [0, 0.68333, 0, 0, 0.69222],
				926: [0, 0.68333, 0.15294, 0, 0.66444],
				928: [0, 0.68333, 0.16389, 0, 0.74333],
				931: [0, 0.68333, 0.12028, 0, 0.71555],
				933: [0, 0.68333, 0.11111, 0, 0.76666],
				934: [0, 0.68333, 0.05986, 0, 0.71555],
				936: [0, 0.68333, 0.11111, 0, 0.76666],
				937: [0, 0.68333, 0.10257, 0, 0.71555],
				8211: [0, 0.43056, 0.09208, 0, 0.51111],
				8212: [0, 0.43056, 0.09208, 0, 1.02222],
				8216: [0, 0.69444, 0.12417, 0, 0.30667],
				8217: [0, 0.69444, 0.12417, 0, 0.30667],
				8220: [0, 0.69444, 0.1685, 0, 0.51444],
				8221: [0, 0.69444, 0.06961, 0, 0.51444],
				8463: [0, 0.68889, 0, 0, 0.54028],
			},
			"Main-Regular": {
				32: [0, 0, 0, 0, 0.25],
				33: [0, 0.69444, 0, 0, 0.27778],
				34: [0, 0.69444, 0, 0, 0.5],
				35: [0.19444, 0.69444, 0, 0, 0.83334],
				36: [0.05556, 0.75, 0, 0, 0.5],
				37: [0.05556, 0.75, 0, 0, 0.83334],
				38: [0, 0.69444, 0, 0, 0.77778],
				39: [0, 0.69444, 0, 0, 0.27778],
				40: [0.25, 0.75, 0, 0, 0.38889],
				41: [0.25, 0.75, 0, 0, 0.38889],
				42: [0, 0.75, 0, 0, 0.5],
				43: [0.08333, 0.58333, 0, 0, 0.77778],
				44: [0.19444, 0.10556, 0, 0, 0.27778],
				45: [0, 0.43056, 0, 0, 0.33333],
				46: [0, 0.10556, 0, 0, 0.27778],
				47: [0.25, 0.75, 0, 0, 0.5],
				48: [0, 0.64444, 0, 0, 0.5],
				49: [0, 0.64444, 0, 0, 0.5],
				50: [0, 0.64444, 0, 0, 0.5],
				51: [0, 0.64444, 0, 0, 0.5],
				52: [0, 0.64444, 0, 0, 0.5],
				53: [0, 0.64444, 0, 0, 0.5],
				54: [0, 0.64444, 0, 0, 0.5],
				55: [0, 0.64444, 0, 0, 0.5],
				56: [0, 0.64444, 0, 0, 0.5],
				57: [0, 0.64444, 0, 0, 0.5],
				58: [0, 0.43056, 0, 0, 0.27778],
				59: [0.19444, 0.43056, 0, 0, 0.27778],
				60: [0.0391, 0.5391, 0, 0, 0.77778],
				61: [-0.13313, 0.36687, 0, 0, 0.77778],
				62: [0.0391, 0.5391, 0, 0, 0.77778],
				63: [0, 0.69444, 0, 0, 0.47222],
				64: [0, 0.69444, 0, 0, 0.77778],
				65: [0, 0.68333, 0, 0, 0.75],
				66: [0, 0.68333, 0, 0, 0.70834],
				67: [0, 0.68333, 0, 0, 0.72222],
				68: [0, 0.68333, 0, 0, 0.76389],
				69: [0, 0.68333, 0, 0, 0.68056],
				70: [0, 0.68333, 0, 0, 0.65278],
				71: [0, 0.68333, 0, 0, 0.78472],
				72: [0, 0.68333, 0, 0, 0.75],
				73: [0, 0.68333, 0, 0, 0.36111],
				74: [0, 0.68333, 0, 0, 0.51389],
				75: [0, 0.68333, 0, 0, 0.77778],
				76: [0, 0.68333, 0, 0, 0.625],
				77: [0, 0.68333, 0, 0, 0.91667],
				78: [0, 0.68333, 0, 0, 0.75],
				79: [0, 0.68333, 0, 0, 0.77778],
				80: [0, 0.68333, 0, 0, 0.68056],
				81: [0.19444, 0.68333, 0, 0, 0.77778],
				82: [0, 0.68333, 0, 0, 0.73611],
				83: [0, 0.68333, 0, 0, 0.55556],
				84: [0, 0.68333, 0, 0, 0.72222],
				85: [0, 0.68333, 0, 0, 0.75],
				86: [0, 0.68333, 0.01389, 0, 0.75],
				87: [0, 0.68333, 0.01389, 0, 1.02778],
				88: [0, 0.68333, 0, 0, 0.75],
				89: [0, 0.68333, 0.025, 0, 0.75],
				90: [0, 0.68333, 0, 0, 0.61111],
				91: [0.25, 0.75, 0, 0, 0.27778],
				92: [0.25, 0.75, 0, 0, 0.5],
				93: [0.25, 0.75, 0, 0, 0.27778],
				94: [0, 0.69444, 0, 0, 0.5],
				95: [0.31, 0.12056, 0.02778, 0, 0.5],
				97: [0, 0.43056, 0, 0, 0.5],
				98: [0, 0.69444, 0, 0, 0.55556],
				99: [0, 0.43056, 0, 0, 0.44445],
				100: [0, 0.69444, 0, 0, 0.55556],
				101: [0, 0.43056, 0, 0, 0.44445],
				102: [0, 0.69444, 0.07778, 0, 0.30556],
				103: [0.19444, 0.43056, 0.01389, 0, 0.5],
				104: [0, 0.69444, 0, 0, 0.55556],
				105: [0, 0.66786, 0, 0, 0.27778],
				106: [0.19444, 0.66786, 0, 0, 0.30556],
				107: [0, 0.69444, 0, 0, 0.52778],
				108: [0, 0.69444, 0, 0, 0.27778],
				109: [0, 0.43056, 0, 0, 0.83334],
				110: [0, 0.43056, 0, 0, 0.55556],
				111: [0, 0.43056, 0, 0, 0.5],
				112: [0.19444, 0.43056, 0, 0, 0.55556],
				113: [0.19444, 0.43056, 0, 0, 0.52778],
				114: [0, 0.43056, 0, 0, 0.39167],
				115: [0, 0.43056, 0, 0, 0.39445],
				116: [0, 0.61508, 0, 0, 0.38889],
				117: [0, 0.43056, 0, 0, 0.55556],
				118: [0, 0.43056, 0.01389, 0, 0.52778],
				119: [0, 0.43056, 0.01389, 0, 0.72222],
				120: [0, 0.43056, 0, 0, 0.52778],
				121: [0.19444, 0.43056, 0.01389, 0, 0.52778],
				122: [0, 0.43056, 0, 0, 0.44445],
				123: [0.25, 0.75, 0, 0, 0.5],
				124: [0.25, 0.75, 0, 0, 0.27778],
				125: [0.25, 0.75, 0, 0, 0.5],
				126: [0.35, 0.31786, 0, 0, 0.5],
				160: [0, 0, 0, 0, 0.25],
				163: [0, 0.69444, 0, 0, 0.76909],
				167: [0.19444, 0.69444, 0, 0, 0.44445],
				168: [0, 0.66786, 0, 0, 0.5],
				172: [0, 0.43056, 0, 0, 0.66667],
				176: [0, 0.69444, 0, 0, 0.75],
				177: [0.08333, 0.58333, 0, 0, 0.77778],
				182: [0.19444, 0.69444, 0, 0, 0.61111],
				184: [0.17014, 0, 0, 0, 0.44445],
				198: [0, 0.68333, 0, 0, 0.90278],
				215: [0.08333, 0.58333, 0, 0, 0.77778],
				216: [0.04861, 0.73194, 0, 0, 0.77778],
				223: [0, 0.69444, 0, 0, 0.5],
				230: [0, 0.43056, 0, 0, 0.72222],
				247: [0.08333, 0.58333, 0, 0, 0.77778],
				248: [0.09722, 0.52778, 0, 0, 0.5],
				305: [0, 0.43056, 0, 0, 0.27778],
				338: [0, 0.68333, 0, 0, 1.01389],
				339: [0, 0.43056, 0, 0, 0.77778],
				567: [0.19444, 0.43056, 0, 0, 0.30556],
				710: [0, 0.69444, 0, 0, 0.5],
				711: [0, 0.62847, 0, 0, 0.5],
				713: [0, 0.56778, 0, 0, 0.5],
				714: [0, 0.69444, 0, 0, 0.5],
				715: [0, 0.69444, 0, 0, 0.5],
				728: [0, 0.69444, 0, 0, 0.5],
				729: [0, 0.66786, 0, 0, 0.27778],
				730: [0, 0.69444, 0, 0, 0.75],
				732: [0, 0.66786, 0, 0, 0.5],
				733: [0, 0.69444, 0, 0, 0.5],
				915: [0, 0.68333, 0, 0, 0.625],
				916: [0, 0.68333, 0, 0, 0.83334],
				920: [0, 0.68333, 0, 0, 0.77778],
				923: [0, 0.68333, 0, 0, 0.69445],
				926: [0, 0.68333, 0, 0, 0.66667],
				928: [0, 0.68333, 0, 0, 0.75],
				931: [0, 0.68333, 0, 0, 0.72222],
				933: [0, 0.68333, 0, 0, 0.77778],
				934: [0, 0.68333, 0, 0, 0.72222],
				936: [0, 0.68333, 0, 0, 0.77778],
				937: [0, 0.68333, 0, 0, 0.72222],
				8211: [0, 0.43056, 0.02778, 0, 0.5],
				8212: [0, 0.43056, 0.02778, 0, 1],
				8216: [0, 0.69444, 0, 0, 0.27778],
				8217: [0, 0.69444, 0, 0, 0.27778],
				8220: [0, 0.69444, 0, 0, 0.5],
				8221: [0, 0.69444, 0, 0, 0.5],
				8224: [0.19444, 0.69444, 0, 0, 0.44445],
				8225: [0.19444, 0.69444, 0, 0, 0.44445],
				8230: [0, 0.123, 0, 0, 1.172],
				8242: [0, 0.55556, 0, 0, 0.275],
				8407: [0, 0.71444, 0.15382, 0, 0.5],
				8463: [0, 0.68889, 0, 0, 0.54028],
				8465: [0, 0.69444, 0, 0, 0.72222],
				8467: [0, 0.69444, 0, 0.11111, 0.41667],
				8472: [0.19444, 0.43056, 0, 0.11111, 0.63646],
				8476: [0, 0.69444, 0, 0, 0.72222],
				8501: [0, 0.69444, 0, 0, 0.61111],
				8592: [-0.13313, 0.36687, 0, 0, 1],
				8593: [0.19444, 0.69444, 0, 0, 0.5],
				8594: [-0.13313, 0.36687, 0, 0, 1],
				8595: [0.19444, 0.69444, 0, 0, 0.5],
				8596: [-0.13313, 0.36687, 0, 0, 1],
				8597: [0.25, 0.75, 0, 0, 0.5],
				8598: [0.19444, 0.69444, 0, 0, 1],
				8599: [0.19444, 0.69444, 0, 0, 1],
				8600: [0.19444, 0.69444, 0, 0, 1],
				8601: [0.19444, 0.69444, 0, 0, 1],
				8614: [0.011, 0.511, 0, 0, 1],
				8617: [0.011, 0.511, 0, 0, 1.126],
				8618: [0.011, 0.511, 0, 0, 1.126],
				8636: [-0.13313, 0.36687, 0, 0, 1],
				8637: [-0.13313, 0.36687, 0, 0, 1],
				8640: [-0.13313, 0.36687, 0, 0, 1],
				8641: [-0.13313, 0.36687, 0, 0, 1],
				8652: [0.011, 0.671, 0, 0, 1],
				8656: [-0.13313, 0.36687, 0, 0, 1],
				8657: [0.19444, 0.69444, 0, 0, 0.61111],
				8658: [-0.13313, 0.36687, 0, 0, 1],
				8659: [0.19444, 0.69444, 0, 0, 0.61111],
				8660: [-0.13313, 0.36687, 0, 0, 1],
				8661: [0.25, 0.75, 0, 0, 0.61111],
				8704: [0, 0.69444, 0, 0, 0.55556],
				8706: [0, 0.69444, 0.05556, 0.08334, 0.5309],
				8707: [0, 0.69444, 0, 0, 0.55556],
				8709: [0.05556, 0.75, 0, 0, 0.5],
				8711: [0, 0.68333, 0, 0, 0.83334],
				8712: [0.0391, 0.5391, 0, 0, 0.66667],
				8715: [0.0391, 0.5391, 0, 0, 0.66667],
				8722: [0.08333, 0.58333, 0, 0, 0.77778],
				8723: [0.08333, 0.58333, 0, 0, 0.77778],
				8725: [0.25, 0.75, 0, 0, 0.5],
				8726: [0.25, 0.75, 0, 0, 0.5],
				8727: [-0.03472, 0.46528, 0, 0, 0.5],
				8728: [-0.05555, 0.44445, 0, 0, 0.5],
				8729: [-0.05555, 0.44445, 0, 0, 0.5],
				8730: [0.2, 0.8, 0, 0, 0.83334],
				8733: [0, 0.43056, 0, 0, 0.77778],
				8734: [0, 0.43056, 0, 0, 1],
				8736: [0, 0.69224, 0, 0, 0.72222],
				8739: [0.25, 0.75, 0, 0, 0.27778],
				8741: [0.25, 0.75, 0, 0, 0.5],
				8743: [0, 0.55556, 0, 0, 0.66667],
				8744: [0, 0.55556, 0, 0, 0.66667],
				8745: [0, 0.55556, 0, 0, 0.66667],
				8746: [0, 0.55556, 0, 0, 0.66667],
				8747: [0.19444, 0.69444, 0.11111, 0, 0.41667],
				8764: [-0.13313, 0.36687, 0, 0, 0.77778],
				8768: [0.19444, 0.69444, 0, 0, 0.27778],
				8771: [-0.03625, 0.46375, 0, 0, 0.77778],
				8773: [-0.022, 0.589, 0, 0, 0.778],
				8776: [-0.01688, 0.48312, 0, 0, 0.77778],
				8781: [-0.03625, 0.46375, 0, 0, 0.77778],
				8784: [-0.133, 0.673, 0, 0, 0.778],
				8801: [-0.03625, 0.46375, 0, 0, 0.77778],
				8804: [0.13597, 0.63597, 0, 0, 0.77778],
				8805: [0.13597, 0.63597, 0, 0, 0.77778],
				8810: [0.0391, 0.5391, 0, 0, 1],
				8811: [0.0391, 0.5391, 0, 0, 1],
				8826: [0.0391, 0.5391, 0, 0, 0.77778],
				8827: [0.0391, 0.5391, 0, 0, 0.77778],
				8834: [0.0391, 0.5391, 0, 0, 0.77778],
				8835: [0.0391, 0.5391, 0, 0, 0.77778],
				8838: [0.13597, 0.63597, 0, 0, 0.77778],
				8839: [0.13597, 0.63597, 0, 0, 0.77778],
				8846: [0, 0.55556, 0, 0, 0.66667],
				8849: [0.13597, 0.63597, 0, 0, 0.77778],
				8850: [0.13597, 0.63597, 0, 0, 0.77778],
				8851: [0, 0.55556, 0, 0, 0.66667],
				8852: [0, 0.55556, 0, 0, 0.66667],
				8853: [0.08333, 0.58333, 0, 0, 0.77778],
				8854: [0.08333, 0.58333, 0, 0, 0.77778],
				8855: [0.08333, 0.58333, 0, 0, 0.77778],
				8856: [0.08333, 0.58333, 0, 0, 0.77778],
				8857: [0.08333, 0.58333, 0, 0, 0.77778],
				8866: [0, 0.69444, 0, 0, 0.61111],
				8867: [0, 0.69444, 0, 0, 0.61111],
				8868: [0, 0.69444, 0, 0, 0.77778],
				8869: [0, 0.69444, 0, 0, 0.77778],
				8872: [0.249, 0.75, 0, 0, 0.867],
				8900: [-0.05555, 0.44445, 0, 0, 0.5],
				8901: [-0.05555, 0.44445, 0, 0, 0.27778],
				8902: [-0.03472, 0.46528, 0, 0, 0.5],
				8904: [0.005, 0.505, 0, 0, 0.9],
				8942: [0.03, 0.903, 0, 0, 0.278],
				8943: [-0.19, 0.313, 0, 0, 1.172],
				8945: [-0.1, 0.823, 0, 0, 1.282],
				8968: [0.25, 0.75, 0, 0, 0.44445],
				8969: [0.25, 0.75, 0, 0, 0.44445],
				8970: [0.25, 0.75, 0, 0, 0.44445],
				8971: [0.25, 0.75, 0, 0, 0.44445],
				8994: [-0.14236, 0.35764, 0, 0, 1],
				8995: [-0.14236, 0.35764, 0, 0, 1],
				9136: [0.244, 0.744, 0, 0, 0.412],
				9137: [0.244, 0.745, 0, 0, 0.412],
				9651: [0.19444, 0.69444, 0, 0, 0.88889],
				9657: [-0.03472, 0.46528, 0, 0, 0.5],
				9661: [0.19444, 0.69444, 0, 0, 0.88889],
				9667: [-0.03472, 0.46528, 0, 0, 0.5],
				9711: [0.19444, 0.69444, 0, 0, 1],
				9824: [0.12963, 0.69444, 0, 0, 0.77778],
				9825: [0.12963, 0.69444, 0, 0, 0.77778],
				9826: [0.12963, 0.69444, 0, 0, 0.77778],
				9827: [0.12963, 0.69444, 0, 0, 0.77778],
				9837: [0, 0.75, 0, 0, 0.38889],
				9838: [0.19444, 0.69444, 0, 0, 0.38889],
				9839: [0.19444, 0.69444, 0, 0, 0.38889],
				10216: [0.25, 0.75, 0, 0, 0.38889],
				10217: [0.25, 0.75, 0, 0, 0.38889],
				10222: [0.244, 0.744, 0, 0, 0.412],
				10223: [0.244, 0.745, 0, 0, 0.412],
				10229: [0.011, 0.511, 0, 0, 1.609],
				10230: [0.011, 0.511, 0, 0, 1.638],
				10231: [0.011, 0.511, 0, 0, 1.859],
				10232: [0.024, 0.525, 0, 0, 1.609],
				10233: [0.024, 0.525, 0, 0, 1.638],
				10234: [0.024, 0.525, 0, 0, 1.858],
				10236: [0.011, 0.511, 0, 0, 1.638],
				10815: [0, 0.68333, 0, 0, 0.75],
				10927: [0.13597, 0.63597, 0, 0, 0.77778],
				10928: [0.13597, 0.63597, 0, 0, 0.77778],
				57376: [0.19444, 0.69444, 0, 0, 0],
			},
			"Math-BoldItalic": {
				32: [0, 0, 0, 0, 0.25],
				48: [0, 0.44444, 0, 0, 0.575],
				49: [0, 0.44444, 0, 0, 0.575],
				50: [0, 0.44444, 0, 0, 0.575],
				51: [0.19444, 0.44444, 0, 0, 0.575],
				52: [0.19444, 0.44444, 0, 0, 0.575],
				53: [0.19444, 0.44444, 0, 0, 0.575],
				54: [0, 0.64444, 0, 0, 0.575],
				55: [0.19444, 0.44444, 0, 0, 0.575],
				56: [0, 0.64444, 0, 0, 0.575],
				57: [0.19444, 0.44444, 0, 0, 0.575],
				65: [0, 0.68611, 0, 0, 0.86944],
				66: [0, 0.68611, 0.04835, 0, 0.8664],
				67: [0, 0.68611, 0.06979, 0, 0.81694],
				68: [0, 0.68611, 0.03194, 0, 0.93812],
				69: [0, 0.68611, 0.05451, 0, 0.81007],
				70: [0, 0.68611, 0.15972, 0, 0.68889],
				71: [0, 0.68611, 0, 0, 0.88673],
				72: [0, 0.68611, 0.08229, 0, 0.98229],
				73: [0, 0.68611, 0.07778, 0, 0.51111],
				74: [0, 0.68611, 0.10069, 0, 0.63125],
				75: [0, 0.68611, 0.06979, 0, 0.97118],
				76: [0, 0.68611, 0, 0, 0.75555],
				77: [0, 0.68611, 0.11424, 0, 1.14201],
				78: [0, 0.68611, 0.11424, 0, 0.95034],
				79: [0, 0.68611, 0.03194, 0, 0.83666],
				80: [0, 0.68611, 0.15972, 0, 0.72309],
				81: [0.19444, 0.68611, 0, 0, 0.86861],
				82: [0, 0.68611, 0.00421, 0, 0.87235],
				83: [0, 0.68611, 0.05382, 0, 0.69271],
				84: [0, 0.68611, 0.15972, 0, 0.63663],
				85: [0, 0.68611, 0.11424, 0, 0.80027],
				86: [0, 0.68611, 0.25555, 0, 0.67778],
				87: [0, 0.68611, 0.15972, 0, 1.09305],
				88: [0, 0.68611, 0.07778, 0, 0.94722],
				89: [0, 0.68611, 0.25555, 0, 0.67458],
				90: [0, 0.68611, 0.06979, 0, 0.77257],
				97: [0, 0.44444, 0, 0, 0.63287],
				98: [0, 0.69444, 0, 0, 0.52083],
				99: [0, 0.44444, 0, 0, 0.51342],
				100: [0, 0.69444, 0, 0, 0.60972],
				101: [0, 0.44444, 0, 0, 0.55361],
				102: [0.19444, 0.69444, 0.11042, 0, 0.56806],
				103: [0.19444, 0.44444, 0.03704, 0, 0.5449],
				104: [0, 0.69444, 0, 0, 0.66759],
				105: [0, 0.69326, 0, 0, 0.4048],
				106: [0.19444, 0.69326, 0.0622, 0, 0.47083],
				107: [0, 0.69444, 0.01852, 0, 0.6037],
				108: [0, 0.69444, 0.0088, 0, 0.34815],
				109: [0, 0.44444, 0, 0, 1.0324],
				110: [0, 0.44444, 0, 0, 0.71296],
				111: [0, 0.44444, 0, 0, 0.58472],
				112: [0.19444, 0.44444, 0, 0, 0.60092],
				113: [0.19444, 0.44444, 0.03704, 0, 0.54213],
				114: [0, 0.44444, 0.03194, 0, 0.5287],
				115: [0, 0.44444, 0, 0, 0.53125],
				116: [0, 0.63492, 0, 0, 0.41528],
				117: [0, 0.44444, 0, 0, 0.68102],
				118: [0, 0.44444, 0.03704, 0, 0.56666],
				119: [0, 0.44444, 0.02778, 0, 0.83148],
				120: [0, 0.44444, 0, 0, 0.65903],
				121: [0.19444, 0.44444, 0.03704, 0, 0.59028],
				122: [0, 0.44444, 0.04213, 0, 0.55509],
				160: [0, 0, 0, 0, 0.25],
				915: [0, 0.68611, 0.15972, 0, 0.65694],
				916: [0, 0.68611, 0, 0, 0.95833],
				920: [0, 0.68611, 0.03194, 0, 0.86722],
				923: [0, 0.68611, 0, 0, 0.80555],
				926: [0, 0.68611, 0.07458, 0, 0.84125],
				928: [0, 0.68611, 0.08229, 0, 0.98229],
				931: [0, 0.68611, 0.05451, 0, 0.88507],
				933: [0, 0.68611, 0.15972, 0, 0.67083],
				934: [0, 0.68611, 0, 0, 0.76666],
				936: [0, 0.68611, 0.11653, 0, 0.71402],
				937: [0, 0.68611, 0.04835, 0, 0.8789],
				945: [0, 0.44444, 0, 0, 0.76064],
				946: [0.19444, 0.69444, 0.03403, 0, 0.65972],
				947: [0.19444, 0.44444, 0.06389, 0, 0.59003],
				948: [0, 0.69444, 0.03819, 0, 0.52222],
				949: [0, 0.44444, 0, 0, 0.52882],
				950: [0.19444, 0.69444, 0.06215, 0, 0.50833],
				951: [0.19444, 0.44444, 0.03704, 0, 0.6],
				952: [0, 0.69444, 0.03194, 0, 0.5618],
				953: [0, 0.44444, 0, 0, 0.41204],
				954: [0, 0.44444, 0, 0, 0.66759],
				955: [0, 0.69444, 0, 0, 0.67083],
				956: [0.19444, 0.44444, 0, 0, 0.70787],
				957: [0, 0.44444, 0.06898, 0, 0.57685],
				958: [0.19444, 0.69444, 0.03021, 0, 0.50833],
				959: [0, 0.44444, 0, 0, 0.58472],
				960: [0, 0.44444, 0.03704, 0, 0.68241],
				961: [0.19444, 0.44444, 0, 0, 0.6118],
				962: [0.09722, 0.44444, 0.07917, 0, 0.42361],
				963: [0, 0.44444, 0.03704, 0, 0.68588],
				964: [0, 0.44444, 0.13472, 0, 0.52083],
				965: [0, 0.44444, 0.03704, 0, 0.63055],
				966: [0.19444, 0.44444, 0, 0, 0.74722],
				967: [0.19444, 0.44444, 0, 0, 0.71805],
				968: [0.19444, 0.69444, 0.03704, 0, 0.75833],
				969: [0, 0.44444, 0.03704, 0, 0.71782],
				977: [0, 0.69444, 0, 0, 0.69155],
				981: [0.19444, 0.69444, 0, 0, 0.7125],
				982: [0, 0.44444, 0.03194, 0, 0.975],
				1009: [0.19444, 0.44444, 0, 0, 0.6118],
				1013: [0, 0.44444, 0, 0, 0.48333],
				57649: [0, 0.44444, 0, 0, 0.39352],
				57911: [0.19444, 0.44444, 0, 0, 0.43889],
			},
			"Math-Italic": {
				32: [0, 0, 0, 0, 0.25],
				48: [0, 0.43056, 0, 0, 0.5],
				49: [0, 0.43056, 0, 0, 0.5],
				50: [0, 0.43056, 0, 0, 0.5],
				51: [0.19444, 0.43056, 0, 0, 0.5],
				52: [0.19444, 0.43056, 0, 0, 0.5],
				53: [0.19444, 0.43056, 0, 0, 0.5],
				54: [0, 0.64444, 0, 0, 0.5],
				55: [0.19444, 0.43056, 0, 0, 0.5],
				56: [0, 0.64444, 0, 0, 0.5],
				57: [0.19444, 0.43056, 0, 0, 0.5],
				65: [0, 0.68333, 0, 0.13889, 0.75],
				66: [0, 0.68333, 0.05017, 0.08334, 0.75851],
				67: [0, 0.68333, 0.07153, 0.08334, 0.71472],
				68: [0, 0.68333, 0.02778, 0.05556, 0.82792],
				69: [0, 0.68333, 0.05764, 0.08334, 0.7382],
				70: [0, 0.68333, 0.13889, 0.08334, 0.64306],
				71: [0, 0.68333, 0, 0.08334, 0.78625],
				72: [0, 0.68333, 0.08125, 0.05556, 0.83125],
				73: [0, 0.68333, 0.07847, 0.11111, 0.43958],
				74: [0, 0.68333, 0.09618, 0.16667, 0.55451],
				75: [0, 0.68333, 0.07153, 0.05556, 0.84931],
				76: [0, 0.68333, 0, 0.02778, 0.68056],
				77: [0, 0.68333, 0.10903, 0.08334, 0.97014],
				78: [0, 0.68333, 0.10903, 0.08334, 0.80347],
				79: [0, 0.68333, 0.02778, 0.08334, 0.76278],
				80: [0, 0.68333, 0.13889, 0.08334, 0.64201],
				81: [0.19444, 0.68333, 0, 0.08334, 0.79056],
				82: [0, 0.68333, 0.00773, 0.08334, 0.75929],
				83: [0, 0.68333, 0.05764, 0.08334, 0.6132],
				84: [0, 0.68333, 0.13889, 0.08334, 0.58438],
				85: [0, 0.68333, 0.10903, 0.02778, 0.68278],
				86: [0, 0.68333, 0.22222, 0, 0.58333],
				87: [0, 0.68333, 0.13889, 0, 0.94445],
				88: [0, 0.68333, 0.07847, 0.08334, 0.82847],
				89: [0, 0.68333, 0.22222, 0, 0.58056],
				90: [0, 0.68333, 0.07153, 0.08334, 0.68264],
				97: [0, 0.43056, 0, 0, 0.52859],
				98: [0, 0.69444, 0, 0, 0.42917],
				99: [0, 0.43056, 0, 0.05556, 0.43276],
				100: [0, 0.69444, 0, 0.16667, 0.52049],
				101: [0, 0.43056, 0, 0.05556, 0.46563],
				102: [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
				103: [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
				104: [0, 0.69444, 0, 0, 0.57616],
				105: [0, 0.65952, 0, 0, 0.34451],
				106: [0.19444, 0.65952, 0.05724, 0, 0.41181],
				107: [0, 0.69444, 0.03148, 0, 0.5206],
				108: [0, 0.69444, 0.01968, 0.08334, 0.29838],
				109: [0, 0.43056, 0, 0, 0.87801],
				110: [0, 0.43056, 0, 0, 0.60023],
				111: [0, 0.43056, 0, 0.05556, 0.48472],
				112: [0.19444, 0.43056, 0, 0.08334, 0.50313],
				113: [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
				114: [0, 0.43056, 0.02778, 0.05556, 0.45116],
				115: [0, 0.43056, 0, 0.05556, 0.46875],
				116: [0, 0.61508, 0, 0.08334, 0.36111],
				117: [0, 0.43056, 0, 0.02778, 0.57246],
				118: [0, 0.43056, 0.03588, 0.02778, 0.48472],
				119: [0, 0.43056, 0.02691, 0.08334, 0.71592],
				120: [0, 0.43056, 0, 0.02778, 0.57153],
				121: [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
				122: [0, 0.43056, 0.04398, 0.05556, 0.46505],
				160: [0, 0, 0, 0, 0.25],
				915: [0, 0.68333, 0.13889, 0.08334, 0.61528],
				916: [0, 0.68333, 0, 0.16667, 0.83334],
				920: [0, 0.68333, 0.02778, 0.08334, 0.76278],
				923: [0, 0.68333, 0, 0.16667, 0.69445],
				926: [0, 0.68333, 0.07569, 0.08334, 0.74236],
				928: [0, 0.68333, 0.08125, 0.05556, 0.83125],
				931: [0, 0.68333, 0.05764, 0.08334, 0.77986],
				933: [0, 0.68333, 0.13889, 0.05556, 0.58333],
				934: [0, 0.68333, 0, 0.08334, 0.66667],
				936: [0, 0.68333, 0.11, 0.05556, 0.61222],
				937: [0, 0.68333, 0.05017, 0.08334, 0.7724],
				945: [0, 0.43056, 0.0037, 0.02778, 0.6397],
				946: [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
				947: [0.19444, 0.43056, 0.05556, 0, 0.51773],
				948: [0, 0.69444, 0.03785, 0.05556, 0.44444],
				949: [0, 0.43056, 0, 0.08334, 0.46632],
				950: [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
				951: [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
				952: [0, 0.69444, 0.02778, 0.08334, 0.46944],
				953: [0, 0.43056, 0, 0.05556, 0.35394],
				954: [0, 0.43056, 0, 0, 0.57616],
				955: [0, 0.69444, 0, 0, 0.58334],
				956: [0.19444, 0.43056, 0, 0.02778, 0.60255],
				957: [0, 0.43056, 0.06366, 0.02778, 0.49398],
				958: [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
				959: [0, 0.43056, 0, 0.05556, 0.48472],
				960: [0, 0.43056, 0.03588, 0, 0.57003],
				961: [0.19444, 0.43056, 0, 0.08334, 0.51702],
				962: [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
				963: [0, 0.43056, 0.03588, 0, 0.57141],
				964: [0, 0.43056, 0.1132, 0.02778, 0.43715],
				965: [0, 0.43056, 0.03588, 0.02778, 0.54028],
				966: [0.19444, 0.43056, 0, 0.08334, 0.65417],
				967: [0.19444, 0.43056, 0, 0.05556, 0.62569],
				968: [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
				969: [0, 0.43056, 0.03588, 0, 0.62245],
				977: [0, 0.69444, 0, 0.08334, 0.59144],
				981: [0.19444, 0.69444, 0, 0.08334, 0.59583],
				982: [0, 0.43056, 0.02778, 0, 0.82813],
				1009: [0.19444, 0.43056, 0, 0.08334, 0.51702],
				1013: [0, 0.43056, 0, 0.05556, 0.4059],
				57649: [0, 0.43056, 0, 0.02778, 0.32246],
				57911: [0.19444, 0.43056, 0, 0.08334, 0.38403],
			},
			"SansSerif-Bold": {
				32: [0, 0, 0, 0, 0.25],
				33: [0, 0.69444, 0, 0, 0.36667],
				34: [0, 0.69444, 0, 0, 0.55834],
				35: [0.19444, 0.69444, 0, 0, 0.91667],
				36: [0.05556, 0.75, 0, 0, 0.55],
				37: [0.05556, 0.75, 0, 0, 1.02912],
				38: [0, 0.69444, 0, 0, 0.83056],
				39: [0, 0.69444, 0, 0, 0.30556],
				40: [0.25, 0.75, 0, 0, 0.42778],
				41: [0.25, 0.75, 0, 0, 0.42778],
				42: [0, 0.75, 0, 0, 0.55],
				43: [0.11667, 0.61667, 0, 0, 0.85556],
				44: [0.10556, 0.13056, 0, 0, 0.30556],
				45: [0, 0.45833, 0, 0, 0.36667],
				46: [0, 0.13056, 0, 0, 0.30556],
				47: [0.25, 0.75, 0, 0, 0.55],
				48: [0, 0.69444, 0, 0, 0.55],
				49: [0, 0.69444, 0, 0, 0.55],
				50: [0, 0.69444, 0, 0, 0.55],
				51: [0, 0.69444, 0, 0, 0.55],
				52: [0, 0.69444, 0, 0, 0.55],
				53: [0, 0.69444, 0, 0, 0.55],
				54: [0, 0.69444, 0, 0, 0.55],
				55: [0, 0.69444, 0, 0, 0.55],
				56: [0, 0.69444, 0, 0, 0.55],
				57: [0, 0.69444, 0, 0, 0.55],
				58: [0, 0.45833, 0, 0, 0.30556],
				59: [0.10556, 0.45833, 0, 0, 0.30556],
				61: [-0.09375, 0.40625, 0, 0, 0.85556],
				63: [0, 0.69444, 0, 0, 0.51945],
				64: [0, 0.69444, 0, 0, 0.73334],
				65: [0, 0.69444, 0, 0, 0.73334],
				66: [0, 0.69444, 0, 0, 0.73334],
				67: [0, 0.69444, 0, 0, 0.70278],
				68: [0, 0.69444, 0, 0, 0.79445],
				69: [0, 0.69444, 0, 0, 0.64167],
				70: [0, 0.69444, 0, 0, 0.61111],
				71: [0, 0.69444, 0, 0, 0.73334],
				72: [0, 0.69444, 0, 0, 0.79445],
				73: [0, 0.69444, 0, 0, 0.33056],
				74: [0, 0.69444, 0, 0, 0.51945],
				75: [0, 0.69444, 0, 0, 0.76389],
				76: [0, 0.69444, 0, 0, 0.58056],
				77: [0, 0.69444, 0, 0, 0.97778],
				78: [0, 0.69444, 0, 0, 0.79445],
				79: [0, 0.69444, 0, 0, 0.79445],
				80: [0, 0.69444, 0, 0, 0.70278],
				81: [0.10556, 0.69444, 0, 0, 0.79445],
				82: [0, 0.69444, 0, 0, 0.70278],
				83: [0, 0.69444, 0, 0, 0.61111],
				84: [0, 0.69444, 0, 0, 0.73334],
				85: [0, 0.69444, 0, 0, 0.76389],
				86: [0, 0.69444, 0.01528, 0, 0.73334],
				87: [0, 0.69444, 0.01528, 0, 1.03889],
				88: [0, 0.69444, 0, 0, 0.73334],
				89: [0, 0.69444, 0.0275, 0, 0.73334],
				90: [0, 0.69444, 0, 0, 0.67223],
				91: [0.25, 0.75, 0, 0, 0.34306],
				93: [0.25, 0.75, 0, 0, 0.34306],
				94: [0, 0.69444, 0, 0, 0.55],
				95: [0.35, 0.10833, 0.03056, 0, 0.55],
				97: [0, 0.45833, 0, 0, 0.525],
				98: [0, 0.69444, 0, 0, 0.56111],
				99: [0, 0.45833, 0, 0, 0.48889],
				100: [0, 0.69444, 0, 0, 0.56111],
				101: [0, 0.45833, 0, 0, 0.51111],
				102: [0, 0.69444, 0.07639, 0, 0.33611],
				103: [0.19444, 0.45833, 0.01528, 0, 0.55],
				104: [0, 0.69444, 0, 0, 0.56111],
				105: [0, 0.69444, 0, 0, 0.25556],
				106: [0.19444, 0.69444, 0, 0, 0.28611],
				107: [0, 0.69444, 0, 0, 0.53056],
				108: [0, 0.69444, 0, 0, 0.25556],
				109: [0, 0.45833, 0, 0, 0.86667],
				110: [0, 0.45833, 0, 0, 0.56111],
				111: [0, 0.45833, 0, 0, 0.55],
				112: [0.19444, 0.45833, 0, 0, 0.56111],
				113: [0.19444, 0.45833, 0, 0, 0.56111],
				114: [0, 0.45833, 0.01528, 0, 0.37222],
				115: [0, 0.45833, 0, 0, 0.42167],
				116: [0, 0.58929, 0, 0, 0.40417],
				117: [0, 0.45833, 0, 0, 0.56111],
				118: [0, 0.45833, 0.01528, 0, 0.5],
				119: [0, 0.45833, 0.01528, 0, 0.74445],
				120: [0, 0.45833, 0, 0, 0.5],
				121: [0.19444, 0.45833, 0.01528, 0, 0.5],
				122: [0, 0.45833, 0, 0, 0.47639],
				126: [0.35, 0.34444, 0, 0, 0.55],
				160: [0, 0, 0, 0, 0.25],
				168: [0, 0.69444, 0, 0, 0.55],
				176: [0, 0.69444, 0, 0, 0.73334],
				180: [0, 0.69444, 0, 0, 0.55],
				184: [0.17014, 0, 0, 0, 0.48889],
				305: [0, 0.45833, 0, 0, 0.25556],
				567: [0.19444, 0.45833, 0, 0, 0.28611],
				710: [0, 0.69444, 0, 0, 0.55],
				711: [0, 0.63542, 0, 0, 0.55],
				713: [0, 0.63778, 0, 0, 0.55],
				728: [0, 0.69444, 0, 0, 0.55],
				729: [0, 0.69444, 0, 0, 0.30556],
				730: [0, 0.69444, 0, 0, 0.73334],
				732: [0, 0.69444, 0, 0, 0.55],
				733: [0, 0.69444, 0, 0, 0.55],
				915: [0, 0.69444, 0, 0, 0.58056],
				916: [0, 0.69444, 0, 0, 0.91667],
				920: [0, 0.69444, 0, 0, 0.85556],
				923: [0, 0.69444, 0, 0, 0.67223],
				926: [0, 0.69444, 0, 0, 0.73334],
				928: [0, 0.69444, 0, 0, 0.79445],
				931: [0, 0.69444, 0, 0, 0.79445],
				933: [0, 0.69444, 0, 0, 0.85556],
				934: [0, 0.69444, 0, 0, 0.79445],
				936: [0, 0.69444, 0, 0, 0.85556],
				937: [0, 0.69444, 0, 0, 0.79445],
				8211: [0, 0.45833, 0.03056, 0, 0.55],
				8212: [0, 0.45833, 0.03056, 0, 1.10001],
				8216: [0, 0.69444, 0, 0, 0.30556],
				8217: [0, 0.69444, 0, 0, 0.30556],
				8220: [0, 0.69444, 0, 0, 0.55834],
				8221: [0, 0.69444, 0, 0, 0.55834],
			},
			"SansSerif-Italic": {
				32: [0, 0, 0, 0, 0.25],
				33: [0, 0.69444, 0.05733, 0, 0.31945],
				34: [0, 0.69444, 0.00316, 0, 0.5],
				35: [0.19444, 0.69444, 0.05087, 0, 0.83334],
				36: [0.05556, 0.75, 0.11156, 0, 0.5],
				37: [0.05556, 0.75, 0.03126, 0, 0.83334],
				38: [0, 0.69444, 0.03058, 0, 0.75834],
				39: [0, 0.69444, 0.07816, 0, 0.27778],
				40: [0.25, 0.75, 0.13164, 0, 0.38889],
				41: [0.25, 0.75, 0.02536, 0, 0.38889],
				42: [0, 0.75, 0.11775, 0, 0.5],
				43: [0.08333, 0.58333, 0.02536, 0, 0.77778],
				44: [0.125, 0.08333, 0, 0, 0.27778],
				45: [0, 0.44444, 0.01946, 0, 0.33333],
				46: [0, 0.08333, 0, 0, 0.27778],
				47: [0.25, 0.75, 0.13164, 0, 0.5],
				48: [0, 0.65556, 0.11156, 0, 0.5],
				49: [0, 0.65556, 0.11156, 0, 0.5],
				50: [0, 0.65556, 0.11156, 0, 0.5],
				51: [0, 0.65556, 0.11156, 0, 0.5],
				52: [0, 0.65556, 0.11156, 0, 0.5],
				53: [0, 0.65556, 0.11156, 0, 0.5],
				54: [0, 0.65556, 0.11156, 0, 0.5],
				55: [0, 0.65556, 0.11156, 0, 0.5],
				56: [0, 0.65556, 0.11156, 0, 0.5],
				57: [0, 0.65556, 0.11156, 0, 0.5],
				58: [0, 0.44444, 0.02502, 0, 0.27778],
				59: [0.125, 0.44444, 0.02502, 0, 0.27778],
				61: [-0.13, 0.37, 0.05087, 0, 0.77778],
				63: [0, 0.69444, 0.11809, 0, 0.47222],
				64: [0, 0.69444, 0.07555, 0, 0.66667],
				65: [0, 0.69444, 0, 0, 0.66667],
				66: [0, 0.69444, 0.08293, 0, 0.66667],
				67: [0, 0.69444, 0.11983, 0, 0.63889],
				68: [0, 0.69444, 0.07555, 0, 0.72223],
				69: [0, 0.69444, 0.11983, 0, 0.59722],
				70: [0, 0.69444, 0.13372, 0, 0.56945],
				71: [0, 0.69444, 0.11983, 0, 0.66667],
				72: [0, 0.69444, 0.08094, 0, 0.70834],
				73: [0, 0.69444, 0.13372, 0, 0.27778],
				74: [0, 0.69444, 0.08094, 0, 0.47222],
				75: [0, 0.69444, 0.11983, 0, 0.69445],
				76: [0, 0.69444, 0, 0, 0.54167],
				77: [0, 0.69444, 0.08094, 0, 0.875],
				78: [0, 0.69444, 0.08094, 0, 0.70834],
				79: [0, 0.69444, 0.07555, 0, 0.73611],
				80: [0, 0.69444, 0.08293, 0, 0.63889],
				81: [0.125, 0.69444, 0.07555, 0, 0.73611],
				82: [0, 0.69444, 0.08293, 0, 0.64584],
				83: [0, 0.69444, 0.09205, 0, 0.55556],
				84: [0, 0.69444, 0.13372, 0, 0.68056],
				85: [0, 0.69444, 0.08094, 0, 0.6875],
				86: [0, 0.69444, 0.1615, 0, 0.66667],
				87: [0, 0.69444, 0.1615, 0, 0.94445],
				88: [0, 0.69444, 0.13372, 0, 0.66667],
				89: [0, 0.69444, 0.17261, 0, 0.66667],
				90: [0, 0.69444, 0.11983, 0, 0.61111],
				91: [0.25, 0.75, 0.15942, 0, 0.28889],
				93: [0.25, 0.75, 0.08719, 0, 0.28889],
				94: [0, 0.69444, 0.0799, 0, 0.5],
				95: [0.35, 0.09444, 0.08616, 0, 0.5],
				97: [0, 0.44444, 0.00981, 0, 0.48056],
				98: [0, 0.69444, 0.03057, 0, 0.51667],
				99: [0, 0.44444, 0.08336, 0, 0.44445],
				100: [0, 0.69444, 0.09483, 0, 0.51667],
				101: [0, 0.44444, 0.06778, 0, 0.44445],
				102: [0, 0.69444, 0.21705, 0, 0.30556],
				103: [0.19444, 0.44444, 0.10836, 0, 0.5],
				104: [0, 0.69444, 0.01778, 0, 0.51667],
				105: [0, 0.67937, 0.09718, 0, 0.23889],
				106: [0.19444, 0.67937, 0.09162, 0, 0.26667],
				107: [0, 0.69444, 0.08336, 0, 0.48889],
				108: [0, 0.69444, 0.09483, 0, 0.23889],
				109: [0, 0.44444, 0.01778, 0, 0.79445],
				110: [0, 0.44444, 0.01778, 0, 0.51667],
				111: [0, 0.44444, 0.06613, 0, 0.5],
				112: [0.19444, 0.44444, 0.0389, 0, 0.51667],
				113: [0.19444, 0.44444, 0.04169, 0, 0.51667],
				114: [0, 0.44444, 0.10836, 0, 0.34167],
				115: [0, 0.44444, 0.0778, 0, 0.38333],
				116: [0, 0.57143, 0.07225, 0, 0.36111],
				117: [0, 0.44444, 0.04169, 0, 0.51667],
				118: [0, 0.44444, 0.10836, 0, 0.46111],
				119: [0, 0.44444, 0.10836, 0, 0.68334],
				120: [0, 0.44444, 0.09169, 0, 0.46111],
				121: [0.19444, 0.44444, 0.10836, 0, 0.46111],
				122: [0, 0.44444, 0.08752, 0, 0.43472],
				126: [0.35, 0.32659, 0.08826, 0, 0.5],
				160: [0, 0, 0, 0, 0.25],
				168: [0, 0.67937, 0.06385, 0, 0.5],
				176: [0, 0.69444, 0, 0, 0.73752],
				184: [0.17014, 0, 0, 0, 0.44445],
				305: [0, 0.44444, 0.04169, 0, 0.23889],
				567: [0.19444, 0.44444, 0.04169, 0, 0.26667],
				710: [0, 0.69444, 0.0799, 0, 0.5],
				711: [0, 0.63194, 0.08432, 0, 0.5],
				713: [0, 0.60889, 0.08776, 0, 0.5],
				714: [0, 0.69444, 0.09205, 0, 0.5],
				715: [0, 0.69444, 0, 0, 0.5],
				728: [0, 0.69444, 0.09483, 0, 0.5],
				729: [0, 0.67937, 0.07774, 0, 0.27778],
				730: [0, 0.69444, 0, 0, 0.73752],
				732: [0, 0.67659, 0.08826, 0, 0.5],
				733: [0, 0.69444, 0.09205, 0, 0.5],
				915: [0, 0.69444, 0.13372, 0, 0.54167],
				916: [0, 0.69444, 0, 0, 0.83334],
				920: [0, 0.69444, 0.07555, 0, 0.77778],
				923: [0, 0.69444, 0, 0, 0.61111],
				926: [0, 0.69444, 0.12816, 0, 0.66667],
				928: [0, 0.69444, 0.08094, 0, 0.70834],
				931: [0, 0.69444, 0.11983, 0, 0.72222],
				933: [0, 0.69444, 0.09031, 0, 0.77778],
				934: [0, 0.69444, 0.04603, 0, 0.72222],
				936: [0, 0.69444, 0.09031, 0, 0.77778],
				937: [0, 0.69444, 0.08293, 0, 0.72222],
				8211: [0, 0.44444, 0.08616, 0, 0.5],
				8212: [0, 0.44444, 0.08616, 0, 1],
				8216: [0, 0.69444, 0.07816, 0, 0.27778],
				8217: [0, 0.69444, 0.07816, 0, 0.27778],
				8220: [0, 0.69444, 0.14205, 0, 0.5],
				8221: [0, 0.69444, 0.00316, 0, 0.5],
			},
			"SansSerif-Regular": {
				32: [0, 0, 0, 0, 0.25],
				33: [0, 0.69444, 0, 0, 0.31945],
				34: [0, 0.69444, 0, 0, 0.5],
				35: [0.19444, 0.69444, 0, 0, 0.83334],
				36: [0.05556, 0.75, 0, 0, 0.5],
				37: [0.05556, 0.75, 0, 0, 0.83334],
				38: [0, 0.69444, 0, 0, 0.75834],
				39: [0, 0.69444, 0, 0, 0.27778],
				40: [0.25, 0.75, 0, 0, 0.38889],
				41: [0.25, 0.75, 0, 0, 0.38889],
				42: [0, 0.75, 0, 0, 0.5],
				43: [0.08333, 0.58333, 0, 0, 0.77778],
				44: [0.125, 0.08333, 0, 0, 0.27778],
				45: [0, 0.44444, 0, 0, 0.33333],
				46: [0, 0.08333, 0, 0, 0.27778],
				47: [0.25, 0.75, 0, 0, 0.5],
				48: [0, 0.65556, 0, 0, 0.5],
				49: [0, 0.65556, 0, 0, 0.5],
				50: [0, 0.65556, 0, 0, 0.5],
				51: [0, 0.65556, 0, 0, 0.5],
				52: [0, 0.65556, 0, 0, 0.5],
				53: [0, 0.65556, 0, 0, 0.5],
				54: [0, 0.65556, 0, 0, 0.5],
				55: [0, 0.65556, 0, 0, 0.5],
				56: [0, 0.65556, 0, 0, 0.5],
				57: [0, 0.65556, 0, 0, 0.5],
				58: [0, 0.44444, 0, 0, 0.27778],
				59: [0.125, 0.44444, 0, 0, 0.27778],
				61: [-0.13, 0.37, 0, 0, 0.77778],
				63: [0, 0.69444, 0, 0, 0.47222],
				64: [0, 0.69444, 0, 0, 0.66667],
				65: [0, 0.69444, 0, 0, 0.66667],
				66: [0, 0.69444, 0, 0, 0.66667],
				67: [0, 0.69444, 0, 0, 0.63889],
				68: [0, 0.69444, 0, 0, 0.72223],
				69: [0, 0.69444, 0, 0, 0.59722],
				70: [0, 0.69444, 0, 0, 0.56945],
				71: [0, 0.69444, 0, 0, 0.66667],
				72: [0, 0.69444, 0, 0, 0.70834],
				73: [0, 0.69444, 0, 0, 0.27778],
				74: [0, 0.69444, 0, 0, 0.47222],
				75: [0, 0.69444, 0, 0, 0.69445],
				76: [0, 0.69444, 0, 0, 0.54167],
				77: [0, 0.69444, 0, 0, 0.875],
				78: [0, 0.69444, 0, 0, 0.70834],
				79: [0, 0.69444, 0, 0, 0.73611],
				80: [0, 0.69444, 0, 0, 0.63889],
				81: [0.125, 0.69444, 0, 0, 0.73611],
				82: [0, 0.69444, 0, 0, 0.64584],
				83: [0, 0.69444, 0, 0, 0.55556],
				84: [0, 0.69444, 0, 0, 0.68056],
				85: [0, 0.69444, 0, 0, 0.6875],
				86: [0, 0.69444, 0.01389, 0, 0.66667],
				87: [0, 0.69444, 0.01389, 0, 0.94445],
				88: [0, 0.69444, 0, 0, 0.66667],
				89: [0, 0.69444, 0.025, 0, 0.66667],
				90: [0, 0.69444, 0, 0, 0.61111],
				91: [0.25, 0.75, 0, 0, 0.28889],
				93: [0.25, 0.75, 0, 0, 0.28889],
				94: [0, 0.69444, 0, 0, 0.5],
				95: [0.35, 0.09444, 0.02778, 0, 0.5],
				97: [0, 0.44444, 0, 0, 0.48056],
				98: [0, 0.69444, 0, 0, 0.51667],
				99: [0, 0.44444, 0, 0, 0.44445],
				100: [0, 0.69444, 0, 0, 0.51667],
				101: [0, 0.44444, 0, 0, 0.44445],
				102: [0, 0.69444, 0.06944, 0, 0.30556],
				103: [0.19444, 0.44444, 0.01389, 0, 0.5],
				104: [0, 0.69444, 0, 0, 0.51667],
				105: [0, 0.67937, 0, 0, 0.23889],
				106: [0.19444, 0.67937, 0, 0, 0.26667],
				107: [0, 0.69444, 0, 0, 0.48889],
				108: [0, 0.69444, 0, 0, 0.23889],
				109: [0, 0.44444, 0, 0, 0.79445],
				110: [0, 0.44444, 0, 0, 0.51667],
				111: [0, 0.44444, 0, 0, 0.5],
				112: [0.19444, 0.44444, 0, 0, 0.51667],
				113: [0.19444, 0.44444, 0, 0, 0.51667],
				114: [0, 0.44444, 0.01389, 0, 0.34167],
				115: [0, 0.44444, 0, 0, 0.38333],
				116: [0, 0.57143, 0, 0, 0.36111],
				117: [0, 0.44444, 0, 0, 0.51667],
				118: [0, 0.44444, 0.01389, 0, 0.46111],
				119: [0, 0.44444, 0.01389, 0, 0.68334],
				120: [0, 0.44444, 0, 0, 0.46111],
				121: [0.19444, 0.44444, 0.01389, 0, 0.46111],
				122: [0, 0.44444, 0, 0, 0.43472],
				126: [0.35, 0.32659, 0, 0, 0.5],
				160: [0, 0, 0, 0, 0.25],
				168: [0, 0.67937, 0, 0, 0.5],
				176: [0, 0.69444, 0, 0, 0.66667],
				184: [0.17014, 0, 0, 0, 0.44445],
				305: [0, 0.44444, 0, 0, 0.23889],
				567: [0.19444, 0.44444, 0, 0, 0.26667],
				710: [0, 0.69444, 0, 0, 0.5],
				711: [0, 0.63194, 0, 0, 0.5],
				713: [0, 0.60889, 0, 0, 0.5],
				714: [0, 0.69444, 0, 0, 0.5],
				715: [0, 0.69444, 0, 0, 0.5],
				728: [0, 0.69444, 0, 0, 0.5],
				729: [0, 0.67937, 0, 0, 0.27778],
				730: [0, 0.69444, 0, 0, 0.66667],
				732: [0, 0.67659, 0, 0, 0.5],
				733: [0, 0.69444, 0, 0, 0.5],
				915: [0, 0.69444, 0, 0, 0.54167],
				916: [0, 0.69444, 0, 0, 0.83334],
				920: [0, 0.69444, 0, 0, 0.77778],
				923: [0, 0.69444, 0, 0, 0.61111],
				926: [0, 0.69444, 0, 0, 0.66667],
				928: [0, 0.69444, 0, 0, 0.70834],
				931: [0, 0.69444, 0, 0, 0.72222],
				933: [0, 0.69444, 0, 0, 0.77778],
				934: [0, 0.69444, 0, 0, 0.72222],
				936: [0, 0.69444, 0, 0, 0.77778],
				937: [0, 0.69444, 0, 0, 0.72222],
				8211: [0, 0.44444, 0.02778, 0, 0.5],
				8212: [0, 0.44444, 0.02778, 0, 1],
				8216: [0, 0.69444, 0, 0, 0.27778],
				8217: [0, 0.69444, 0, 0, 0.27778],
				8220: [0, 0.69444, 0, 0, 0.5],
				8221: [0, 0.69444, 0, 0, 0.5],
			},
			"Script-Regular": {
				32: [0, 0, 0, 0, 0.25],
				65: [0, 0.7, 0.22925, 0, 0.80253],
				66: [0, 0.7, 0.04087, 0, 0.90757],
				67: [0, 0.7, 0.1689, 0, 0.66619],
				68: [0, 0.7, 0.09371, 0, 0.77443],
				69: [0, 0.7, 0.18583, 0, 0.56162],
				70: [0, 0.7, 0.13634, 0, 0.89544],
				71: [0, 0.7, 0.17322, 0, 0.60961],
				72: [0, 0.7, 0.29694, 0, 0.96919],
				73: [0, 0.7, 0.19189, 0, 0.80907],
				74: [0.27778, 0.7, 0.19189, 0, 1.05159],
				75: [0, 0.7, 0.31259, 0, 0.91364],
				76: [0, 0.7, 0.19189, 0, 0.87373],
				77: [0, 0.7, 0.15981, 0, 1.08031],
				78: [0, 0.7, 0.3525, 0, 0.9015],
				79: [0, 0.7, 0.08078, 0, 0.73787],
				80: [0, 0.7, 0.08078, 0, 1.01262],
				81: [0, 0.7, 0.03305, 0, 0.88282],
				82: [0, 0.7, 0.06259, 0, 0.85],
				83: [0, 0.7, 0.19189, 0, 0.86767],
				84: [0, 0.7, 0.29087, 0, 0.74697],
				85: [0, 0.7, 0.25815, 0, 0.79996],
				86: [0, 0.7, 0.27523, 0, 0.62204],
				87: [0, 0.7, 0.27523, 0, 0.80532],
				88: [0, 0.7, 0.26006, 0, 0.94445],
				89: [0, 0.7, 0.2939, 0, 0.70961],
				90: [0, 0.7, 0.24037, 0, 0.8212],
				160: [0, 0, 0, 0, 0.25],
			},
			"Size1-Regular": {
				32: [0, 0, 0, 0, 0.25],
				40: [0.35001, 0.85, 0, 0, 0.45834],
				41: [0.35001, 0.85, 0, 0, 0.45834],
				47: [0.35001, 0.85, 0, 0, 0.57778],
				91: [0.35001, 0.85, 0, 0, 0.41667],
				92: [0.35001, 0.85, 0, 0, 0.57778],
				93: [0.35001, 0.85, 0, 0, 0.41667],
				123: [0.35001, 0.85, 0, 0, 0.58334],
				125: [0.35001, 0.85, 0, 0, 0.58334],
				160: [0, 0, 0, 0, 0.25],
				710: [0, 0.72222, 0, 0, 0.55556],
				732: [0, 0.72222, 0, 0, 0.55556],
				770: [0, 0.72222, 0, 0, 0.55556],
				771: [0, 0.72222, 0, 0, 0.55556],
				8214: [-99e-5, 0.601, 0, 0, 0.77778],
				8593: [1e-5, 0.6, 0, 0, 0.66667],
				8595: [1e-5, 0.6, 0, 0, 0.66667],
				8657: [1e-5, 0.6, 0, 0, 0.77778],
				8659: [1e-5, 0.6, 0, 0, 0.77778],
				8719: [0.25001, 0.75, 0, 0, 0.94445],
				8720: [0.25001, 0.75, 0, 0, 0.94445],
				8721: [0.25001, 0.75, 0, 0, 1.05556],
				8730: [0.35001, 0.85, 0, 0, 1],
				8739: [-0.00599, 0.606, 0, 0, 0.33333],
				8741: [-0.00599, 0.606, 0, 0, 0.55556],
				8747: [0.30612, 0.805, 0.19445, 0, 0.47222],
				8748: [0.306, 0.805, 0.19445, 0, 0.47222],
				8749: [0.306, 0.805, 0.19445, 0, 0.47222],
				8750: [0.30612, 0.805, 0.19445, 0, 0.47222],
				8896: [0.25001, 0.75, 0, 0, 0.83334],
				8897: [0.25001, 0.75, 0, 0, 0.83334],
				8898: [0.25001, 0.75, 0, 0, 0.83334],
				8899: [0.25001, 0.75, 0, 0, 0.83334],
				8968: [0.35001, 0.85, 0, 0, 0.47222],
				8969: [0.35001, 0.85, 0, 0, 0.47222],
				8970: [0.35001, 0.85, 0, 0, 0.47222],
				8971: [0.35001, 0.85, 0, 0, 0.47222],
				9168: [-99e-5, 0.601, 0, 0, 0.66667],
				10216: [0.35001, 0.85, 0, 0, 0.47222],
				10217: [0.35001, 0.85, 0, 0, 0.47222],
				10752: [0.25001, 0.75, 0, 0, 1.11111],
				10753: [0.25001, 0.75, 0, 0, 1.11111],
				10754: [0.25001, 0.75, 0, 0, 1.11111],
				10756: [0.25001, 0.75, 0, 0, 0.83334],
				10758: [0.25001, 0.75, 0, 0, 0.83334],
			},
			"Size2-Regular": {
				32: [0, 0, 0, 0, 0.25],
				40: [0.65002, 1.15, 0, 0, 0.59722],
				41: [0.65002, 1.15, 0, 0, 0.59722],
				47: [0.65002, 1.15, 0, 0, 0.81111],
				91: [0.65002, 1.15, 0, 0, 0.47222],
				92: [0.65002, 1.15, 0, 0, 0.81111],
				93: [0.65002, 1.15, 0, 0, 0.47222],
				123: [0.65002, 1.15, 0, 0, 0.66667],
				125: [0.65002, 1.15, 0, 0, 0.66667],
				160: [0, 0, 0, 0, 0.25],
				710: [0, 0.75, 0, 0, 1],
				732: [0, 0.75, 0, 0, 1],
				770: [0, 0.75, 0, 0, 1],
				771: [0, 0.75, 0, 0, 1],
				8719: [0.55001, 1.05, 0, 0, 1.27778],
				8720: [0.55001, 1.05, 0, 0, 1.27778],
				8721: [0.55001, 1.05, 0, 0, 1.44445],
				8730: [0.65002, 1.15, 0, 0, 1],
				8747: [0.86225, 1.36, 0.44445, 0, 0.55556],
				8748: [0.862, 1.36, 0.44445, 0, 0.55556],
				8749: [0.862, 1.36, 0.44445, 0, 0.55556],
				8750: [0.86225, 1.36, 0.44445, 0, 0.55556],
				8896: [0.55001, 1.05, 0, 0, 1.11111],
				8897: [0.55001, 1.05, 0, 0, 1.11111],
				8898: [0.55001, 1.05, 0, 0, 1.11111],
				8899: [0.55001, 1.05, 0, 0, 1.11111],
				8968: [0.65002, 1.15, 0, 0, 0.52778],
				8969: [0.65002, 1.15, 0, 0, 0.52778],
				8970: [0.65002, 1.15, 0, 0, 0.52778],
				8971: [0.65002, 1.15, 0, 0, 0.52778],
				10216: [0.65002, 1.15, 0, 0, 0.61111],
				10217: [0.65002, 1.15, 0, 0, 0.61111],
				10752: [0.55001, 1.05, 0, 0, 1.51112],
				10753: [0.55001, 1.05, 0, 0, 1.51112],
				10754: [0.55001, 1.05, 0, 0, 1.51112],
				10756: [0.55001, 1.05, 0, 0, 1.11111],
				10758: [0.55001, 1.05, 0, 0, 1.11111],
			},
			"Size3-Regular": {
				32: [0, 0, 0, 0, 0.25],
				40: [0.95003, 1.45, 0, 0, 0.73611],
				41: [0.95003, 1.45, 0, 0, 0.73611],
				47: [0.95003, 1.45, 0, 0, 1.04445],
				91: [0.95003, 1.45, 0, 0, 0.52778],
				92: [0.95003, 1.45, 0, 0, 1.04445],
				93: [0.95003, 1.45, 0, 0, 0.52778],
				123: [0.95003, 1.45, 0, 0, 0.75],
				125: [0.95003, 1.45, 0, 0, 0.75],
				160: [0, 0, 0, 0, 0.25],
				710: [0, 0.75, 0, 0, 1.44445],
				732: [0, 0.75, 0, 0, 1.44445],
				770: [0, 0.75, 0, 0, 1.44445],
				771: [0, 0.75, 0, 0, 1.44445],
				8730: [0.95003, 1.45, 0, 0, 1],
				8968: [0.95003, 1.45, 0, 0, 0.58334],
				8969: [0.95003, 1.45, 0, 0, 0.58334],
				8970: [0.95003, 1.45, 0, 0, 0.58334],
				8971: [0.95003, 1.45, 0, 0, 0.58334],
				10216: [0.95003, 1.45, 0, 0, 0.75],
				10217: [0.95003, 1.45, 0, 0, 0.75],
			},
			"Size4-Regular": {
				32: [0, 0, 0, 0, 0.25],
				40: [1.25003, 1.75, 0, 0, 0.79167],
				41: [1.25003, 1.75, 0, 0, 0.79167],
				47: [1.25003, 1.75, 0, 0, 1.27778],
				91: [1.25003, 1.75, 0, 0, 0.58334],
				92: [1.25003, 1.75, 0, 0, 1.27778],
				93: [1.25003, 1.75, 0, 0, 0.58334],
				123: [1.25003, 1.75, 0, 0, 0.80556],
				125: [1.25003, 1.75, 0, 0, 0.80556],
				160: [0, 0, 0, 0, 0.25],
				710: [0, 0.825, 0, 0, 1.8889],
				732: [0, 0.825, 0, 0, 1.8889],
				770: [0, 0.825, 0, 0, 1.8889],
				771: [0, 0.825, 0, 0, 1.8889],
				8730: [1.25003, 1.75, 0, 0, 1],
				8968: [1.25003, 1.75, 0, 0, 0.63889],
				8969: [1.25003, 1.75, 0, 0, 0.63889],
				8970: [1.25003, 1.75, 0, 0, 0.63889],
				8971: [1.25003, 1.75, 0, 0, 0.63889],
				9115: [0.64502, 1.155, 0, 0, 0.875],
				9116: [1e-5, 0.6, 0, 0, 0.875],
				9117: [0.64502, 1.155, 0, 0, 0.875],
				9118: [0.64502, 1.155, 0, 0, 0.875],
				9119: [1e-5, 0.6, 0, 0, 0.875],
				9120: [0.64502, 1.155, 0, 0, 0.875],
				9121: [0.64502, 1.155, 0, 0, 0.66667],
				9122: [-99e-5, 0.601, 0, 0, 0.66667],
				9123: [0.64502, 1.155, 0, 0, 0.66667],
				9124: [0.64502, 1.155, 0, 0, 0.66667],
				9125: [-99e-5, 0.601, 0, 0, 0.66667],
				9126: [0.64502, 1.155, 0, 0, 0.66667],
				9127: [1e-5, 0.9, 0, 0, 0.88889],
				9128: [0.65002, 1.15, 0, 0, 0.88889],
				9129: [0.90001, 0, 0, 0, 0.88889],
				9130: [0, 0.3, 0, 0, 0.88889],
				9131: [1e-5, 0.9, 0, 0, 0.88889],
				9132: [0.65002, 1.15, 0, 0, 0.88889],
				9133: [0.90001, 0, 0, 0, 0.88889],
				9143: [0.88502, 0.915, 0, 0, 1.05556],
				10216: [1.25003, 1.75, 0, 0, 0.80556],
				10217: [1.25003, 1.75, 0, 0, 0.80556],
				57344: [-0.00499, 0.605, 0, 0, 1.05556],
				57345: [-0.00499, 0.605, 0, 0, 1.05556],
				57680: [0, 0.12, 0, 0, 0.45],
				57681: [0, 0.12, 0, 0, 0.45],
				57682: [0, 0.12, 0, 0, 0.45],
				57683: [0, 0.12, 0, 0, 0.45],
			},
			"Typewriter-Regular": {
				32: [0, 0, 0, 0, 0.525],
				33: [0, 0.61111, 0, 0, 0.525],
				34: [0, 0.61111, 0, 0, 0.525],
				35: [0, 0.61111, 0, 0, 0.525],
				36: [0.08333, 0.69444, 0, 0, 0.525],
				37: [0.08333, 0.69444, 0, 0, 0.525],
				38: [0, 0.61111, 0, 0, 0.525],
				39: [0, 0.61111, 0, 0, 0.525],
				40: [0.08333, 0.69444, 0, 0, 0.525],
				41: [0.08333, 0.69444, 0, 0, 0.525],
				42: [0, 0.52083, 0, 0, 0.525],
				43: [-0.08056, 0.53055, 0, 0, 0.525],
				44: [0.13889, 0.125, 0, 0, 0.525],
				45: [-0.08056, 0.53055, 0, 0, 0.525],
				46: [0, 0.125, 0, 0, 0.525],
				47: [0.08333, 0.69444, 0, 0, 0.525],
				48: [0, 0.61111, 0, 0, 0.525],
				49: [0, 0.61111, 0, 0, 0.525],
				50: [0, 0.61111, 0, 0, 0.525],
				51: [0, 0.61111, 0, 0, 0.525],
				52: [0, 0.61111, 0, 0, 0.525],
				53: [0, 0.61111, 0, 0, 0.525],
				54: [0, 0.61111, 0, 0, 0.525],
				55: [0, 0.61111, 0, 0, 0.525],
				56: [0, 0.61111, 0, 0, 0.525],
				57: [0, 0.61111, 0, 0, 0.525],
				58: [0, 0.43056, 0, 0, 0.525],
				59: [0.13889, 0.43056, 0, 0, 0.525],
				60: [-0.05556, 0.55556, 0, 0, 0.525],
				61: [-0.19549, 0.41562, 0, 0, 0.525],
				62: [-0.05556, 0.55556, 0, 0, 0.525],
				63: [0, 0.61111, 0, 0, 0.525],
				64: [0, 0.61111, 0, 0, 0.525],
				65: [0, 0.61111, 0, 0, 0.525],
				66: [0, 0.61111, 0, 0, 0.525],
				67: [0, 0.61111, 0, 0, 0.525],
				68: [0, 0.61111, 0, 0, 0.525],
				69: [0, 0.61111, 0, 0, 0.525],
				70: [0, 0.61111, 0, 0, 0.525],
				71: [0, 0.61111, 0, 0, 0.525],
				72: [0, 0.61111, 0, 0, 0.525],
				73: [0, 0.61111, 0, 0, 0.525],
				74: [0, 0.61111, 0, 0, 0.525],
				75: [0, 0.61111, 0, 0, 0.525],
				76: [0, 0.61111, 0, 0, 0.525],
				77: [0, 0.61111, 0, 0, 0.525],
				78: [0, 0.61111, 0, 0, 0.525],
				79: [0, 0.61111, 0, 0, 0.525],
				80: [0, 0.61111, 0, 0, 0.525],
				81: [0.13889, 0.61111, 0, 0, 0.525],
				82: [0, 0.61111, 0, 0, 0.525],
				83: [0, 0.61111, 0, 0, 0.525],
				84: [0, 0.61111, 0, 0, 0.525],
				85: [0, 0.61111, 0, 0, 0.525],
				86: [0, 0.61111, 0, 0, 0.525],
				87: [0, 0.61111, 0, 0, 0.525],
				88: [0, 0.61111, 0, 0, 0.525],
				89: [0, 0.61111, 0, 0, 0.525],
				90: [0, 0.61111, 0, 0, 0.525],
				91: [0.08333, 0.69444, 0, 0, 0.525],
				92: [0.08333, 0.69444, 0, 0, 0.525],
				93: [0.08333, 0.69444, 0, 0, 0.525],
				94: [0, 0.61111, 0, 0, 0.525],
				95: [0.09514, 0, 0, 0, 0.525],
				96: [0, 0.61111, 0, 0, 0.525],
				97: [0, 0.43056, 0, 0, 0.525],
				98: [0, 0.61111, 0, 0, 0.525],
				99: [0, 0.43056, 0, 0, 0.525],
				100: [0, 0.61111, 0, 0, 0.525],
				101: [0, 0.43056, 0, 0, 0.525],
				102: [0, 0.61111, 0, 0, 0.525],
				103: [0.22222, 0.43056, 0, 0, 0.525],
				104: [0, 0.61111, 0, 0, 0.525],
				105: [0, 0.61111, 0, 0, 0.525],
				106: [0.22222, 0.61111, 0, 0, 0.525],
				107: [0, 0.61111, 0, 0, 0.525],
				108: [0, 0.61111, 0, 0, 0.525],
				109: [0, 0.43056, 0, 0, 0.525],
				110: [0, 0.43056, 0, 0, 0.525],
				111: [0, 0.43056, 0, 0, 0.525],
				112: [0.22222, 0.43056, 0, 0, 0.525],
				113: [0.22222, 0.43056, 0, 0, 0.525],
				114: [0, 0.43056, 0, 0, 0.525],
				115: [0, 0.43056, 0, 0, 0.525],
				116: [0, 0.55358, 0, 0, 0.525],
				117: [0, 0.43056, 0, 0, 0.525],
				118: [0, 0.43056, 0, 0, 0.525],
				119: [0, 0.43056, 0, 0, 0.525],
				120: [0, 0.43056, 0, 0, 0.525],
				121: [0.22222, 0.43056, 0, 0, 0.525],
				122: [0, 0.43056, 0, 0, 0.525],
				123: [0.08333, 0.69444, 0, 0, 0.525],
				124: [0.08333, 0.69444, 0, 0, 0.525],
				125: [0.08333, 0.69444, 0, 0, 0.525],
				126: [0, 0.61111, 0, 0, 0.525],
				127: [0, 0.61111, 0, 0, 0.525],
				160: [0, 0, 0, 0, 0.525],
				176: [0, 0.61111, 0, 0, 0.525],
				184: [0.19445, 0, 0, 0, 0.525],
				305: [0, 0.43056, 0, 0, 0.525],
				567: [0.22222, 0.43056, 0, 0, 0.525],
				711: [0, 0.56597, 0, 0, 0.525],
				713: [0, 0.56555, 0, 0, 0.525],
				714: [0, 0.61111, 0, 0, 0.525],
				715: [0, 0.61111, 0, 0, 0.525],
				728: [0, 0.61111, 0, 0, 0.525],
				730: [0, 0.61111, 0, 0, 0.525],
				770: [0, 0.61111, 0, 0, 0.525],
				771: [0, 0.61111, 0, 0, 0.525],
				776: [0, 0.61111, 0, 0, 0.525],
				915: [0, 0.61111, 0, 0, 0.525],
				916: [0, 0.61111, 0, 0, 0.525],
				920: [0, 0.61111, 0, 0, 0.525],
				923: [0, 0.61111, 0, 0, 0.525],
				926: [0, 0.61111, 0, 0, 0.525],
				928: [0, 0.61111, 0, 0, 0.525],
				931: [0, 0.61111, 0, 0, 0.525],
				933: [0, 0.61111, 0, 0, 0.525],
				934: [0, 0.61111, 0, 0, 0.525],
				936: [0, 0.61111, 0, 0, 0.525],
				937: [0, 0.61111, 0, 0, 0.525],
				8216: [0, 0.61111, 0, 0, 0.525],
				8217: [0, 0.61111, 0, 0, 0.525],
				8242: [0, 0.61111, 0, 0, 0.525],
				9251: [0.11111, 0.21944, 0, 0, 0.525],
			},
		},
		Tr = {
			slant: [0.25, 0.25, 0.25],
			space: [0, 0, 0],
			stretch: [0, 0, 0],
			shrink: [0, 0, 0],
			xHeight: [0.431, 0.431, 0.431],
			quad: [1, 1.171, 1.472],
			extraSpace: [0, 0, 0],
			num1: [0.677, 0.732, 0.925],
			num2: [0.394, 0.384, 0.387],
			num3: [0.444, 0.471, 0.504],
			denom1: [0.686, 0.752, 1.025],
			denom2: [0.345, 0.344, 0.532],
			sup1: [0.413, 0.503, 0.504],
			sup2: [0.363, 0.431, 0.404],
			sup3: [0.289, 0.286, 0.294],
			sub1: [0.15, 0.143, 0.2],
			sub2: [0.247, 0.286, 0.4],
			supDrop: [0.386, 0.353, 0.494],
			subDrop: [0.05, 0.071, 0.1],
			delim1: [2.39, 1.7, 1.98],
			delim2: [1.01, 1.157, 1.42],
			axisHeight: [0.25, 0.25, 0.25],
			defaultRuleThickness: [0.04, 0.049, 0.049],
			bigOpSpacing1: [0.111, 0.111, 0.111],
			bigOpSpacing2: [0.166, 0.166, 0.166],
			bigOpSpacing3: [0.2, 0.2, 0.2],
			bigOpSpacing4: [0.6, 0.611, 0.611],
			bigOpSpacing5: [0.1, 0.143, 0.143],
			sqrtRuleThickness: [0.04, 0.04, 0.04],
			ptPerEm: [10, 10, 10],
			doubleRuleSep: [0.2, 0.2, 0.2],
			arrayRuleWidth: [0.04, 0.04, 0.04],
			fboxsep: [0.3, 0.3, 0.3],
			fboxrule: [0.04, 0.04, 0.04],
		},
		Mn = {
			Å: "A",
			Ð: "D",
			Þ: "o",
			å: "a",
			ð: "d",
			þ: "o",
			А: "A",
			Б: "B",
			В: "B",
			Г: "F",
			Д: "A",
			Е: "E",
			Ж: "K",
			З: "3",
			И: "N",
			Й: "N",
			К: "K",
			Л: "N",
			М: "M",
			Н: "H",
			О: "O",
			П: "N",
			Р: "P",
			С: "C",
			Т: "T",
			У: "y",
			Ф: "O",
			Х: "X",
			Ц: "U",
			Ч: "h",
			Ш: "W",
			Щ: "W",
			Ъ: "B",
			Ы: "X",
			Ь: "B",
			Э: "3",
			Ю: "X",
			Я: "R",
			а: "a",
			б: "b",
			в: "a",
			г: "r",
			д: "y",
			е: "e",
			ж: "m",
			з: "e",
			и: "n",
			й: "n",
			к: "n",
			л: "n",
			м: "m",
			н: "n",
			о: "o",
			п: "n",
			р: "p",
			с: "c",
			т: "o",
			у: "y",
			ф: "b",
			х: "x",
			ц: "n",
			ч: "n",
			ш: "w",
			щ: "w",
			ъ: "a",
			ы: "m",
			ь: "a",
			э: "e",
			ю: "m",
			я: "r",
		};
	function Ns(r, e) {
		lt[r] = e;
	}
	function f0(r, e, t) {
		if (!lt[e]) throw new Error("Font metrics not found for font: " + e + ".");
		var n = r.charCodeAt(0),
			a = lt[e][n];
		if (
			(!a && r[0] in Mn && ((n = Mn[r[0]].charCodeAt(0)), (a = lt[e][n])),
			!a && t === "text" && En(n) && (a = lt[e][77]),
			a)
		)
			return { depth: a[0], height: a[1], italic: a[2], skew: a[3], width: a[4] };
	}
	var g0 = {};
	function Os(r) {
		var e;
		if ((r >= 5 ? (e = 0) : r >= 3 ? (e = 1) : (e = 2), !g0[e])) {
			var t = (g0[e] = { cssEmPerMu: Tr.quad[e] / 18 });
			for (var n in Tr) Tr.hasOwnProperty(n) && (t[n] = Tr[n][e]);
		}
		return g0[e];
	}
	var zs = [
			[1, 1, 1],
			[2, 1, 1],
			[3, 1, 1],
			[4, 2, 1],
			[5, 2, 1],
			[6, 3, 1],
			[7, 4, 2],
			[8, 6, 3],
			[9, 7, 6],
			[10, 8, 7],
			[11, 10, 9],
		],
		An = [0.5, 0.6, 0.7, 0.8, 0.9, 1, 1.2, 1.44, 1.728, 2.074, 2.488],
		Nn = function (e, t) {
			return t.size < 2 ? e : zs[e - 1][t.size - 1];
		};
	class bt {
		constructor(e) {
			(this.style = void 0),
				(this.color = void 0),
				(this.size = void 0),
				(this.textSize = void 0),
				(this.phantom = void 0),
				(this.font = void 0),
				(this.fontFamily = void 0),
				(this.fontWeight = void 0),
				(this.fontShape = void 0),
				(this.sizeMultiplier = void 0),
				(this.maxSize = void 0),
				(this.minRuleThickness = void 0),
				(this._fontMetrics = void 0),
				(this.style = e.style),
				(this.color = e.color),
				(this.size = e.size || bt.BASESIZE),
				(this.textSize = e.textSize || this.size),
				(this.phantom = !!e.phantom),
				(this.font = e.font || ""),
				(this.fontFamily = e.fontFamily || ""),
				(this.fontWeight = e.fontWeight || ""),
				(this.fontShape = e.fontShape || ""),
				(this.sizeMultiplier = An[this.size - 1]),
				(this.maxSize = e.maxSize),
				(this.minRuleThickness = e.minRuleThickness),
				(this._fontMetrics = void 0);
		}
		extend(e) {
			var t = {
				style: this.style,
				size: this.size,
				textSize: this.textSize,
				color: this.color,
				phantom: this.phantom,
				font: this.font,
				fontFamily: this.fontFamily,
				fontWeight: this.fontWeight,
				fontShape: this.fontShape,
				maxSize: this.maxSize,
				minRuleThickness: this.minRuleThickness,
			};
			for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
			return new bt(t);
		}
		havingStyle(e) {
			return this.style === e ? this : this.extend({ style: e, size: Nn(this.textSize, e) });
		}
		havingCrampedStyle() {
			return this.havingStyle(this.style.cramp());
		}
		havingSize(e) {
			return this.size === e && this.textSize === e
				? this
				: this.extend({
						style: this.style.text(),
						size: e,
						textSize: e,
						sizeMultiplier: An[e - 1],
					});
		}
		havingBaseStyle(e) {
			e = e || this.style.text();
			var t = Nn(bt.BASESIZE, e);
			return this.size === t && this.textSize === bt.BASESIZE && this.style === e
				? this
				: this.extend({ style: e, size: t });
		}
		havingBaseSizing() {
			var e;
			switch (this.style.id) {
				case 4:
				case 5:
					e = 3;
					break;
				case 6:
				case 7:
					e = 1;
					break;
				default:
					e = 6;
			}
			return this.extend({ style: this.style.text(), size: e });
		}
		withColor(e) {
			return this.extend({ color: e });
		}
		withPhantom() {
			return this.extend({ phantom: !0 });
		}
		withFont(e) {
			return this.extend({ font: e });
		}
		withTextFontFamily(e) {
			return this.extend({ fontFamily: e, font: "" });
		}
		withTextFontWeight(e) {
			return this.extend({ fontWeight: e, font: "" });
		}
		withTextFontShape(e) {
			return this.extend({ fontShape: e, font: "" });
		}
		sizingClasses(e) {
			return e.size !== this.size ? ["sizing", "reset-size" + e.size, "size" + this.size] : [];
		}
		baseSizingClasses() {
			return this.size !== bt.BASESIZE
				? ["sizing", "reset-size" + this.size, "size" + bt.BASESIZE]
				: [];
		}
		fontMetrics() {
			return this._fontMetrics || (this._fontMetrics = Os(this.size)), this._fontMetrics;
		}
		getColor() {
			return this.phantom ? "transparent" : this.color;
		}
	}
	bt.BASESIZE = 6;
	var b0 = {
			pt: 1,
			mm: 7227 / 2540,
			cm: 7227 / 254,
			in: 72.27,
			bp: 803 / 800,
			pc: 12,
			dd: 1238 / 1157,
			cc: 14856 / 1157,
			nd: 685 / 642,
			nc: 1370 / 107,
			sp: 1 / 65536,
			px: 803 / 800,
		},
		Cs = { ex: !0, em: !0, mu: !0 },
		On = function (e) {
			return typeof e != "string" && (e = e.unit), e in b0 || e in Cs || e === "ex";
		},
		ke = function (e, t) {
			var n;
			if (e.unit in b0) n = b0[e.unit] / t.fontMetrics().ptPerEm / t.sizeMultiplier;
			else if (e.unit === "mu") n = t.fontMetrics().cssEmPerMu;
			else {
				var a;
				if ((t.style.isTight() ? (a = t.havingStyle(t.style.text())) : (a = t), e.unit === "ex"))
					n = a.fontMetrics().xHeight;
				else if (e.unit === "em") n = a.fontMetrics().quad;
				else throw new A("Invalid unit: '" + e.unit + "'");
				a !== t && (n *= a.sizeMultiplier / t.sizeMultiplier);
			}
			return Math.min(e.number * n, t.maxSize);
		},
		R = function (e) {
			return +e.toFixed(4) + "em";
		},
		Mt = function (e) {
			return e.filter((t) => t).join(" ");
		},
		zn = function (e, t, n) {
			if (
				((this.classes = e || []),
				(this.attributes = {}),
				(this.height = 0),
				(this.depth = 0),
				(this.maxFontSize = 0),
				(this.style = n || {}),
				t)
			) {
				t.style.isTight() && this.classes.push("mtight");
				var a = t.getColor();
				a && (this.style.color = a);
			}
		},
		Cn = function (e) {
			var t = document.createElement(e);
			t.className = Mt(this.classes);
			for (var n in this.style) this.style.hasOwnProperty(n) && (t.style[n] = this.style[n]);
			for (var a in this.attributes)
				this.attributes.hasOwnProperty(a) && t.setAttribute(a, this.attributes[a]);
			for (var i = 0; i < this.children.length; i++) t.appendChild(this.children[i].toNode());
			return t;
		},
		Rs = /[\s"'>/=\x00-\x1f]/,
		Rn = function (e) {
			var t = "<" + e;
			this.classes.length && (t += ' class="' + V.escape(Mt(this.classes)) + '"');
			var n = "";
			for (var a in this.style)
				this.style.hasOwnProperty(a) && (n += V.hyphenate(a) + ":" + this.style[a] + ";");
			n && (t += ' style="' + V.escape(n) + '"');
			for (var i in this.attributes)
				if (this.attributes.hasOwnProperty(i)) {
					if (Rs.test(i)) throw new A("Invalid attribute name '" + i + "'");
					t += " " + i + '="' + V.escape(this.attributes[i]) + '"';
				}
			t += ">";
			for (var s = 0; s < this.children.length; s++) t += this.children[s].toMarkup();
			return (t += "</" + e + ">"), t;
		};
	class ar {
		constructor(e, t, n, a) {
			(this.children = void 0),
				(this.attributes = void 0),
				(this.classes = void 0),
				(this.height = void 0),
				(this.depth = void 0),
				(this.width = void 0),
				(this.maxFontSize = void 0),
				(this.style = void 0),
				zn.call(this, e, n, a),
				(this.children = t || []);
		}
		setAttribute(e, t) {
			this.attributes[e] = t;
		}
		hasClass(e) {
			return V.contains(this.classes, e);
		}
		toNode() {
			return Cn.call(this, "span");
		}
		toMarkup() {
			return Rn.call(this, "span");
		}
	}
	class v0 {
		constructor(e, t, n, a) {
			(this.children = void 0),
				(this.attributes = void 0),
				(this.classes = void 0),
				(this.height = void 0),
				(this.depth = void 0),
				(this.maxFontSize = void 0),
				(this.style = void 0),
				zn.call(this, t, a),
				(this.children = n || []),
				this.setAttribute("href", e);
		}
		setAttribute(e, t) {
			this.attributes[e] = t;
		}
		hasClass(e) {
			return V.contains(this.classes, e);
		}
		toNode() {
			return Cn.call(this, "a");
		}
		toMarkup() {
			return Rn.call(this, "a");
		}
	}
	class Is {
		constructor(e, t, n) {
			(this.src = void 0),
				(this.alt = void 0),
				(this.classes = void 0),
				(this.height = void 0),
				(this.depth = void 0),
				(this.maxFontSize = void 0),
				(this.style = void 0),
				(this.alt = t),
				(this.src = e),
				(this.classes = ["mord"]),
				(this.style = n);
		}
		hasClass(e) {
			return V.contains(this.classes, e);
		}
		toNode() {
			var e = document.createElement("img");
			(e.src = this.src), (e.alt = this.alt), (e.className = "mord");
			for (var t in this.style) this.style.hasOwnProperty(t) && (e.style[t] = this.style[t]);
			return e;
		}
		toMarkup() {
			var e = '<img src="' + V.escape(this.src) + '"' + (' alt="' + V.escape(this.alt) + '"'),
				t = "";
			for (var n in this.style)
				this.style.hasOwnProperty(n) && (t += V.hyphenate(n) + ":" + this.style[n] + ";");
			return t && (e += ' style="' + V.escape(t) + '"'), (e += "'/>"), e;
		}
	}
	var Ds = { î: "ı̂", ï: "ı̈", í: "ı́", ì: "ı̀" };
	class tt {
		constructor(e, t, n, a, i, s, l, u) {
			(this.text = void 0),
				(this.height = void 0),
				(this.depth = void 0),
				(this.italic = void 0),
				(this.skew = void 0),
				(this.width = void 0),
				(this.maxFontSize = void 0),
				(this.classes = void 0),
				(this.style = void 0),
				(this.text = e),
				(this.height = t || 0),
				(this.depth = n || 0),
				(this.italic = a || 0),
				(this.skew = i || 0),
				(this.width = s || 0),
				(this.classes = l || []),
				(this.style = u || {}),
				(this.maxFontSize = 0);
			var d = vs(this.text.charCodeAt(0));
			d && this.classes.push(d + "_fallback"),
				/[îïíì]/.test(this.text) && (this.text = Ds[this.text]);
		}
		hasClass(e) {
			return V.contains(this.classes, e);
		}
		toNode() {
			var e = document.createTextNode(this.text),
				t = null;
			this.italic > 0 &&
				((t = document.createElement("span")), (t.style.marginRight = R(this.italic))),
				this.classes.length > 0 &&
					((t = t || document.createElement("span")), (t.className = Mt(this.classes)));
			for (var n in this.style)
				this.style.hasOwnProperty(n) &&
					((t = t || document.createElement("span")), (t.style[n] = this.style[n]));
			return t ? (t.appendChild(e), t) : e;
		}
		toMarkup() {
			var e = !1,
				t = "<span";
			this.classes.length &&
				((e = !0), (t += ' class="'), (t += V.escape(Mt(this.classes))), (t += '"'));
			var n = "";
			this.italic > 0 && (n += "margin-right:" + this.italic + "em;");
			for (var a in this.style)
				this.style.hasOwnProperty(a) && (n += V.hyphenate(a) + ":" + this.style[a] + ";");
			n && ((e = !0), (t += ' style="' + V.escape(n) + '"'));
			var i = V.escape(this.text);
			return e ? ((t += ">"), (t += i), (t += "</span>"), t) : i;
		}
	}
	class vt {
		constructor(e, t) {
			(this.children = void 0),
				(this.attributes = void 0),
				(this.children = e || []),
				(this.attributes = t || {});
		}
		toNode() {
			var e = "http://www.w3.org/2000/svg",
				t = document.createElementNS(e, "svg");
			for (var n in this.attributes)
				Object.prototype.hasOwnProperty.call(this.attributes, n) &&
					t.setAttribute(n, this.attributes[n]);
			for (var a = 0; a < this.children.length; a++) t.appendChild(this.children[a].toNode());
			return t;
		}
		toMarkup() {
			var e = '<svg xmlns="http://www.w3.org/2000/svg"';
			for (var t in this.attributes)
				Object.prototype.hasOwnProperty.call(this.attributes, t) &&
					(e += " " + t + '="' + V.escape(this.attributes[t]) + '"');
			e += ">";
			for (var n = 0; n < this.children.length; n++) e += this.children[n].toMarkup();
			return (e += "</svg>"), e;
		}
	}
	class At {
		constructor(e, t) {
			(this.pathName = void 0),
				(this.alternate = void 0),
				(this.pathName = e),
				(this.alternate = t);
		}
		toNode() {
			var e = "http://www.w3.org/2000/svg",
				t = document.createElementNS(e, "path");
			return (
				this.alternate
					? t.setAttribute("d", this.alternate)
					: t.setAttribute("d", Tn[this.pathName]),
				t
			);
		}
		toMarkup() {
			return this.alternate
				? '<path d="' + V.escape(this.alternate) + '"/>'
				: '<path d="' + V.escape(Tn[this.pathName]) + '"/>';
		}
	}
	class y0 {
		constructor(e) {
			(this.attributes = void 0), (this.attributes = e || {});
		}
		toNode() {
			var e = "http://www.w3.org/2000/svg",
				t = document.createElementNS(e, "line");
			for (var n in this.attributes)
				Object.prototype.hasOwnProperty.call(this.attributes, n) &&
					t.setAttribute(n, this.attributes[n]);
			return t;
		}
		toMarkup() {
			var e = "<line";
			for (var t in this.attributes)
				Object.prototype.hasOwnProperty.call(this.attributes, t) &&
					(e += " " + t + '="' + V.escape(this.attributes[t]) + '"');
			return (e += "/>"), e;
		}
	}
	function In(r) {
		if (r instanceof tt) return r;
		throw new Error("Expected symbolNode but got " + String(r) + ".");
	}
	function Bs(r) {
		if (r instanceof ar) return r;
		throw new Error("Expected span<HtmlDomNode> but got " + String(r) + ".");
	}
	var Ls = { bin: 1, close: 1, inner: 1, open: 1, punct: 1, rel: 1 },
		$s = { "accent-token": 1, mathord: 1, "op-token": 1, spacing: 1, textord: 1 },
		fe = { math: {}, text: {} };
	function o(r, e, t, n, a, i) {
		(fe[r][a] = { font: e, group: t, replace: n }), i && n && (fe[r][n] = fe[r][a]);
	}
	var c = "math",
		N = "text",
		h = "main",
		g = "ams",
		xe = "accent-token",
		F = "bin",
		Ge = "close",
		Xt = "inner",
		X = "mathord",
		ze = "op-token",
		Ze = "open",
		Mr = "punct",
		b = "rel",
		yt = "spacing",
		w = "textord";
	o(c, h, b, "≡", "\\equiv", !0),
		o(c, h, b, "≺", "\\prec", !0),
		o(c, h, b, "≻", "\\succ", !0),
		o(c, h, b, "∼", "\\sim", !0),
		o(c, h, b, "⊥", "\\perp"),
		o(c, h, b, "⪯", "\\preceq", !0),
		o(c, h, b, "⪰", "\\succeq", !0),
		o(c, h, b, "≃", "\\simeq", !0),
		o(c, h, b, "∣", "\\mid", !0),
		o(c, h, b, "≪", "\\ll", !0),
		o(c, h, b, "≫", "\\gg", !0),
		o(c, h, b, "≍", "\\asymp", !0),
		o(c, h, b, "∥", "\\parallel"),
		o(c, h, b, "⋈", "\\bowtie", !0),
		o(c, h, b, "⌣", "\\smile", !0),
		o(c, h, b, "⊑", "\\sqsubseteq", !0),
		o(c, h, b, "⊒", "\\sqsupseteq", !0),
		o(c, h, b, "≐", "\\doteq", !0),
		o(c, h, b, "⌢", "\\frown", !0),
		o(c, h, b, "∋", "\\ni", !0),
		o(c, h, b, "∝", "\\propto", !0),
		o(c, h, b, "⊢", "\\vdash", !0),
		o(c, h, b, "⊣", "\\dashv", !0),
		o(c, h, b, "∋", "\\owns"),
		o(c, h, Mr, ".", "\\ldotp"),
		o(c, h, Mr, "⋅", "\\cdotp"),
		o(c, h, w, "#", "\\#"),
		o(N, h, w, "#", "\\#"),
		o(c, h, w, "&", "\\&"),
		o(N, h, w, "&", "\\&"),
		o(c, h, w, "ℵ", "\\aleph", !0),
		o(c, h, w, "∀", "\\forall", !0),
		o(c, h, w, "ℏ", "\\hbar", !0),
		o(c, h, w, "∃", "\\exists", !0),
		o(c, h, w, "∇", "\\nabla", !0),
		o(c, h, w, "♭", "\\flat", !0),
		o(c, h, w, "ℓ", "\\ell", !0),
		o(c, h, w, "♮", "\\natural", !0),
		o(c, h, w, "♣", "\\clubsuit", !0),
		o(c, h, w, "℘", "\\wp", !0),
		o(c, h, w, "♯", "\\sharp", !0),
		o(c, h, w, "♢", "\\diamondsuit", !0),
		o(c, h, w, "ℜ", "\\Re", !0),
		o(c, h, w, "♡", "\\heartsuit", !0),
		o(c, h, w, "ℑ", "\\Im", !0),
		o(c, h, w, "♠", "\\spadesuit", !0),
		o(c, h, w, "§", "\\S", !0),
		o(N, h, w, "§", "\\S"),
		o(c, h, w, "¶", "\\P", !0),
		o(N, h, w, "¶", "\\P"),
		o(c, h, w, "†", "\\dag"),
		o(N, h, w, "†", "\\dag"),
		o(N, h, w, "†", "\\textdagger"),
		o(c, h, w, "‡", "\\ddag"),
		o(N, h, w, "‡", "\\ddag"),
		o(N, h, w, "‡", "\\textdaggerdbl"),
		o(c, h, Ge, "⎱", "\\rmoustache", !0),
		o(c, h, Ze, "⎰", "\\lmoustache", !0),
		o(c, h, Ge, "⟯", "\\rgroup", !0),
		o(c, h, Ze, "⟮", "\\lgroup", !0),
		o(c, h, F, "∓", "\\mp", !0),
		o(c, h, F, "⊖", "\\ominus", !0),
		o(c, h, F, "⊎", "\\uplus", !0),
		o(c, h, F, "⊓", "\\sqcap", !0),
		o(c, h, F, "∗", "\\ast"),
		o(c, h, F, "⊔", "\\sqcup", !0),
		o(c, h, F, "◯", "\\bigcirc", !0),
		o(c, h, F, "∙", "\\bullet", !0),
		o(c, h, F, "‡", "\\ddagger"),
		o(c, h, F, "≀", "\\wr", !0),
		o(c, h, F, "⨿", "\\amalg"),
		o(c, h, F, "&", "\\And"),
		o(c, h, b, "⟵", "\\longleftarrow", !0),
		o(c, h, b, "⇐", "\\Leftarrow", !0),
		o(c, h, b, "⟸", "\\Longleftarrow", !0),
		o(c, h, b, "⟶", "\\longrightarrow", !0),
		o(c, h, b, "⇒", "\\Rightarrow", !0),
		o(c, h, b, "⟹", "\\Longrightarrow", !0),
		o(c, h, b, "↔", "\\leftrightarrow", !0),
		o(c, h, b, "⟷", "\\longleftrightarrow", !0),
		o(c, h, b, "⇔", "\\Leftrightarrow", !0),
		o(c, h, b, "⟺", "\\Longleftrightarrow", !0),
		o(c, h, b, "↦", "\\mapsto", !0),
		o(c, h, b, "⟼", "\\longmapsto", !0),
		o(c, h, b, "↗", "\\nearrow", !0),
		o(c, h, b, "↩", "\\hookleftarrow", !0),
		o(c, h, b, "↪", "\\hookrightarrow", !0),
		o(c, h, b, "↘", "\\searrow", !0),
		o(c, h, b, "↼", "\\leftharpoonup", !0),
		o(c, h, b, "⇀", "\\rightharpoonup", !0),
		o(c, h, b, "↙", "\\swarrow", !0),
		o(c, h, b, "↽", "\\leftharpoondown", !0),
		o(c, h, b, "⇁", "\\rightharpoondown", !0),
		o(c, h, b, "↖", "\\nwarrow", !0),
		o(c, h, b, "⇌", "\\rightleftharpoons", !0),
		o(c, g, b, "≮", "\\nless", !0),
		o(c, g, b, "", "\\@nleqslant"),
		o(c, g, b, "", "\\@nleqq"),
		o(c, g, b, "⪇", "\\lneq", !0),
		o(c, g, b, "≨", "\\lneqq", !0),
		o(c, g, b, "", "\\@lvertneqq"),
		o(c, g, b, "⋦", "\\lnsim", !0),
		o(c, g, b, "⪉", "\\lnapprox", !0),
		o(c, g, b, "⊀", "\\nprec", !0),
		o(c, g, b, "⋠", "\\npreceq", !0),
		o(c, g, b, "⋨", "\\precnsim", !0),
		o(c, g, b, "⪹", "\\precnapprox", !0),
		o(c, g, b, "≁", "\\nsim", !0),
		o(c, g, b, "", "\\@nshortmid"),
		o(c, g, b, "∤", "\\nmid", !0),
		o(c, g, b, "⊬", "\\nvdash", !0),
		o(c, g, b, "⊭", "\\nvDash", !0),
		o(c, g, b, "⋪", "\\ntriangleleft"),
		o(c, g, b, "⋬", "\\ntrianglelefteq", !0),
		o(c, g, b, "⊊", "\\subsetneq", !0),
		o(c, g, b, "", "\\@varsubsetneq"),
		o(c, g, b, "⫋", "\\subsetneqq", !0),
		o(c, g, b, "", "\\@varsubsetneqq"),
		o(c, g, b, "≯", "\\ngtr", !0),
		o(c, g, b, "", "\\@ngeqslant"),
		o(c, g, b, "", "\\@ngeqq"),
		o(c, g, b, "⪈", "\\gneq", !0),
		o(c, g, b, "≩", "\\gneqq", !0),
		o(c, g, b, "", "\\@gvertneqq"),
		o(c, g, b, "⋧", "\\gnsim", !0),
		o(c, g, b, "⪊", "\\gnapprox", !0),
		o(c, g, b, "⊁", "\\nsucc", !0),
		o(c, g, b, "⋡", "\\nsucceq", !0),
		o(c, g, b, "⋩", "\\succnsim", !0),
		o(c, g, b, "⪺", "\\succnapprox", !0),
		o(c, g, b, "≆", "\\ncong", !0),
		o(c, g, b, "", "\\@nshortparallel"),
		o(c, g, b, "∦", "\\nparallel", !0),
		o(c, g, b, "⊯", "\\nVDash", !0),
		o(c, g, b, "⋫", "\\ntriangleright"),
		o(c, g, b, "⋭", "\\ntrianglerighteq", !0),
		o(c, g, b, "", "\\@nsupseteqq"),
		o(c, g, b, "⊋", "\\supsetneq", !0),
		o(c, g, b, "", "\\@varsupsetneq"),
		o(c, g, b, "⫌", "\\supsetneqq", !0),
		o(c, g, b, "", "\\@varsupsetneqq"),
		o(c, g, b, "⊮", "\\nVdash", !0),
		o(c, g, b, "⪵", "\\precneqq", !0),
		o(c, g, b, "⪶", "\\succneqq", !0),
		o(c, g, b, "", "\\@nsubseteqq"),
		o(c, g, F, "⊴", "\\unlhd"),
		o(c, g, F, "⊵", "\\unrhd"),
		o(c, g, b, "↚", "\\nleftarrow", !0),
		o(c, g, b, "↛", "\\nrightarrow", !0),
		o(c, g, b, "⇍", "\\nLeftarrow", !0),
		o(c, g, b, "⇏", "\\nRightarrow", !0),
		o(c, g, b, "↮", "\\nleftrightarrow", !0),
		o(c, g, b, "⇎", "\\nLeftrightarrow", !0),
		o(c, g, b, "△", "\\vartriangle"),
		o(c, g, w, "ℏ", "\\hslash"),
		o(c, g, w, "▽", "\\triangledown"),
		o(c, g, w, "◊", "\\lozenge"),
		o(c, g, w, "Ⓢ", "\\circledS"),
		o(c, g, w, "®", "\\circledR"),
		o(N, g, w, "®", "\\circledR"),
		o(c, g, w, "∡", "\\measuredangle", !0),
		o(c, g, w, "∄", "\\nexists"),
		o(c, g, w, "℧", "\\mho"),
		o(c, g, w, "Ⅎ", "\\Finv", !0),
		o(c, g, w, "⅁", "\\Game", !0),
		o(c, g, w, "‵", "\\backprime"),
		o(c, g, w, "▲", "\\blacktriangle"),
		o(c, g, w, "▼", "\\blacktriangledown"),
		o(c, g, w, "■", "\\blacksquare"),
		o(c, g, w, "⧫", "\\blacklozenge"),
		o(c, g, w, "★", "\\bigstar"),
		o(c, g, w, "∢", "\\sphericalangle", !0),
		o(c, g, w, "∁", "\\complement", !0),
		o(c, g, w, "ð", "\\eth", !0),
		o(N, h, w, "ð", "ð"),
		o(c, g, w, "╱", "\\diagup"),
		o(c, g, w, "╲", "\\diagdown"),
		o(c, g, w, "□", "\\square"),
		o(c, g, w, "□", "\\Box"),
		o(c, g, w, "◊", "\\Diamond"),
		o(c, g, w, "¥", "\\yen", !0),
		o(N, g, w, "¥", "\\yen", !0),
		o(c, g, w, "✓", "\\checkmark", !0),
		o(N, g, w, "✓", "\\checkmark"),
		o(c, g, w, "ℶ", "\\beth", !0),
		o(c, g, w, "ℸ", "\\daleth", !0),
		o(c, g, w, "ℷ", "\\gimel", !0),
		o(c, g, w, "ϝ", "\\digamma", !0),
		o(c, g, w, "ϰ", "\\varkappa"),
		o(c, g, Ze, "┌", "\\@ulcorner", !0),
		o(c, g, Ge, "┐", "\\@urcorner", !0),
		o(c, g, Ze, "└", "\\@llcorner", !0),
		o(c, g, Ge, "┘", "\\@lrcorner", !0),
		o(c, g, b, "≦", "\\leqq", !0),
		o(c, g, b, "⩽", "\\leqslant", !0),
		o(c, g, b, "⪕", "\\eqslantless", !0),
		o(c, g, b, "≲", "\\lesssim", !0),
		o(c, g, b, "⪅", "\\lessapprox", !0),
		o(c, g, b, "≊", "\\approxeq", !0),
		o(c, g, F, "⋖", "\\lessdot"),
		o(c, g, b, "⋘", "\\lll", !0),
		o(c, g, b, "≶", "\\lessgtr", !0),
		o(c, g, b, "⋚", "\\lesseqgtr", !0),
		o(c, g, b, "⪋", "\\lesseqqgtr", !0),
		o(c, g, b, "≑", "\\doteqdot"),
		o(c, g, b, "≓", "\\risingdotseq", !0),
		o(c, g, b, "≒", "\\fallingdotseq", !0),
		o(c, g, b, "∽", "\\backsim", !0),
		o(c, g, b, "⋍", "\\backsimeq", !0),
		o(c, g, b, "⫅", "\\subseteqq", !0),
		o(c, g, b, "⋐", "\\Subset", !0),
		o(c, g, b, "⊏", "\\sqsubset", !0),
		o(c, g, b, "≼", "\\preccurlyeq", !0),
		o(c, g, b, "⋞", "\\curlyeqprec", !0),
		o(c, g, b, "≾", "\\precsim", !0),
		o(c, g, b, "⪷", "\\precapprox", !0),
		o(c, g, b, "⊲", "\\vartriangleleft"),
		o(c, g, b, "⊴", "\\trianglelefteq"),
		o(c, g, b, "⊨", "\\vDash", !0),
		o(c, g, b, "⊪", "\\Vvdash", !0),
		o(c, g, b, "⌣", "\\smallsmile"),
		o(c, g, b, "⌢", "\\smallfrown"),
		o(c, g, b, "≏", "\\bumpeq", !0),
		o(c, g, b, "≎", "\\Bumpeq", !0),
		o(c, g, b, "≧", "\\geqq", !0),
		o(c, g, b, "⩾", "\\geqslant", !0),
		o(c, g, b, "⪖", "\\eqslantgtr", !0),
		o(c, g, b, "≳", "\\gtrsim", !0),
		o(c, g, b, "⪆", "\\gtrapprox", !0),
		o(c, g, F, "⋗", "\\gtrdot"),
		o(c, g, b, "⋙", "\\ggg", !0),
		o(c, g, b, "≷", "\\gtrless", !0),
		o(c, g, b, "⋛", "\\gtreqless", !0),
		o(c, g, b, "⪌", "\\gtreqqless", !0),
		o(c, g, b, "≖", "\\eqcirc", !0),
		o(c, g, b, "≗", "\\circeq", !0),
		o(c, g, b, "≜", "\\triangleq", !0),
		o(c, g, b, "∼", "\\thicksim"),
		o(c, g, b, "≈", "\\thickapprox"),
		o(c, g, b, "⫆", "\\supseteqq", !0),
		o(c, g, b, "⋑", "\\Supset", !0),
		o(c, g, b, "⊐", "\\sqsupset", !0),
		o(c, g, b, "≽", "\\succcurlyeq", !0),
		o(c, g, b, "⋟", "\\curlyeqsucc", !0),
		o(c, g, b, "≿", "\\succsim", !0),
		o(c, g, b, "⪸", "\\succapprox", !0),
		o(c, g, b, "⊳", "\\vartriangleright"),
		o(c, g, b, "⊵", "\\trianglerighteq"),
		o(c, g, b, "⊩", "\\Vdash", !0),
		o(c, g, b, "∣", "\\shortmid"),
		o(c, g, b, "∥", "\\shortparallel"),
		o(c, g, b, "≬", "\\between", !0),
		o(c, g, b, "⋔", "\\pitchfork", !0),
		o(c, g, b, "∝", "\\varpropto"),
		o(c, g, b, "◀", "\\blacktriangleleft"),
		o(c, g, b, "∴", "\\therefore", !0),
		o(c, g, b, "∍", "\\backepsilon"),
		o(c, g, b, "▶", "\\blacktriangleright"),
		o(c, g, b, "∵", "\\because", !0),
		o(c, g, b, "⋘", "\\llless"),
		o(c, g, b, "⋙", "\\gggtr"),
		o(c, g, F, "⊲", "\\lhd"),
		o(c, g, F, "⊳", "\\rhd"),
		o(c, g, b, "≂", "\\eqsim", !0),
		o(c, h, b, "⋈", "\\Join"),
		o(c, g, b, "≑", "\\Doteq", !0),
		o(c, g, F, "∔", "\\dotplus", !0),
		o(c, g, F, "∖", "\\smallsetminus"),
		o(c, g, F, "⋒", "\\Cap", !0),
		o(c, g, F, "⋓", "\\Cup", !0),
		o(c, g, F, "⩞", "\\doublebarwedge", !0),
		o(c, g, F, "⊟", "\\boxminus", !0),
		o(c, g, F, "⊞", "\\boxplus", !0),
		o(c, g, F, "⋇", "\\divideontimes", !0),
		o(c, g, F, "⋉", "\\ltimes", !0),
		o(c, g, F, "⋊", "\\rtimes", !0),
		o(c, g, F, "⋋", "\\leftthreetimes", !0),
		o(c, g, F, "⋌", "\\rightthreetimes", !0),
		o(c, g, F, "⋏", "\\curlywedge", !0),
		o(c, g, F, "⋎", "\\curlyvee", !0),
		o(c, g, F, "⊝", "\\circleddash", !0),
		o(c, g, F, "⊛", "\\circledast", !0),
		o(c, g, F, "⋅", "\\centerdot"),
		o(c, g, F, "⊺", "\\intercal", !0),
		o(c, g, F, "⋒", "\\doublecap"),
		o(c, g, F, "⋓", "\\doublecup"),
		o(c, g, F, "⊠", "\\boxtimes", !0),
		o(c, g, b, "⇢", "\\dashrightarrow", !0),
		o(c, g, b, "⇠", "\\dashleftarrow", !0),
		o(c, g, b, "⇇", "\\leftleftarrows", !0),
		o(c, g, b, "⇆", "\\leftrightarrows", !0),
		o(c, g, b, "⇚", "\\Lleftarrow", !0),
		o(c, g, b, "↞", "\\twoheadleftarrow", !0),
		o(c, g, b, "↢", "\\leftarrowtail", !0),
		o(c, g, b, "↫", "\\looparrowleft", !0),
		o(c, g, b, "⇋", "\\leftrightharpoons", !0),
		o(c, g, b, "↶", "\\curvearrowleft", !0),
		o(c, g, b, "↺", "\\circlearrowleft", !0),
		o(c, g, b, "↰", "\\Lsh", !0),
		o(c, g, b, "⇈", "\\upuparrows", !0),
		o(c, g, b, "↿", "\\upharpoonleft", !0),
		o(c, g, b, "⇃", "\\downharpoonleft", !0),
		o(c, h, b, "⊶", "\\origof", !0),
		o(c, h, b, "⊷", "\\imageof", !0),
		o(c, g, b, "⊸", "\\multimap", !0),
		o(c, g, b, "↭", "\\leftrightsquigarrow", !0),
		o(c, g, b, "⇉", "\\rightrightarrows", !0),
		o(c, g, b, "⇄", "\\rightleftarrows", !0),
		o(c, g, b, "↠", "\\twoheadrightarrow", !0),
		o(c, g, b, "↣", "\\rightarrowtail", !0),
		o(c, g, b, "↬", "\\looparrowright", !0),
		o(c, g, b, "↷", "\\curvearrowright", !0),
		o(c, g, b, "↻", "\\circlearrowright", !0),
		o(c, g, b, "↱", "\\Rsh", !0),
		o(c, g, b, "⇊", "\\downdownarrows", !0),
		o(c, g, b, "↾", "\\upharpoonright", !0),
		o(c, g, b, "⇂", "\\downharpoonright", !0),
		o(c, g, b, "⇝", "\\rightsquigarrow", !0),
		o(c, g, b, "⇝", "\\leadsto"),
		o(c, g, b, "⇛", "\\Rrightarrow", !0),
		o(c, g, b, "↾", "\\restriction"),
		o(c, h, w, "‘", "`"),
		o(c, h, w, "$", "\\$"),
		o(N, h, w, "$", "\\$"),
		o(N, h, w, "$", "\\textdollar"),
		o(c, h, w, "%", "\\%"),
		o(N, h, w, "%", "\\%"),
		o(c, h, w, "_", "\\_"),
		o(N, h, w, "_", "\\_"),
		o(N, h, w, "_", "\\textunderscore"),
		o(c, h, w, "∠", "\\angle", !0),
		o(c, h, w, "∞", "\\infty", !0),
		o(c, h, w, "′", "\\prime"),
		o(c, h, w, "△", "\\triangle"),
		o(c, h, w, "Γ", "\\Gamma", !0),
		o(c, h, w, "Δ", "\\Delta", !0),
		o(c, h, w, "Θ", "\\Theta", !0),
		o(c, h, w, "Λ", "\\Lambda", !0),
		o(c, h, w, "Ξ", "\\Xi", !0),
		o(c, h, w, "Π", "\\Pi", !0),
		o(c, h, w, "Σ", "\\Sigma", !0),
		o(c, h, w, "Υ", "\\Upsilon", !0),
		o(c, h, w, "Φ", "\\Phi", !0),
		o(c, h, w, "Ψ", "\\Psi", !0),
		o(c, h, w, "Ω", "\\Omega", !0),
		o(c, h, w, "A", "Α"),
		o(c, h, w, "B", "Β"),
		o(c, h, w, "E", "Ε"),
		o(c, h, w, "Z", "Ζ"),
		o(c, h, w, "H", "Η"),
		o(c, h, w, "I", "Ι"),
		o(c, h, w, "K", "Κ"),
		o(c, h, w, "M", "Μ"),
		o(c, h, w, "N", "Ν"),
		o(c, h, w, "O", "Ο"),
		o(c, h, w, "P", "Ρ"),
		o(c, h, w, "T", "Τ"),
		o(c, h, w, "X", "Χ"),
		o(c, h, w, "¬", "\\neg", !0),
		o(c, h, w, "¬", "\\lnot"),
		o(c, h, w, "⊤", "\\top"),
		o(c, h, w, "⊥", "\\bot"),
		o(c, h, w, "∅", "\\emptyset"),
		o(c, g, w, "∅", "\\varnothing"),
		o(c, h, X, "α", "\\alpha", !0),
		o(c, h, X, "β", "\\beta", !0),
		o(c, h, X, "γ", "\\gamma", !0),
		o(c, h, X, "δ", "\\delta", !0),
		o(c, h, X, "ϵ", "\\epsilon", !0),
		o(c, h, X, "ζ", "\\zeta", !0),
		o(c, h, X, "η", "\\eta", !0),
		o(c, h, X, "θ", "\\theta", !0),
		o(c, h, X, "ι", "\\iota", !0),
		o(c, h, X, "κ", "\\kappa", !0),
		o(c, h, X, "λ", "\\lambda", !0),
		o(c, h, X, "μ", "\\mu", !0),
		o(c, h, X, "ν", "\\nu", !0),
		o(c, h, X, "ξ", "\\xi", !0),
		o(c, h, X, "ο", "\\omicron", !0),
		o(c, h, X, "π", "\\pi", !0),
		o(c, h, X, "ρ", "\\rho", !0),
		o(c, h, X, "σ", "\\sigma", !0),
		o(c, h, X, "τ", "\\tau", !0),
		o(c, h, X, "υ", "\\upsilon", !0),
		o(c, h, X, "ϕ", "\\phi", !0),
		o(c, h, X, "χ", "\\chi", !0),
		o(c, h, X, "ψ", "\\psi", !0),
		o(c, h, X, "ω", "\\omega", !0),
		o(c, h, X, "ε", "\\varepsilon", !0),
		o(c, h, X, "ϑ", "\\vartheta", !0),
		o(c, h, X, "ϖ", "\\varpi", !0),
		o(c, h, X, "ϱ", "\\varrho", !0),
		o(c, h, X, "ς", "\\varsigma", !0),
		o(c, h, X, "φ", "\\varphi", !0),
		o(c, h, F, "∗", "*", !0),
		o(c, h, F, "+", "+"),
		o(c, h, F, "−", "-", !0),
		o(c, h, F, "⋅", "\\cdot", !0),
		o(c, h, F, "∘", "\\circ", !0),
		o(c, h, F, "÷", "\\div", !0),
		o(c, h, F, "±", "\\pm", !0),
		o(c, h, F, "×", "\\times", !0),
		o(c, h, F, "∩", "\\cap", !0),
		o(c, h, F, "∪", "\\cup", !0),
		o(c, h, F, "∖", "\\setminus", !0),
		o(c, h, F, "∧", "\\land"),
		o(c, h, F, "∨", "\\lor"),
		o(c, h, F, "∧", "\\wedge", !0),
		o(c, h, F, "∨", "\\vee", !0),
		o(c, h, w, "√", "\\surd"),
		o(c, h, Ze, "⟨", "\\langle", !0),
		o(c, h, Ze, "∣", "\\lvert"),
		o(c, h, Ze, "∥", "\\lVert"),
		o(c, h, Ge, "?", "?"),
		o(c, h, Ge, "!", "!"),
		o(c, h, Ge, "⟩", "\\rangle", !0),
		o(c, h, Ge, "∣", "\\rvert"),
		o(c, h, Ge, "∥", "\\rVert"),
		o(c, h, b, "=", "="),
		o(c, h, b, ":", ":"),
		o(c, h, b, "≈", "\\approx", !0),
		o(c, h, b, "≅", "\\cong", !0),
		o(c, h, b, "≥", "\\ge"),
		o(c, h, b, "≥", "\\geq", !0),
		o(c, h, b, "←", "\\gets"),
		o(c, h, b, ">", "\\gt", !0),
		o(c, h, b, "∈", "\\in", !0),
		o(c, h, b, "", "\\@not"),
		o(c, h, b, "⊂", "\\subset", !0),
		o(c, h, b, "⊃", "\\supset", !0),
		o(c, h, b, "⊆", "\\subseteq", !0),
		o(c, h, b, "⊇", "\\supseteq", !0),
		o(c, g, b, "⊈", "\\nsubseteq", !0),
		o(c, g, b, "⊉", "\\nsupseteq", !0),
		o(c, h, b, "⊨", "\\models"),
		o(c, h, b, "←", "\\leftarrow", !0),
		o(c, h, b, "≤", "\\le"),
		o(c, h, b, "≤", "\\leq", !0),
		o(c, h, b, "<", "\\lt", !0),
		o(c, h, b, "→", "\\rightarrow", !0),
		o(c, h, b, "→", "\\to"),
		o(c, g, b, "≱", "\\ngeq", !0),
		o(c, g, b, "≰", "\\nleq", !0),
		o(c, h, yt, " ", "\\ "),
		o(c, h, yt, " ", "\\space"),
		o(c, h, yt, " ", "\\nobreakspace"),
		o(N, h, yt, " ", "\\ "),
		o(N, h, yt, " ", " "),
		o(N, h, yt, " ", "\\space"),
		o(N, h, yt, " ", "\\nobreakspace"),
		o(c, h, yt, null, "\\nobreak"),
		o(c, h, yt, null, "\\allowbreak"),
		o(c, h, Mr, ",", ","),
		o(c, h, Mr, ";", ";"),
		o(c, g, F, "⊼", "\\barwedge", !0),
		o(c, g, F, "⊻", "\\veebar", !0),
		o(c, h, F, "⊙", "\\odot", !0),
		o(c, h, F, "⊕", "\\oplus", !0),
		o(c, h, F, "⊗", "\\otimes", !0),
		o(c, h, w, "∂", "\\partial", !0),
		o(c, h, F, "⊘", "\\oslash", !0),
		o(c, g, F, "⊚", "\\circledcirc", !0),
		o(c, g, F, "⊡", "\\boxdot", !0),
		o(c, h, F, "△", "\\bigtriangleup"),
		o(c, h, F, "▽", "\\bigtriangledown"),
		o(c, h, F, "†", "\\dagger"),
		o(c, h, F, "⋄", "\\diamond"),
		o(c, h, F, "⋆", "\\star"),
		o(c, h, F, "◃", "\\triangleleft"),
		o(c, h, F, "▹", "\\triangleright"),
		o(c, h, Ze, "{", "\\{"),
		o(N, h, w, "{", "\\{"),
		o(N, h, w, "{", "\\textbraceleft"),
		o(c, h, Ge, "}", "\\}"),
		o(N, h, w, "}", "\\}"),
		o(N, h, w, "}", "\\textbraceright"),
		o(c, h, Ze, "{", "\\lbrace"),
		o(c, h, Ge, "}", "\\rbrace"),
		o(c, h, Ze, "[", "\\lbrack", !0),
		o(N, h, w, "[", "\\lbrack", !0),
		o(c, h, Ge, "]", "\\rbrack", !0),
		o(N, h, w, "]", "\\rbrack", !0),
		o(c, h, Ze, "(", "\\lparen", !0),
		o(c, h, Ge, ")", "\\rparen", !0),
		o(N, h, w, "<", "\\textless", !0),
		o(N, h, w, ">", "\\textgreater", !0),
		o(c, h, Ze, "⌊", "\\lfloor", !0),
		o(c, h, Ge, "⌋", "\\rfloor", !0),
		o(c, h, Ze, "⌈", "\\lceil", !0),
		o(c, h, Ge, "⌉", "\\rceil", !0),
		o(c, h, w, "\\", "\\backslash"),
		o(c, h, w, "∣", "|"),
		o(c, h, w, "∣", "\\vert"),
		o(N, h, w, "|", "\\textbar", !0),
		o(c, h, w, "∥", "\\|"),
		o(c, h, w, "∥", "\\Vert"),
		o(N, h, w, "∥", "\\textbardbl"),
		o(N, h, w, "~", "\\textasciitilde"),
		o(N, h, w, "\\", "\\textbackslash"),
		o(N, h, w, "^", "\\textasciicircum"),
		o(c, h, b, "↑", "\\uparrow", !0),
		o(c, h, b, "⇑", "\\Uparrow", !0),
		o(c, h, b, "↓", "\\downarrow", !0),
		o(c, h, b, "⇓", "\\Downarrow", !0),
		o(c, h, b, "↕", "\\updownarrow", !0),
		o(c, h, b, "⇕", "\\Updownarrow", !0),
		o(c, h, ze, "∐", "\\coprod"),
		o(c, h, ze, "⋁", "\\bigvee"),
		o(c, h, ze, "⋀", "\\bigwedge"),
		o(c, h, ze, "⨄", "\\biguplus"),
		o(c, h, ze, "⋂", "\\bigcap"),
		o(c, h, ze, "⋃", "\\bigcup"),
		o(c, h, ze, "∫", "\\int"),
		o(c, h, ze, "∫", "\\intop"),
		o(c, h, ze, "∬", "\\iint"),
		o(c, h, ze, "∭", "\\iiint"),
		o(c, h, ze, "∏", "\\prod"),
		o(c, h, ze, "∑", "\\sum"),
		o(c, h, ze, "⨂", "\\bigotimes"),
		o(c, h, ze, "⨁", "\\bigoplus"),
		o(c, h, ze, "⨀", "\\bigodot"),
		o(c, h, ze, "∮", "\\oint"),
		o(c, h, ze, "∯", "\\oiint"),
		o(c, h, ze, "∰", "\\oiiint"),
		o(c, h, ze, "⨆", "\\bigsqcup"),
		o(c, h, ze, "∫", "\\smallint"),
		o(N, h, Xt, "…", "\\textellipsis"),
		o(c, h, Xt, "…", "\\mathellipsis"),
		o(N, h, Xt, "…", "\\ldots", !0),
		o(c, h, Xt, "…", "\\ldots", !0),
		o(c, h, Xt, "⋯", "\\@cdots", !0),
		o(c, h, Xt, "⋱", "\\ddots", !0),
		o(c, h, w, "⋮", "\\varvdots"),
		o(N, h, w, "⋮", "\\varvdots"),
		o(c, h, xe, "ˊ", "\\acute"),
		o(c, h, xe, "ˋ", "\\grave"),
		o(c, h, xe, "¨", "\\ddot"),
		o(c, h, xe, "~", "\\tilde"),
		o(c, h, xe, "ˉ", "\\bar"),
		o(c, h, xe, "˘", "\\breve"),
		o(c, h, xe, "ˇ", "\\check"),
		o(c, h, xe, "^", "\\hat"),
		o(c, h, xe, "⃗", "\\vec"),
		o(c, h, xe, "˙", "\\dot"),
		o(c, h, xe, "˚", "\\mathring"),
		o(c, h, X, "", "\\@imath"),
		o(c, h, X, "", "\\@jmath"),
		o(c, h, w, "ı", "ı"),
		o(c, h, w, "ȷ", "ȷ"),
		o(N, h, w, "ı", "\\i", !0),
		o(N, h, w, "ȷ", "\\j", !0),
		o(N, h, w, "ß", "\\ss", !0),
		o(N, h, w, "æ", "\\ae", !0),
		o(N, h, w, "œ", "\\oe", !0),
		o(N, h, w, "ø", "\\o", !0),
		o(N, h, w, "Æ", "\\AE", !0),
		o(N, h, w, "Œ", "\\OE", !0),
		o(N, h, w, "Ø", "\\O", !0),
		o(N, h, xe, "ˊ", "\\'"),
		o(N, h, xe, "ˋ", "\\`"),
		o(N, h, xe, "ˆ", "\\^"),
		o(N, h, xe, "˜", "\\~"),
		o(N, h, xe, "ˉ", "\\="),
		o(N, h, xe, "˘", "\\u"),
		o(N, h, xe, "˙", "\\."),
		o(N, h, xe, "¸", "\\c"),
		o(N, h, xe, "˚", "\\r"),
		o(N, h, xe, "ˇ", "\\v"),
		o(N, h, xe, "¨", '\\"'),
		o(N, h, xe, "˝", "\\H"),
		o(N, h, xe, "◯", "\\textcircled");
	var Dn = { "--": !0, "---": !0, "``": !0, "''": !0 };
	o(N, h, w, "–", "--", !0),
		o(N, h, w, "–", "\\textendash"),
		o(N, h, w, "—", "---", !0),
		o(N, h, w, "—", "\\textemdash"),
		o(N, h, w, "‘", "`", !0),
		o(N, h, w, "‘", "\\textquoteleft"),
		o(N, h, w, "’", "'", !0),
		o(N, h, w, "’", "\\textquoteright"),
		o(N, h, w, "“", "``", !0),
		o(N, h, w, "“", "\\textquotedblleft"),
		o(N, h, w, "”", "''", !0),
		o(N, h, w, "”", "\\textquotedblright"),
		o(c, h, w, "°", "\\degree", !0),
		o(N, h, w, "°", "\\degree"),
		o(N, h, w, "°", "\\textdegree", !0),
		o(c, h, w, "£", "\\pounds"),
		o(c, h, w, "£", "\\mathsterling", !0),
		o(N, h, w, "£", "\\pounds"),
		o(N, h, w, "£", "\\textsterling", !0),
		o(c, g, w, "✠", "\\maltese"),
		o(N, g, w, "✠", "\\maltese");
	for (var Bn = '0123456789/@."', x0 = 0; x0 < Bn.length; x0++) {
		var Ln = Bn.charAt(x0);
		o(c, h, w, Ln, Ln);
	}
	for (var $n = '0123456789!@*()-=+";:?/.,', w0 = 0; w0 < $n.length; w0++) {
		var qn = $n.charAt(w0);
		o(N, h, w, qn, qn);
	}
	for (
		var Ar = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", k0 = 0;
		k0 < Ar.length;
		k0++
	) {
		var Nr = Ar.charAt(k0);
		o(c, h, X, Nr, Nr), o(N, h, w, Nr, Nr);
	}
	o(c, g, w, "C", "ℂ"),
		o(N, g, w, "C", "ℂ"),
		o(c, g, w, "H", "ℍ"),
		o(N, g, w, "H", "ℍ"),
		o(c, g, w, "N", "ℕ"),
		o(N, g, w, "N", "ℕ"),
		o(c, g, w, "P", "ℙ"),
		o(N, g, w, "P", "ℙ"),
		o(c, g, w, "Q", "ℚ"),
		o(N, g, w, "Q", "ℚ"),
		o(c, g, w, "R", "ℝ"),
		o(N, g, w, "R", "ℝ"),
		o(c, g, w, "Z", "ℤ"),
		o(N, g, w, "Z", "ℤ"),
		o(c, h, X, "h", "ℎ"),
		o(N, h, X, "h", "ℎ");
	for (var Y = "", Ke = 0; Ke < Ar.length; Ke++) {
		var Se = Ar.charAt(Ke);
		(Y = String.fromCharCode(55349, 56320 + Ke)),
			o(c, h, X, Se, Y),
			o(N, h, w, Se, Y),
			(Y = String.fromCharCode(55349, 56372 + Ke)),
			o(c, h, X, Se, Y),
			o(N, h, w, Se, Y),
			(Y = String.fromCharCode(55349, 56424 + Ke)),
			o(c, h, X, Se, Y),
			o(N, h, w, Se, Y),
			(Y = String.fromCharCode(55349, 56580 + Ke)),
			o(c, h, X, Se, Y),
			o(N, h, w, Se, Y),
			(Y = String.fromCharCode(55349, 56684 + Ke)),
			o(c, h, X, Se, Y),
			o(N, h, w, Se, Y),
			(Y = String.fromCharCode(55349, 56736 + Ke)),
			o(c, h, X, Se, Y),
			o(N, h, w, Se, Y),
			(Y = String.fromCharCode(55349, 56788 + Ke)),
			o(c, h, X, Se, Y),
			o(N, h, w, Se, Y),
			(Y = String.fromCharCode(55349, 56840 + Ke)),
			o(c, h, X, Se, Y),
			o(N, h, w, Se, Y),
			(Y = String.fromCharCode(55349, 56944 + Ke)),
			o(c, h, X, Se, Y),
			o(N, h, w, Se, Y),
			Ke < 26 &&
				((Y = String.fromCharCode(55349, 56632 + Ke)),
				o(c, h, X, Se, Y),
				o(N, h, w, Se, Y),
				(Y = String.fromCharCode(55349, 56476 + Ke)),
				o(c, h, X, Se, Y),
				o(N, h, w, Se, Y));
	}
	(Y = "𝕜"), o(c, h, X, "k", Y), o(N, h, w, "k", Y);
	for (var $t = 0; $t < 10; $t++) {
		var Nt = $t.toString();
		(Y = String.fromCharCode(55349, 57294 + $t)),
			o(c, h, X, Nt, Y),
			o(N, h, w, Nt, Y),
			(Y = String.fromCharCode(55349, 57314 + $t)),
			o(c, h, X, Nt, Y),
			o(N, h, w, Nt, Y),
			(Y = String.fromCharCode(55349, 57324 + $t)),
			o(c, h, X, Nt, Y),
			o(N, h, w, Nt, Y),
			(Y = String.fromCharCode(55349, 57334 + $t)),
			o(c, h, X, Nt, Y),
			o(N, h, w, Nt, Y);
	}
	for (var _0 = "ÐÞþ", S0 = 0; S0 < _0.length; S0++) {
		var Or = _0.charAt(S0);
		o(c, h, X, Or, Or), o(N, h, w, Or, Or);
	}
	var zr = [
			["mathbf", "textbf", "Main-Bold"],
			["mathbf", "textbf", "Main-Bold"],
			["mathnormal", "textit", "Math-Italic"],
			["mathnormal", "textit", "Math-Italic"],
			["boldsymbol", "boldsymbol", "Main-BoldItalic"],
			["boldsymbol", "boldsymbol", "Main-BoldItalic"],
			["mathscr", "textscr", "Script-Regular"],
			["", "", ""],
			["", "", ""],
			["", "", ""],
			["mathfrak", "textfrak", "Fraktur-Regular"],
			["mathfrak", "textfrak", "Fraktur-Regular"],
			["mathbb", "textbb", "AMS-Regular"],
			["mathbb", "textbb", "AMS-Regular"],
			["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
			["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
			["mathsf", "textsf", "SansSerif-Regular"],
			["mathsf", "textsf", "SansSerif-Regular"],
			["mathboldsf", "textboldsf", "SansSerif-Bold"],
			["mathboldsf", "textboldsf", "SansSerif-Bold"],
			["mathitsf", "textitsf", "SansSerif-Italic"],
			["mathitsf", "textitsf", "SansSerif-Italic"],
			["", "", ""],
			["", "", ""],
			["mathtt", "texttt", "Typewriter-Regular"],
			["mathtt", "texttt", "Typewriter-Regular"],
		],
		Pn = [
			["mathbf", "textbf", "Main-Bold"],
			["", "", ""],
			["mathsf", "textsf", "SansSerif-Regular"],
			["mathboldsf", "textboldsf", "SansSerif-Bold"],
			["mathtt", "texttt", "Typewriter-Regular"],
		],
		qs = function (e, t) {
			var n = e.charCodeAt(0),
				a = e.charCodeAt(1),
				i = (n - 55296) * 1024 + (a - 56320) + 65536,
				s = t === "math" ? 0 : 1;
			if (119808 <= i && i < 120484) {
				var l = Math.floor((i - 119808) / 26);
				return [zr[l][2], zr[l][s]];
			} else if (120782 <= i && i <= 120831) {
				var u = Math.floor((i - 120782) / 10);
				return [Pn[u][2], Pn[u][s]];
			} else {
				if (i === 120485 || i === 120486) return [zr[0][2], zr[0][s]];
				if (120486 < i && i < 120782) return ["", ""];
				throw new A("Unsupported character: " + e);
			}
		},
		Cr = function (e, t, n) {
			return (
				fe[n][e] && fe[n][e].replace && (e = fe[n][e].replace), { value: e, metrics: f0(e, t, n) }
			);
		},
		at = function (e, t, n, a, i) {
			var s = Cr(e, t, n),
				l = s.metrics;
			e = s.value;
			var u;
			if (l) {
				var d = l.italic;
				(n === "text" || (a && a.font === "mathit")) && (d = 0),
					(u = new tt(e, l.height, l.depth, d, l.skew, l.width, i));
			} else
				typeof console < "u" &&
					console.warn(
						"No character metrics " + ("for '" + e + "' in style '" + t + "' and mode '" + n + "'")
					),
					(u = new tt(e, 0, 0, 0, 0, 0, i));
			if (a) {
				(u.maxFontSize = a.sizeMultiplier), a.style.isTight() && u.classes.push("mtight");
				var p = a.getColor();
				p && (u.style.color = p);
			}
			return u;
		},
		Ps = function (e, t, n, a) {
			return (
				a === void 0 && (a = []),
				n.font === "boldsymbol" && Cr(e, "Main-Bold", t).metrics
					? at(e, "Main-Bold", t, n, a.concat(["mathbf"]))
					: e === "\\" || fe[t][e].font === "main"
						? at(e, "Main-Regular", t, n, a)
						: at(e, "AMS-Regular", t, n, a.concat(["amsrm"]))
			);
		},
		Fs = function (e, t, n, a, i) {
			return i !== "textord" && Cr(e, "Math-BoldItalic", t).metrics
				? { fontName: "Math-BoldItalic", fontClass: "boldsymbol" }
				: { fontName: "Main-Bold", fontClass: "mathbf" };
		},
		Hs = function (e, t, n) {
			var a = e.mode,
				i = e.text,
				s = ["mord"],
				l = a === "math" || (a === "text" && t.font),
				u = l ? t.font : t.fontFamily,
				d = "",
				p = "";
			if ((i.charCodeAt(0) === 55349 && ([d, p] = qs(i, a)), d.length > 0))
				return at(i, d, a, t, s.concat(p));
			if (u) {
				var f, v;
				if (u === "boldsymbol") {
					var x = Fs(i, a, t, s, n);
					(f = x.fontName), (v = [x.fontClass]);
				} else
					l
						? ((f = Un[u].fontName), (v = [u]))
						: ((f = Rr(u, t.fontWeight, t.fontShape)), (v = [u, t.fontWeight, t.fontShape]));
				if (Cr(i, f, a).metrics) return at(i, f, a, t, s.concat(v));
				if (Dn.hasOwnProperty(i) && f.slice(0, 10) === "Typewriter") {
					for (var _ = [], S = 0; S < i.length; S++) _.push(at(i[S], f, a, t, s.concat(v)));
					return Hn(_);
				}
			}
			if (n === "mathord") return at(i, "Math-Italic", a, t, s.concat(["mathnormal"]));
			if (n === "textord") {
				var M = fe[a][i] && fe[a][i].font;
				if (M === "ams") {
					var O = Rr("amsrm", t.fontWeight, t.fontShape);
					return at(i, O, a, t, s.concat("amsrm", t.fontWeight, t.fontShape));
				} else if (M === "main" || !M) {
					var I = Rr("textrm", t.fontWeight, t.fontShape);
					return at(i, I, a, t, s.concat(t.fontWeight, t.fontShape));
				} else {
					var $ = Rr(M, t.fontWeight, t.fontShape);
					return at(i, $, a, t, s.concat($, t.fontWeight, t.fontShape));
				}
			} else throw new Error("unexpected type: " + n + " in makeOrd");
		},
		Us = (r, e) => {
			if (Mt(r.classes) !== Mt(e.classes) || r.skew !== e.skew || r.maxFontSize !== e.maxFontSize)
				return !1;
			if (r.classes.length === 1) {
				var t = r.classes[0];
				if (t === "mbin" || t === "mord") return !1;
			}
			for (var n in r.style) if (r.style.hasOwnProperty(n) && r.style[n] !== e.style[n]) return !1;
			for (var a in e.style) if (e.style.hasOwnProperty(a) && r.style[a] !== e.style[a]) return !1;
			return !0;
		},
		Gs = (r) => {
			for (var e = 0; e < r.length - 1; e++) {
				var t = r[e],
					n = r[e + 1];
				t instanceof tt &&
					n instanceof tt &&
					Us(t, n) &&
					((t.text += n.text),
					(t.height = Math.max(t.height, n.height)),
					(t.depth = Math.max(t.depth, n.depth)),
					(t.italic = n.italic),
					r.splice(e + 1, 1),
					e--);
			}
			return r;
		},
		E0 = function (e) {
			for (var t = 0, n = 0, a = 0, i = 0; i < e.children.length; i++) {
				var s = e.children[i];
				s.height > t && (t = s.height),
					s.depth > n && (n = s.depth),
					s.maxFontSize > a && (a = s.maxFontSize);
			}
			(e.height = t), (e.depth = n), (e.maxFontSize = a);
		},
		Ve = function (e, t, n, a) {
			var i = new ar(e, t, n, a);
			return E0(i), i;
		},
		Fn = (r, e, t, n) => new ar(r, e, t, n),
		Ks = function (e, t, n) {
			var a = Ve([e], [], t);
			return (
				(a.height = Math.max(n || t.fontMetrics().defaultRuleThickness, t.minRuleThickness)),
				(a.style.borderBottomWidth = R(a.height)),
				(a.maxFontSize = 1),
				a
			);
		},
		Vs = function (e, t, n, a) {
			var i = new v0(e, t, n, a);
			return E0(i), i;
		},
		Hn = function (e) {
			var t = new nr(e);
			return E0(t), t;
		},
		Ws = function (e, t) {
			return e instanceof nr ? Ve([], [e], t) : e;
		},
		Zs = function (e) {
			if (e.positionType === "individualShift") {
				for (
					var t = e.children, n = [t[0]], a = -t[0].shift - t[0].elem.depth, i = a, s = 1;
					s < t.length;
					s++
				) {
					var l = -t[s].shift - i - t[s].elem.depth,
						u = l - (t[s - 1].elem.height + t[s - 1].elem.depth);
					(i = i + l), n.push({ type: "kern", size: u }), n.push(t[s]);
				}
				return { children: n, depth: a };
			}
			var d;
			if (e.positionType === "top") {
				for (var p = e.positionData, f = 0; f < e.children.length; f++) {
					var v = e.children[f];
					p -= v.type === "kern" ? v.size : v.elem.height + v.elem.depth;
				}
				d = p;
			} else if (e.positionType === "bottom") d = -e.positionData;
			else {
				var x = e.children[0];
				if (x.type !== "elem") throw new Error('First child must have type "elem".');
				if (e.positionType === "shift") d = -x.elem.depth - e.positionData;
				else if (e.positionType === "firstBaseline") d = -x.elem.depth;
				else throw new Error("Invalid positionType " + e.positionType + ".");
			}
			return { children: e.children, depth: d };
		},
		Xs = function (e, t) {
			for (var { children: n, depth: a } = Zs(e), i = 0, s = 0; s < n.length; s++) {
				var l = n[s];
				if (l.type === "elem") {
					var u = l.elem;
					i = Math.max(i, u.maxFontSize, u.height);
				}
			}
			i += 2;
			var d = Ve(["pstrut"], []);
			d.style.height = R(i);
			for (var p = [], f = a, v = a, x = a, _ = 0; _ < n.length; _++) {
				var S = n[_];
				if (S.type === "kern") x += S.size;
				else {
					var M = S.elem,
						O = S.wrapperClasses || [],
						I = S.wrapperStyle || {},
						$ = Ve(O, [d, M], void 0, I);
					($.style.top = R(-i - x - M.depth)),
						S.marginLeft && ($.style.marginLeft = S.marginLeft),
						S.marginRight && ($.style.marginRight = S.marginRight),
						p.push($),
						(x += M.height + M.depth);
				}
				(f = Math.min(f, x)), (v = Math.max(v, x));
			}
			var P = Ve(["vlist"], p);
			P.style.height = R(v);
			var q;
			if (f < 0) {
				var U = Ve([], []),
					Q = Ve(["vlist"], [U]);
				Q.style.height = R(-f);
				var ne = Ve(["vlist-s"], [new tt("​")]);
				q = [Ve(["vlist-r"], [P, ne]), Ve(["vlist-r"], [Q])];
			} else q = [Ve(["vlist-r"], [P])];
			var te = Ve(["vlist-t"], q);
			return q.length === 2 && te.classes.push("vlist-t2"), (te.height = v), (te.depth = -f), te;
		},
		Ys = (r, e) => {
			var t = Ve(["mspace"], [], e),
				n = ke(r, e);
			return (t.style.marginRight = R(n)), t;
		},
		Rr = function (e, t, n) {
			var a = "";
			switch (e) {
				case "amsrm":
					a = "AMS";
					break;
				case "textrm":
					a = "Main";
					break;
				case "textsf":
					a = "SansSerif";
					break;
				case "texttt":
					a = "Typewriter";
					break;
				default:
					a = e;
			}
			var i;
			return (
				t === "textbf" && n === "textit"
					? (i = "BoldItalic")
					: t === "textbf"
						? (i = "Bold")
						: t === "textit"
							? (i = "Italic")
							: (i = "Regular"),
				a + "-" + i
			);
		},
		Un = {
			mathbf: { variant: "bold", fontName: "Main-Bold" },
			mathrm: { variant: "normal", fontName: "Main-Regular" },
			textit: { variant: "italic", fontName: "Main-Italic" },
			mathit: { variant: "italic", fontName: "Main-Italic" },
			mathnormal: { variant: "italic", fontName: "Math-Italic" },
			mathsfit: { variant: "sans-serif-italic", fontName: "SansSerif-Italic" },
			mathbb: { variant: "double-struck", fontName: "AMS-Regular" },
			mathcal: { variant: "script", fontName: "Caligraphic-Regular" },
			mathfrak: { variant: "fraktur", fontName: "Fraktur-Regular" },
			mathscr: { variant: "script", fontName: "Script-Regular" },
			mathsf: { variant: "sans-serif", fontName: "SansSerif-Regular" },
			mathtt: { variant: "monospace", fontName: "Typewriter-Regular" },
		},
		Gn = {
			vec: ["vec", 0.471, 0.714],
			oiintSize1: ["oiintSize1", 0.957, 0.499],
			oiintSize2: ["oiintSize2", 1.472, 0.659],
			oiiintSize1: ["oiiintSize1", 1.304, 0.499],
			oiiintSize2: ["oiiintSize2", 1.98, 0.659],
		},
		Qs = function (e, t) {
			var [n, a, i] = Gn[e],
				s = new At(n),
				l = new vt([s], {
					width: R(a),
					height: R(i),
					style: "width:" + R(a),
					viewBox: "0 0 " + 1e3 * a + " " + 1e3 * i,
					preserveAspectRatio: "xMinYMin",
				}),
				u = Fn(["overlay"], [l], t);
			return (u.height = i), (u.style.height = R(i)), (u.style.width = R(a)), u;
		},
		k = {
			fontMap: Un,
			makeSymbol: at,
			mathsym: Ps,
			makeSpan: Ve,
			makeSvgSpan: Fn,
			makeLineSpan: Ks,
			makeAnchor: Vs,
			makeFragment: Hn,
			wrapFragment: Ws,
			makeVList: Xs,
			makeOrd: Hs,
			makeGlue: Ys,
			staticSvg: Qs,
			svgData: Gn,
			tryCombineChars: Gs,
		},
		_e = { number: 3, unit: "mu" },
		qt = { number: 4, unit: "mu" },
		xt = { number: 5, unit: "mu" },
		Js = {
			mord: { mop: _e, mbin: qt, mrel: xt, minner: _e },
			mop: { mord: _e, mop: _e, mrel: xt, minner: _e },
			mbin: { mord: qt, mop: qt, mopen: qt, minner: qt },
			mrel: { mord: xt, mop: xt, mopen: xt, minner: xt },
			mopen: {},
			mclose: { mop: _e, mbin: qt, mrel: xt, minner: _e },
			mpunct: { mord: _e, mop: _e, mrel: xt, mopen: _e, mclose: _e, mpunct: _e, minner: _e },
			minner: { mord: _e, mop: _e, mbin: qt, mrel: xt, mopen: _e, mpunct: _e, minner: _e },
		},
		js = {
			mord: { mop: _e },
			mop: { mord: _e, mop: _e },
			mbin: {},
			mrel: {},
			mopen: {},
			mclose: { mop: _e },
			mpunct: {},
			minner: { mop: _e },
		},
		Kn = {},
		Ir = {},
		Dr = {};
	function B(r) {
		for (
			var { type: e, names: t, props: n, handler: a, htmlBuilder: i, mathmlBuilder: s } = r,
				l = {
					type: e,
					numArgs: n.numArgs,
					argTypes: n.argTypes,
					allowedInArgument: !!n.allowedInArgument,
					allowedInText: !!n.allowedInText,
					allowedInMath: n.allowedInMath === void 0 ? !0 : n.allowedInMath,
					numOptionalArgs: n.numOptionalArgs || 0,
					infix: !!n.infix,
					primitive: !!n.primitive,
					handler: a,
				},
				u = 0;
			u < t.length;
			++u
		)
			Kn[t[u]] = l;
		e && (i && (Ir[e] = i), s && (Dr[e] = s));
	}
	function Pt(r) {
		var { type: e, htmlBuilder: t, mathmlBuilder: n } = r;
		B({
			type: e,
			names: [],
			props: { numArgs: 0 },
			handler() {
				throw new Error("Should never be called.");
			},
			htmlBuilder: t,
			mathmlBuilder: n,
		});
	}
	var Br = function (e) {
			return e.type === "ordgroup" && e.body.length === 1 ? e.body[0] : e;
		},
		Ae = function (e) {
			return e.type === "ordgroup" ? e.body : [e];
		},
		wt = k.makeSpan,
		eo = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"],
		to = ["rightmost", "mrel", "mclose", "mpunct"],
		ro = { display: Z.DISPLAY, text: Z.TEXT, script: Z.SCRIPT, scriptscript: Z.SCRIPTSCRIPT },
		no = {
			mord: "mord",
			mop: "mop",
			mbin: "mbin",
			mrel: "mrel",
			mopen: "mopen",
			mclose: "mclose",
			mpunct: "mpunct",
			minner: "minner",
		},
		Ie = function (e, t, n, a) {
			a === void 0 && (a = [null, null]);
			for (var i = [], s = 0; s < e.length; s++) {
				var l = oe(e[s], t);
				if (l instanceof nr) {
					var u = l.children;
					i.push(...u);
				} else i.push(l);
			}
			if ((k.tryCombineChars(i), !n)) return i;
			var d = t;
			if (e.length === 1) {
				var p = e[0];
				p.type === "sizing"
					? (d = t.havingSize(p.size))
					: p.type === "styling" && (d = t.havingStyle(ro[p.style]));
			}
			var f = wt([a[0] || "leftmost"], [], t),
				v = wt([a[1] || "rightmost"], [], t),
				x = n === "root";
			return (
				Vn(
					i,
					(_, S) => {
						var M = S.classes[0],
							O = _.classes[0];
						M === "mbin" && V.contains(to, O)
							? (S.classes[0] = "mord")
							: O === "mbin" && V.contains(eo, M) && (_.classes[0] = "mord");
					},
					{ node: f },
					v,
					x
				),
				Vn(
					i,
					(_, S) => {
						var M = T0(S),
							O = T0(_),
							I = M && O ? (_.hasClass("mtight") ? js[M][O] : Js[M][O]) : null;
						if (I) return k.makeGlue(I, d);
					},
					{ node: f },
					v,
					x
				),
				i
			);
		},
		Vn = function r(e, t, n, a, i) {
			a && e.push(a);
			for (var s = 0; s < e.length; s++) {
				var l = e[s],
					u = Wn(l);
				if (u) {
					r(u.children, t, n, null, i);
					continue;
				}
				var d = !l.hasClass("mspace");
				if (d) {
					var p = t(l, n.node);
					p && (n.insertAfter ? n.insertAfter(p) : (e.unshift(p), s++));
				}
				d ? (n.node = l) : i && l.hasClass("newline") && (n.node = wt(["leftmost"])),
					(n.insertAfter = ((f) => (v) => {
						e.splice(f + 1, 0, v), s++;
					})(s));
			}
			a && e.pop();
		},
		Wn = function (e) {
			return e instanceof nr || e instanceof v0 || (e instanceof ar && e.hasClass("enclosing"))
				? e
				: null;
		},
		ao = function r(e, t) {
			var n = Wn(e);
			if (n) {
				var a = n.children;
				if (a.length) {
					if (t === "right") return r(a[a.length - 1], "right");
					if (t === "left") return r(a[0], "left");
				}
			}
			return e;
		},
		T0 = function (e, t) {
			return e ? (t && (e = ao(e, t)), no[e.classes[0]] || null) : null;
		},
		ir = function (e, t) {
			var n = ["nulldelimiter"].concat(e.baseSizingClasses());
			return wt(t.concat(n));
		},
		oe = function (e, t, n) {
			if (!e) return wt();
			if (Ir[e.type]) {
				var a = Ir[e.type](e, t);
				if (n && t.size !== n.size) {
					a = wt(t.sizingClasses(n), [a], t);
					var i = t.sizeMultiplier / n.sizeMultiplier;
					(a.height *= i), (a.depth *= i);
				}
				return a;
			} else throw new A("Got group of unknown type: '" + e.type + "'");
		};
	function Lr(r, e) {
		var t = wt(["base"], r, e),
			n = wt(["strut"]);
		return (
			(n.style.height = R(t.height + t.depth)),
			t.depth && (n.style.verticalAlign = R(-t.depth)),
			t.children.unshift(n),
			t
		);
	}
	function M0(r, e) {
		var t = null;
		r.length === 1 && r[0].type === "tag" && ((t = r[0].tag), (r = r[0].body));
		var n = Ie(r, e, "root"),
			a;
		n.length === 2 && n[1].hasClass("tag") && (a = n.pop());
		for (var i = [], s = [], l = 0; l < n.length; l++)
			if (
				(s.push(n[l]),
				n[l].hasClass("mbin") || n[l].hasClass("mrel") || n[l].hasClass("allowbreak"))
			) {
				for (
					var u = !1;
					l < n.length - 1 && n[l + 1].hasClass("mspace") && !n[l + 1].hasClass("newline");

				)
					l++, s.push(n[l]), n[l].hasClass("nobreak") && (u = !0);
				u || (i.push(Lr(s, e)), (s = []));
			} else
				n[l].hasClass("newline") &&
					(s.pop(), s.length > 0 && (i.push(Lr(s, e)), (s = [])), i.push(n[l]));
		s.length > 0 && i.push(Lr(s, e));
		var d;
		t ? ((d = Lr(Ie(t, e, !0))), (d.classes = ["tag"]), i.push(d)) : a && i.push(a);
		var p = wt(["katex-html"], i);
		if ((p.setAttribute("aria-hidden", "true"), d)) {
			var f = d.children[0];
			(f.style.height = R(p.height + p.depth)), p.depth && (f.style.verticalAlign = R(-p.depth));
		}
		return p;
	}
	function Zn(r) {
		return new nr(r);
	}
	class Xe {
		constructor(e, t, n) {
			(this.type = void 0),
				(this.attributes = void 0),
				(this.children = void 0),
				(this.classes = void 0),
				(this.type = e),
				(this.attributes = {}),
				(this.children = t || []),
				(this.classes = n || []);
		}
		setAttribute(e, t) {
			this.attributes[e] = t;
		}
		getAttribute(e) {
			return this.attributes[e];
		}
		toNode() {
			var e = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
			for (var t in this.attributes)
				Object.prototype.hasOwnProperty.call(this.attributes, t) &&
					e.setAttribute(t, this.attributes[t]);
			this.classes.length > 0 && (e.className = Mt(this.classes));
			for (var n = 0; n < this.children.length; n++)
				if (this.children[n] instanceof ct && this.children[n + 1] instanceof ct) {
					for (
						var a = this.children[n].toText() + this.children[++n].toText();
						this.children[n + 1] instanceof ct;

					)
						a += this.children[++n].toText();
					e.appendChild(new ct(a).toNode());
				} else e.appendChild(this.children[n].toNode());
			return e;
		}
		toMarkup() {
			var e = "<" + this.type;
			for (var t in this.attributes)
				Object.prototype.hasOwnProperty.call(this.attributes, t) &&
					((e += " " + t + '="'), (e += V.escape(this.attributes[t])), (e += '"'));
			this.classes.length > 0 && (e += ' class ="' + V.escape(Mt(this.classes)) + '"'), (e += ">");
			for (var n = 0; n < this.children.length; n++) e += this.children[n].toMarkup();
			return (e += "</" + this.type + ">"), e;
		}
		toText() {
			return this.children.map((e) => e.toText()).join("");
		}
	}
	class ct {
		constructor(e) {
			(this.text = void 0), (this.text = e);
		}
		toNode() {
			return document.createTextNode(this.text);
		}
		toMarkup() {
			return V.escape(this.toText());
		}
		toText() {
			return this.text;
		}
	}
	class io {
		constructor(e) {
			(this.width = void 0),
				(this.character = void 0),
				(this.width = e),
				e >= 0.05555 && e <= 0.05556
					? (this.character = " ")
					: e >= 0.1666 && e <= 0.1667
						? (this.character = " ")
						: e >= 0.2222 && e <= 0.2223
							? (this.character = " ")
							: e >= 0.2777 && e <= 0.2778
								? (this.character = "  ")
								: e >= -0.05556 && e <= -0.05555
									? (this.character = " ⁣")
									: e >= -0.1667 && e <= -0.1666
										? (this.character = " ⁣")
										: e >= -0.2223 && e <= -0.2222
											? (this.character = " ⁣")
											: e >= -0.2778 && e <= -0.2777
												? (this.character = " ⁣")
												: (this.character = null);
		}
		toNode() {
			if (this.character) return document.createTextNode(this.character);
			var e = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
			return e.setAttribute("width", R(this.width)), e;
		}
		toMarkup() {
			return this.character
				? "<mtext>" + this.character + "</mtext>"
				: '<mspace width="' + R(this.width) + '"/>';
		}
		toText() {
			return this.character ? this.character : " ";
		}
	}
	var z = { MathNode: Xe, TextNode: ct, SpaceNode: io, newDocumentFragment: Zn },
		rt = function (e, t, n) {
			return (
				fe[t][e] &&
					fe[t][e].replace &&
					e.charCodeAt(0) !== 55349 &&
					!(
						Dn.hasOwnProperty(e) &&
						n &&
						((n.fontFamily && n.fontFamily.slice(4, 6) === "tt") ||
							(n.font && n.font.slice(4, 6) === "tt"))
					) &&
					(e = fe[t][e].replace),
				new z.TextNode(e)
			);
		},
		A0 = function (e) {
			return e.length === 1 ? e[0] : new z.MathNode("mrow", e);
		},
		N0 = function (e, t) {
			if (t.fontFamily === "texttt") return "monospace";
			if (t.fontFamily === "textsf")
				return t.fontShape === "textit" && t.fontWeight === "textbf"
					? "sans-serif-bold-italic"
					: t.fontShape === "textit"
						? "sans-serif-italic"
						: t.fontWeight === "textbf"
							? "bold-sans-serif"
							: "sans-serif";
			if (t.fontShape === "textit" && t.fontWeight === "textbf") return "bold-italic";
			if (t.fontShape === "textit") return "italic";
			if (t.fontWeight === "textbf") return "bold";
			var n = t.font;
			if (!n || n === "mathnormal") return null;
			var a = e.mode;
			if (n === "mathit") return "italic";
			if (n === "boldsymbol") return e.type === "textord" ? "bold" : "bold-italic";
			if (n === "mathbf") return "bold";
			if (n === "mathbb") return "double-struck";
			if (n === "mathsfit") return "sans-serif-italic";
			if (n === "mathfrak") return "fraktur";
			if (n === "mathscr" || n === "mathcal") return "script";
			if (n === "mathsf") return "sans-serif";
			if (n === "mathtt") return "monospace";
			var i = e.text;
			if (V.contains(["\\imath", "\\jmath"], i)) return null;
			fe[a][i] && fe[a][i].replace && (i = fe[a][i].replace);
			var s = k.fontMap[n].fontName;
			return f0(i, s, a) ? k.fontMap[n].variant : null;
		};
	function O0(r) {
		if (!r) return !1;
		if (r.type === "mi" && r.children.length === 1) {
			var e = r.children[0];
			return e instanceof ct && e.text === ".";
		} else if (
			r.type === "mo" &&
			r.children.length === 1 &&
			r.getAttribute("separator") === "true" &&
			r.getAttribute("lspace") === "0em" &&
			r.getAttribute("rspace") === "0em"
		) {
			var t = r.children[0];
			return t instanceof ct && t.text === ",";
		} else return !1;
	}
	var We = function (e, t, n) {
			if (e.length === 1) {
				var a = me(e[0], t);
				return (
					n &&
						a instanceof Xe &&
						a.type === "mo" &&
						(a.setAttribute("lspace", "0em"), a.setAttribute("rspace", "0em")),
					[a]
				);
			}
			for (var i = [], s, l = 0; l < e.length; l++) {
				var u = me(e[l], t);
				if (u instanceof Xe && s instanceof Xe) {
					if (
						u.type === "mtext" &&
						s.type === "mtext" &&
						u.getAttribute("mathvariant") === s.getAttribute("mathvariant")
					) {
						s.children.push(...u.children);
						continue;
					} else if (u.type === "mn" && s.type === "mn") {
						s.children.push(...u.children);
						continue;
					} else if (O0(u) && s.type === "mn") {
						s.children.push(...u.children);
						continue;
					} else if (u.type === "mn" && O0(s))
						(u.children = [...s.children, ...u.children]), i.pop();
					else if (
						(u.type === "msup" || u.type === "msub") &&
						u.children.length >= 1 &&
						(s.type === "mn" || O0(s))
					) {
						var d = u.children[0];
						d instanceof Xe &&
							d.type === "mn" &&
							((d.children = [...s.children, ...d.children]), i.pop());
					} else if (s.type === "mi" && s.children.length === 1) {
						var p = s.children[0];
						if (
							p instanceof ct &&
							p.text === "̸" &&
							(u.type === "mo" || u.type === "mi" || u.type === "mn")
						) {
							var f = u.children[0];
							f instanceof ct &&
								f.text.length > 0 &&
								((f.text = f.text.slice(0, 1) + "̸" + f.text.slice(1)), i.pop());
						}
					}
				}
				i.push(u), (s = u);
			}
			return i;
		},
		Ot = function (e, t, n) {
			return A0(We(e, t, n));
		},
		me = function (e, t) {
			if (!e) return new z.MathNode("mrow");
			if (Dr[e.type]) {
				var n = Dr[e.type](e, t);
				return n;
			} else throw new A("Got group of unknown type: '" + e.type + "'");
		};
	function Xn(r, e, t, n, a) {
		var i = We(r, t),
			s;
		i.length === 1 && i[0] instanceof Xe && V.contains(["mrow", "mtable"], i[0].type)
			? (s = i[0])
			: (s = new z.MathNode("mrow", i));
		var l = new z.MathNode("annotation", [new z.TextNode(e)]);
		l.setAttribute("encoding", "application/x-tex");
		var u = new z.MathNode("semantics", [s, l]),
			d = new z.MathNode("math", [u]);
		d.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML"),
			n && d.setAttribute("display", "block");
		var p = a ? "katex" : "katex-mathml";
		return k.makeSpan([p], [d]);
	}
	var Yn = function (e) {
			return new bt({
				style: e.displayMode ? Z.DISPLAY : Z.TEXT,
				maxSize: e.maxSize,
				minRuleThickness: e.minRuleThickness,
			});
		},
		Qn = function (e, t) {
			if (t.displayMode) {
				var n = ["katex-display"];
				t.leqno && n.push("leqno"), t.fleqn && n.push("fleqn"), (e = k.makeSpan(n, [e]));
			}
			return e;
		},
		so = function (e, t, n) {
			var a = Yn(n),
				i;
			if (n.output === "mathml") return Xn(e, t, a, n.displayMode, !0);
			if (n.output === "html") {
				var s = M0(e, a);
				i = k.makeSpan(["katex"], [s]);
			} else {
				var l = Xn(e, t, a, n.displayMode, !1),
					u = M0(e, a);
				i = k.makeSpan(["katex"], [l, u]);
			}
			return Qn(i, n);
		},
		oo = function (e, t, n) {
			var a = Yn(n),
				i = M0(e, a),
				s = k.makeSpan(["katex"], [i]);
			return Qn(s, n);
		},
		lo = {
			widehat: "^",
			widecheck: "ˇ",
			widetilde: "~",
			utilde: "~",
			overleftarrow: "←",
			underleftarrow: "←",
			xleftarrow: "←",
			overrightarrow: "→",
			underrightarrow: "→",
			xrightarrow: "→",
			underbrace: "⏟",
			overbrace: "⏞",
			overgroup: "⏠",
			undergroup: "⏡",
			overleftrightarrow: "↔",
			underleftrightarrow: "↔",
			xleftrightarrow: "↔",
			Overrightarrow: "⇒",
			xRightarrow: "⇒",
			overleftharpoon: "↼",
			xleftharpoonup: "↼",
			overrightharpoon: "⇀",
			xrightharpoonup: "⇀",
			xLeftarrow: "⇐",
			xLeftrightarrow: "⇔",
			xhookleftarrow: "↩",
			xhookrightarrow: "↪",
			xmapsto: "↦",
			xrightharpoondown: "⇁",
			xleftharpoondown: "↽",
			xrightleftharpoons: "⇌",
			xleftrightharpoons: "⇋",
			xtwoheadleftarrow: "↞",
			xtwoheadrightarrow: "↠",
			xlongequal: "=",
			xtofrom: "⇄",
			xrightleftarrows: "⇄",
			xrightequilibrium: "⇌",
			xleftequilibrium: "⇋",
			"\\cdrightarrow": "→",
			"\\cdleftarrow": "←",
			"\\cdlongequal": "=",
		},
		co = function (e) {
			var t = new z.MathNode("mo", [new z.TextNode(lo[e.replace(/^\\/, "")])]);
			return t.setAttribute("stretchy", "true"), t;
		},
		uo = {
			overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
			overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
			underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
			underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
			xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
			"\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
			xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
			"\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
			Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
			xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
			xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
			overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
			xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
			xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
			overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
			xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
			xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
			xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
			"\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
			xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
			xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
			overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
			overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
			underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
			underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
			xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
			xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
			xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
			xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
			xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
			xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
			overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
			underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
			overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
			undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
			xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
			xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
			xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
			xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
			xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716],
		},
		ho = function (e) {
			return e.type === "ordgroup" ? e.body.length : 1;
		},
		mo = function (e, t) {
			function n() {
				var l = 4e5,
					u = e.label.slice(1);
				if (V.contains(["widehat", "widecheck", "widetilde", "utilde"], u)) {
					var d = e,
						p = ho(d.base),
						f,
						v,
						x;
					if (p > 5)
						u === "widehat" || u === "widecheck"
							? ((f = 420), (l = 2364), (x = 0.42), (v = u + "4"))
							: ((f = 312), (l = 2340), (x = 0.34), (v = "tilde4"));
					else {
						var _ = [1, 1, 2, 2, 3, 3][p];
						u === "widehat" || u === "widecheck"
							? ((l = [0, 1062, 2364, 2364, 2364][_]),
								(f = [0, 239, 300, 360, 420][_]),
								(x = [0, 0.24, 0.3, 0.3, 0.36, 0.42][_]),
								(v = u + _))
							: ((l = [0, 600, 1033, 2339, 2340][_]),
								(f = [0, 260, 286, 306, 312][_]),
								(x = [0, 0.26, 0.286, 0.3, 0.306, 0.34][_]),
								(v = "tilde" + _));
					}
					var S = new At(v),
						M = new vt([S], {
							width: "100%",
							height: R(x),
							viewBox: "0 0 " + l + " " + f,
							preserveAspectRatio: "none",
						});
					return { span: k.makeSvgSpan([], [M], t), minWidth: 0, height: x };
				} else {
					var O = [],
						I = uo[u],
						[$, P, q] = I,
						U = q / 1e3,
						Q = $.length,
						ne,
						te;
					if (Q === 1) {
						var Pe = I[3];
						(ne = ["hide-tail"]), (te = [Pe]);
					} else if (Q === 2)
						(ne = ["halfarrow-left", "halfarrow-right"]), (te = ["xMinYMin", "xMaxYMin"]);
					else if (Q === 3)
						(ne = ["brace-left", "brace-center", "brace-right"]),
							(te = ["xMinYMin", "xMidYMin", "xMaxYMin"]);
					else
						throw new Error(
							`Correct katexImagesData or update code here to support
                    ` +
								Q +
								" children."
						);
					for (var Ee = 0; Ee < Q; Ee++) {
						var ve = new At($[Ee]),
							Qe = new vt([ve], {
								width: "400em",
								height: R(U),
								viewBox: "0 0 " + l + " " + q,
								preserveAspectRatio: te[Ee] + " slice",
							}),
							we = k.makeSvgSpan([ne[Ee]], [Qe], t);
						if (Q === 1) return { span: we, minWidth: P, height: U };
						(we.style.height = R(U)), O.push(we);
					}
					return { span: k.makeSpan(["stretchy"], O, t), minWidth: P, height: U };
				}
			}
			var { span: a, minWidth: i, height: s } = n();
			return (a.height = s), (a.style.height = R(s)), i > 0 && (a.style.minWidth = R(i)), a;
		},
		po = function (e, t, n, a, i) {
			var s,
				l = e.height + e.depth + n + a;
			if (/fbox|color|angl/.test(t)) {
				if (((s = k.makeSpan(["stretchy", t], [], i)), t === "fbox")) {
					var u = i.color && i.getColor();
					u && (s.style.borderColor = u);
				}
			} else {
				var d = [];
				/^[bx]cancel$/.test(t) &&
					d.push(new y0({ x1: "0", y1: "0", x2: "100%", y2: "100%", "stroke-width": "0.046em" })),
					/^x?cancel$/.test(t) &&
						d.push(new y0({ x1: "0", y1: "100%", x2: "100%", y2: "0", "stroke-width": "0.046em" }));
				var p = new vt(d, { width: "100%", height: R(l) });
				s = k.makeSvgSpan([], [p], i);
			}
			return (s.height = l), (s.style.height = R(l)), s;
		},
		kt = { encloseSpan: po, mathMLnode: co, svgSpan: mo };
	function re(r, e) {
		if (!r || r.type !== e)
			throw new Error(
				"Expected node of type " + e + ", but got " + (r ? "node of type " + r.type : String(r))
			);
		return r;
	}
	function z0(r) {
		var e = $r(r);
		if (!e)
			throw new Error(
				"Expected node of symbol group type, but got " + (r ? "node of type " + r.type : String(r))
			);
		return e;
	}
	function $r(r) {
		return r && (r.type === "atom" || $s.hasOwnProperty(r.type)) ? r : null;
	}
	var C0 = (r, e) => {
			var t, n, a;
			r && r.type === "supsub"
				? ((n = re(r.base, "accent")), (t = n.base), (r.base = t), (a = Bs(oe(r, e))), (r.base = n))
				: ((n = re(r, "accent")), (t = n.base));
			var i = oe(t, e.havingCrampedStyle()),
				s = n.isShifty && V.isCharacterBox(t),
				l = 0;
			if (s) {
				var u = V.getBaseElem(t),
					d = oe(u, e.havingCrampedStyle());
				l = In(d).skew;
			}
			var p = n.label === "\\c",
				f = p ? i.height + i.depth : Math.min(i.height, e.fontMetrics().xHeight),
				v;
			if (n.isStretchy)
				(v = kt.svgSpan(n, e)),
					(v = k.makeVList(
						{
							positionType: "firstBaseline",
							children: [
								{ type: "elem", elem: i },
								{
									type: "elem",
									elem: v,
									wrapperClasses: ["svg-align"],
									wrapperStyle:
										l > 0
											? { width: "calc(100% - " + R(2 * l) + ")", marginLeft: R(2 * l) }
											: void 0,
								},
							],
						},
						e
					));
			else {
				var x, _;
				n.label === "\\vec"
					? ((x = k.staticSvg("vec", e)), (_ = k.svgData.vec[1]))
					: ((x = k.makeOrd({ mode: n.mode, text: n.label }, e, "textord")),
						(x = In(x)),
						(x.italic = 0),
						(_ = x.width),
						p && (f += x.depth)),
					(v = k.makeSpan(["accent-body"], [x]));
				var S = n.label === "\\textcircled";
				S && (v.classes.push("accent-full"), (f = i.height));
				var M = l;
				S || (M -= _ / 2),
					(v.style.left = R(M)),
					n.label === "\\textcircled" && (v.style.top = ".2em"),
					(v = k.makeVList(
						{
							positionType: "firstBaseline",
							children: [
								{ type: "elem", elem: i },
								{ type: "kern", size: -f },
								{ type: "elem", elem: v },
							],
						},
						e
					));
			}
			var O = k.makeSpan(["mord", "accent"], [v], e);
			return a
				? ((a.children[0] = O),
					(a.height = Math.max(O.height, a.height)),
					(a.classes[0] = "mord"),
					a)
				: O;
		},
		Jn = (r, e) => {
			var t = r.isStretchy ? kt.mathMLnode(r.label) : new z.MathNode("mo", [rt(r.label, r.mode)]),
				n = new z.MathNode("mover", [me(r.base, e), t]);
			return n.setAttribute("accent", "true"), n;
		},
		fo = new RegExp(
			[
				"\\acute",
				"\\grave",
				"\\ddot",
				"\\tilde",
				"\\bar",
				"\\breve",
				"\\check",
				"\\hat",
				"\\vec",
				"\\dot",
				"\\mathring",
			]
				.map((r) => "\\" + r)
				.join("|")
		);
	B({
		type: "accent",
		names: [
			"\\acute",
			"\\grave",
			"\\ddot",
			"\\tilde",
			"\\bar",
			"\\breve",
			"\\check",
			"\\hat",
			"\\vec",
			"\\dot",
			"\\mathring",
			"\\widecheck",
			"\\widehat",
			"\\widetilde",
			"\\overrightarrow",
			"\\overleftarrow",
			"\\Overrightarrow",
			"\\overleftrightarrow",
			"\\overgroup",
			"\\overlinesegment",
			"\\overleftharpoon",
			"\\overrightharpoon",
		],
		props: { numArgs: 1 },
		handler: (r, e) => {
			var t = Br(e[0]),
				n = !fo.test(r.funcName),
				a =
					!n ||
					r.funcName === "\\widehat" ||
					r.funcName === "\\widetilde" ||
					r.funcName === "\\widecheck";
			return {
				type: "accent",
				mode: r.parser.mode,
				label: r.funcName,
				isStretchy: n,
				isShifty: a,
				base: t,
			};
		},
		htmlBuilder: C0,
		mathmlBuilder: Jn,
	}),
		B({
			type: "accent",
			names: [
				"\\'",
				"\\`",
				"\\^",
				"\\~",
				"\\=",
				"\\u",
				"\\.",
				'\\"',
				"\\c",
				"\\r",
				"\\H",
				"\\v",
				"\\textcircled",
			],
			props: { numArgs: 1, allowedInText: !0, allowedInMath: !0, argTypes: ["primitive"] },
			handler: (r, e) => {
				var t = e[0],
					n = r.parser.mode;
				return (
					n === "math" &&
						(r.parser.settings.reportNonstrict(
							"mathVsTextAccents",
							"LaTeX's accent " + r.funcName + " works only in text mode"
						),
						(n = "text")),
					{ type: "accent", mode: n, label: r.funcName, isStretchy: !1, isShifty: !0, base: t }
				);
			},
			htmlBuilder: C0,
			mathmlBuilder: Jn,
		}),
		B({
			type: "accentUnder",
			names: [
				"\\underleftarrow",
				"\\underrightarrow",
				"\\underleftrightarrow",
				"\\undergroup",
				"\\underlinesegment",
				"\\utilde",
			],
			props: { numArgs: 1 },
			handler: (r, e) => {
				var { parser: t, funcName: n } = r,
					a = e[0];
				return { type: "accentUnder", mode: t.mode, label: n, base: a };
			},
			htmlBuilder: (r, e) => {
				var t = oe(r.base, e),
					n = kt.svgSpan(r, e),
					a = r.label === "\\utilde" ? 0.12 : 0,
					i = k.makeVList(
						{
							positionType: "top",
							positionData: t.height,
							children: [
								{ type: "elem", elem: n, wrapperClasses: ["svg-align"] },
								{ type: "kern", size: a },
								{ type: "elem", elem: t },
							],
						},
						e
					);
				return k.makeSpan(["mord", "accentunder"], [i], e);
			},
			mathmlBuilder: (r, e) => {
				var t = kt.mathMLnode(r.label),
					n = new z.MathNode("munder", [me(r.base, e), t]);
				return n.setAttribute("accentunder", "true"), n;
			},
		});
	var qr = (r) => {
		var e = new z.MathNode("mpadded", r ? [r] : []);
		return e.setAttribute("width", "+0.6em"), e.setAttribute("lspace", "0.3em"), e;
	};
	B({
		type: "xArrow",
		names: [
			"\\xleftarrow",
			"\\xrightarrow",
			"\\xLeftarrow",
			"\\xRightarrow",
			"\\xleftrightarrow",
			"\\xLeftrightarrow",
			"\\xhookleftarrow",
			"\\xhookrightarrow",
			"\\xmapsto",
			"\\xrightharpoondown",
			"\\xrightharpoonup",
			"\\xleftharpoondown",
			"\\xleftharpoonup",
			"\\xrightleftharpoons",
			"\\xleftrightharpoons",
			"\\xlongequal",
			"\\xtwoheadrightarrow",
			"\\xtwoheadleftarrow",
			"\\xtofrom",
			"\\xrightleftarrows",
			"\\xrightequilibrium",
			"\\xleftequilibrium",
			"\\\\cdrightarrow",
			"\\\\cdleftarrow",
			"\\\\cdlongequal",
		],
		props: { numArgs: 1, numOptionalArgs: 1 },
		handler(r, e, t) {
			var { parser: n, funcName: a } = r;
			return { type: "xArrow", mode: n.mode, label: a, body: e[0], below: t[0] };
		},
		htmlBuilder(r, e) {
			var t = e.style,
				n = e.havingStyle(t.sup()),
				a = k.wrapFragment(oe(r.body, n, e), e),
				i = r.label.slice(0, 2) === "\\x" ? "x" : "cd";
			a.classes.push(i + "-arrow-pad");
			var s;
			r.below &&
				((n = e.havingStyle(t.sub())),
				(s = k.wrapFragment(oe(r.below, n, e), e)),
				s.classes.push(i + "-arrow-pad"));
			var l = kt.svgSpan(r, e),
				u = -e.fontMetrics().axisHeight + 0.5 * l.height,
				d = -e.fontMetrics().axisHeight - 0.5 * l.height - 0.111;
			(a.depth > 0.25 || r.label === "\\xleftequilibrium") && (d -= a.depth);
			var p;
			if (s) {
				var f = -e.fontMetrics().axisHeight + s.height + 0.5 * l.height + 0.111;
				p = k.makeVList(
					{
						positionType: "individualShift",
						children: [
							{ type: "elem", elem: a, shift: d },
							{ type: "elem", elem: l, shift: u },
							{ type: "elem", elem: s, shift: f },
						],
					},
					e
				);
			} else
				p = k.makeVList(
					{
						positionType: "individualShift",
						children: [
							{ type: "elem", elem: a, shift: d },
							{ type: "elem", elem: l, shift: u },
						],
					},
					e
				);
			return (
				p.children[0].children[0].children[1].classes.push("svg-align"),
				k.makeSpan(["mrel", "x-arrow"], [p], e)
			);
		},
		mathmlBuilder(r, e) {
			var t = kt.mathMLnode(r.label);
			t.setAttribute("minsize", r.label.charAt(0) === "x" ? "1.75em" : "3.0em");
			var n;
			if (r.body) {
				var a = qr(me(r.body, e));
				if (r.below) {
					var i = qr(me(r.below, e));
					n = new z.MathNode("munderover", [t, i, a]);
				} else n = new z.MathNode("mover", [t, a]);
			} else if (r.below) {
				var s = qr(me(r.below, e));
				n = new z.MathNode("munder", [t, s]);
			} else (n = qr()), (n = new z.MathNode("mover", [t, n]));
			return n;
		},
	});
	var go = k.makeSpan;
	function jn(r, e) {
		var t = Ie(r.body, e, !0);
		return go([r.mclass], t, e);
	}
	function ea(r, e) {
		var t,
			n = We(r.body, e);
		return (
			r.mclass === "minner"
				? (t = new z.MathNode("mpadded", n))
				: r.mclass === "mord"
					? r.isCharacterBox
						? ((t = n[0]), (t.type = "mi"))
						: (t = new z.MathNode("mi", n))
					: (r.isCharacterBox ? ((t = n[0]), (t.type = "mo")) : (t = new z.MathNode("mo", n)),
						r.mclass === "mbin"
							? ((t.attributes.lspace = "0.22em"), (t.attributes.rspace = "0.22em"))
							: r.mclass === "mpunct"
								? ((t.attributes.lspace = "0em"), (t.attributes.rspace = "0.17em"))
								: r.mclass === "mopen" || r.mclass === "mclose"
									? ((t.attributes.lspace = "0em"), (t.attributes.rspace = "0em"))
									: r.mclass === "minner" &&
										((t.attributes.lspace = "0.0556em"), (t.attributes.width = "+0.1111em"))),
			t
		);
	}
	B({
		type: "mclass",
		names: [
			"\\mathord",
			"\\mathbin",
			"\\mathrel",
			"\\mathopen",
			"\\mathclose",
			"\\mathpunct",
			"\\mathinner",
		],
		props: { numArgs: 1, primitive: !0 },
		handler(r, e) {
			var { parser: t, funcName: n } = r,
				a = e[0];
			return {
				type: "mclass",
				mode: t.mode,
				mclass: "m" + n.slice(5),
				body: Ae(a),
				isCharacterBox: V.isCharacterBox(a),
			};
		},
		htmlBuilder: jn,
		mathmlBuilder: ea,
	});
	var Pr = (r) => {
		var e = r.type === "ordgroup" && r.body.length ? r.body[0] : r;
		return e.type === "atom" && (e.family === "bin" || e.family === "rel")
			? "m" + e.family
			: "mord";
	};
	B({
		type: "mclass",
		names: ["\\@binrel"],
		props: { numArgs: 2 },
		handler(r, e) {
			var { parser: t } = r;
			return {
				type: "mclass",
				mode: t.mode,
				mclass: Pr(e[0]),
				body: Ae(e[1]),
				isCharacterBox: V.isCharacterBox(e[1]),
			};
		},
	}),
		B({
			type: "mclass",
			names: ["\\stackrel", "\\overset", "\\underset"],
			props: { numArgs: 2 },
			handler(r, e) {
				var { parser: t, funcName: n } = r,
					a = e[1],
					i = e[0],
					s;
				n !== "\\stackrel" ? (s = Pr(a)) : (s = "mrel");
				var l = {
						type: "op",
						mode: a.mode,
						limits: !0,
						alwaysHandleSupSub: !0,
						parentIsSupSub: !1,
						symbol: !1,
						suppressBaseShift: n !== "\\stackrel",
						body: Ae(a),
					},
					u = {
						type: "supsub",
						mode: i.mode,
						base: l,
						sup: n === "\\underset" ? null : i,
						sub: n === "\\underset" ? i : null,
					};
				return {
					type: "mclass",
					mode: t.mode,
					mclass: s,
					body: [u],
					isCharacterBox: V.isCharacterBox(u),
				};
			},
			htmlBuilder: jn,
			mathmlBuilder: ea,
		}),
		B({
			type: "pmb",
			names: ["\\pmb"],
			props: { numArgs: 1, allowedInText: !0 },
			handler(r, e) {
				var { parser: t } = r;
				return { type: "pmb", mode: t.mode, mclass: Pr(e[0]), body: Ae(e[0]) };
			},
			htmlBuilder(r, e) {
				var t = Ie(r.body, e, !0),
					n = k.makeSpan([r.mclass], t, e);
				return (n.style.textShadow = "0.02em 0.01em 0.04px"), n;
			},
			mathmlBuilder(r, e) {
				var t = We(r.body, e),
					n = new z.MathNode("mstyle", t);
				return n.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px"), n;
			},
		});
	var bo = {
			">": "\\\\cdrightarrow",
			"<": "\\\\cdleftarrow",
			"=": "\\\\cdlongequal",
			A: "\\uparrow",
			V: "\\downarrow",
			"|": "\\Vert",
			".": "no arrow",
		},
		ta = () => ({ type: "styling", body: [], mode: "math", style: "display" }),
		ra = (r) => r.type === "textord" && r.text === "@",
		vo = (r, e) => (r.type === "mathord" || r.type === "atom") && r.text === e;
	function yo(r, e, t) {
		var n = bo[r];
		switch (n) {
			case "\\\\cdrightarrow":
			case "\\\\cdleftarrow":
				return t.callFunction(n, [e[0]], [e[1]]);
			case "\\uparrow":
			case "\\downarrow": {
				var a = t.callFunction("\\\\cdleft", [e[0]], []),
					i = { type: "atom", text: n, mode: "math", family: "rel" },
					s = t.callFunction("\\Big", [i], []),
					l = t.callFunction("\\\\cdright", [e[1]], []),
					u = { type: "ordgroup", mode: "math", body: [a, s, l] };
				return t.callFunction("\\\\cdparent", [u], []);
			}
			case "\\\\cdlongequal":
				return t.callFunction("\\\\cdlongequal", [], []);
			case "\\Vert": {
				var d = { type: "textord", text: "\\Vert", mode: "math" };
				return t.callFunction("\\Big", [d], []);
			}
			default:
				return { type: "textord", text: " ", mode: "math" };
		}
	}
	function xo(r) {
		var e = [];
		for (
			r.gullet.beginGroup(), r.gullet.macros.set("\\cr", "\\\\\\relax"), r.gullet.beginGroup();
			;

		) {
			e.push(r.parseExpression(!1, "\\\\")), r.gullet.endGroup(), r.gullet.beginGroup();
			var t = r.fetch().text;
			if (t === "&" || t === "\\\\") r.consume();
			else if (t === "\\end") {
				e[e.length - 1].length === 0 && e.pop();
				break;
			} else throw new A("Expected \\\\ or \\cr or \\end", r.nextToken);
		}
		for (var n = [], a = [n], i = 0; i < e.length; i++) {
			for (var s = e[i], l = ta(), u = 0; u < s.length; u++)
				if (!ra(s[u])) l.body.push(s[u]);
				else {
					n.push(l), (u += 1);
					var d = z0(s[u]).text,
						p = new Array(2);
					if (
						((p[0] = { type: "ordgroup", mode: "math", body: [] }),
						(p[1] = { type: "ordgroup", mode: "math", body: [] }),
						!("=|.".indexOf(d) > -1))
					)
						if ("<>AV".indexOf(d) > -1)
							for (var f = 0; f < 2; f++) {
								for (var v = !0, x = u + 1; x < s.length; x++) {
									if (vo(s[x], d)) {
										(v = !1), (u = x);
										break;
									}
									if (ra(s[x]))
										throw new A("Missing a " + d + " character to complete a CD arrow.", s[x]);
									p[f].body.push(s[x]);
								}
								if (v) throw new A("Missing a " + d + " character to complete a CD arrow.", s[u]);
							}
						else throw new A('Expected one of "<>AV=|." after @', s[u]);
					var _ = yo(d, p, r),
						S = { type: "styling", body: [_], mode: "math", style: "display" };
					n.push(S), (l = ta());
				}
			i % 2 === 0 ? n.push(l) : n.shift(), (n = []), a.push(n);
		}
		r.gullet.endGroup(), r.gullet.endGroup();
		var M = new Array(a[0].length).fill({ type: "align", align: "c", pregap: 0.25, postgap: 0.25 });
		return {
			type: "array",
			mode: "math",
			body: a,
			arraystretch: 1,
			addJot: !0,
			rowGaps: [null],
			cols: M,
			colSeparationType: "CD",
			hLinesBeforeRow: new Array(a.length + 1).fill([]),
		};
	}
	B({
		type: "cdlabel",
		names: ["\\\\cdleft", "\\\\cdright"],
		props: { numArgs: 1 },
		handler(r, e) {
			var { parser: t, funcName: n } = r;
			return { type: "cdlabel", mode: t.mode, side: n.slice(4), label: e[0] };
		},
		htmlBuilder(r, e) {
			var t = e.havingStyle(e.style.sup()),
				n = k.wrapFragment(oe(r.label, t, e), e);
			return (
				n.classes.push("cd-label-" + r.side),
				(n.style.bottom = R(0.8 - n.depth)),
				(n.height = 0),
				(n.depth = 0),
				n
			);
		},
		mathmlBuilder(r, e) {
			var t = new z.MathNode("mrow", [me(r.label, e)]);
			return (
				(t = new z.MathNode("mpadded", [t])),
				t.setAttribute("width", "0"),
				r.side === "left" && t.setAttribute("lspace", "-1width"),
				t.setAttribute("voffset", "0.7em"),
				(t = new z.MathNode("mstyle", [t])),
				t.setAttribute("displaystyle", "false"),
				t.setAttribute("scriptlevel", "1"),
				t
			);
		},
	}),
		B({
			type: "cdlabelparent",
			names: ["\\\\cdparent"],
			props: { numArgs: 1 },
			handler(r, e) {
				var { parser: t } = r;
				return { type: "cdlabelparent", mode: t.mode, fragment: e[0] };
			},
			htmlBuilder(r, e) {
				var t = k.wrapFragment(oe(r.fragment, e), e);
				return t.classes.push("cd-vert-arrow"), t;
			},
			mathmlBuilder(r, e) {
				return new z.MathNode("mrow", [me(r.fragment, e)]);
			},
		}),
		B({
			type: "textord",
			names: ["\\@char"],
			props: { numArgs: 1, allowedInText: !0 },
			handler(r, e) {
				for (
					var { parser: t } = r, n = re(e[0], "ordgroup"), a = n.body, i = "", s = 0;
					s < a.length;
					s++
				) {
					var l = re(a[s], "textord");
					i += l.text;
				}
				var u = parseInt(i),
					d;
				if (isNaN(u)) throw new A("\\@char has non-numeric argument " + i);
				if (u < 0 || u >= 1114111) throw new A("\\@char with invalid code point " + i);
				return (
					u <= 65535
						? (d = String.fromCharCode(u))
						: ((u -= 65536), (d = String.fromCharCode((u >> 10) + 55296, (u & 1023) + 56320))),
					{ type: "textord", mode: t.mode, text: d }
				);
			},
		});
	var na = (r, e) => {
			var t = Ie(r.body, e.withColor(r.color), !1);
			return k.makeFragment(t);
		},
		aa = (r, e) => {
			var t = We(r.body, e.withColor(r.color)),
				n = new z.MathNode("mstyle", t);
			return n.setAttribute("mathcolor", r.color), n;
		};
	B({
		type: "color",
		names: ["\\textcolor"],
		props: { numArgs: 2, allowedInText: !0, argTypes: ["color", "original"] },
		handler(r, e) {
			var { parser: t } = r,
				n = re(e[0], "color-token").color,
				a = e[1];
			return { type: "color", mode: t.mode, color: n, body: Ae(a) };
		},
		htmlBuilder: na,
		mathmlBuilder: aa,
	}),
		B({
			type: "color",
			names: ["\\color"],
			props: { numArgs: 1, allowedInText: !0, argTypes: ["color"] },
			handler(r, e) {
				var { parser: t, breakOnTokenText: n } = r,
					a = re(e[0], "color-token").color;
				t.gullet.macros.set("\\current@color", a);
				var i = t.parseExpression(!0, n);
				return { type: "color", mode: t.mode, color: a, body: i };
			},
			htmlBuilder: na,
			mathmlBuilder: aa,
		}),
		B({
			type: "cr",
			names: ["\\\\"],
			props: { numArgs: 0, numOptionalArgs: 0, allowedInText: !0 },
			handler(r, e, t) {
				var { parser: n } = r,
					a = n.gullet.future().text === "[" ? n.parseSizeGroup(!0) : null,
					i =
						!n.settings.displayMode ||
						!n.settings.useStrictBehavior(
							"newLineInDisplayMode",
							"In LaTeX, \\\\ or \\newline does nothing in display mode"
						);
				return { type: "cr", mode: n.mode, newLine: i, size: a && re(a, "size").value };
			},
			htmlBuilder(r, e) {
				var t = k.makeSpan(["mspace"], [], e);
				return (
					r.newLine &&
						(t.classes.push("newline"), r.size && (t.style.marginTop = R(ke(r.size, e)))),
					t
				);
			},
			mathmlBuilder(r, e) {
				var t = new z.MathNode("mspace");
				return (
					r.newLine &&
						(t.setAttribute("linebreak", "newline"),
						r.size && t.setAttribute("height", R(ke(r.size, e)))),
					t
				);
			},
		});
	var R0 = {
			"\\global": "\\global",
			"\\long": "\\\\globallong",
			"\\\\globallong": "\\\\globallong",
			"\\def": "\\gdef",
			"\\gdef": "\\gdef",
			"\\edef": "\\xdef",
			"\\xdef": "\\xdef",
			"\\let": "\\\\globallet",
			"\\futurelet": "\\\\globalfuture",
		},
		ia = (r) => {
			var e = r.text;
			if (/^(?:[\\{}$&#^_]|EOF)$/.test(e)) throw new A("Expected a control sequence", r);
			return e;
		},
		wo = (r) => {
			var e = r.gullet.popToken();
			return (
				e.text === "=" && ((e = r.gullet.popToken()), e.text === " " && (e = r.gullet.popToken())),
				e
			);
		},
		sa = (r, e, t, n) => {
			var a = r.gullet.macros.get(t.text);
			a == null &&
				((t.noexpand = !0),
				(a = { tokens: [t], numArgs: 0, unexpandable: !r.gullet.isExpandable(t.text) })),
				r.gullet.macros.set(e, a, n);
		};
	B({
		type: "internal",
		names: ["\\global", "\\long", "\\\\globallong"],
		props: { numArgs: 0, allowedInText: !0 },
		handler(r) {
			var { parser: e, funcName: t } = r;
			e.consumeSpaces();
			var n = e.fetch();
			if (R0[n.text])
				return (
					(t === "\\global" || t === "\\\\globallong") && (n.text = R0[n.text]),
					re(e.parseFunction(), "internal")
				);
			throw new A("Invalid token after macro prefix", n);
		},
	}),
		B({
			type: "internal",
			names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
			props: { numArgs: 0, allowedInText: !0, primitive: !0 },
			handler(r) {
				var { parser: e, funcName: t } = r,
					n = e.gullet.popToken(),
					a = n.text;
				if (/^(?:[\\{}$&#^_]|EOF)$/.test(a)) throw new A("Expected a control sequence", n);
				for (var i = 0, s, l = [[]]; e.gullet.future().text !== "{"; )
					if (((n = e.gullet.popToken()), n.text === "#")) {
						if (e.gullet.future().text === "{") {
							(s = e.gullet.future()), l[i].push("{");
							break;
						}
						if (((n = e.gullet.popToken()), !/^[1-9]$/.test(n.text)))
							throw new A('Invalid argument number "' + n.text + '"');
						if (parseInt(n.text) !== i + 1)
							throw new A('Argument number "' + n.text + '" out of order');
						i++, l.push([]);
					} else {
						if (n.text === "EOF") throw new A("Expected a macro definition");
						l[i].push(n.text);
					}
				var { tokens: u } = e.gullet.consumeArg();
				return (
					s && u.unshift(s),
					(t === "\\edef" || t === "\\xdef") && ((u = e.gullet.expandTokens(u)), u.reverse()),
					e.gullet.macros.set(a, { tokens: u, numArgs: i, delimiters: l }, t === R0[t]),
					{ type: "internal", mode: e.mode }
				);
			},
		}),
		B({
			type: "internal",
			names: ["\\let", "\\\\globallet"],
			props: { numArgs: 0, allowedInText: !0, primitive: !0 },
			handler(r) {
				var { parser: e, funcName: t } = r,
					n = ia(e.gullet.popToken());
				e.gullet.consumeSpaces();
				var a = wo(e);
				return sa(e, n, a, t === "\\\\globallet"), { type: "internal", mode: e.mode };
			},
		}),
		B({
			type: "internal",
			names: ["\\futurelet", "\\\\globalfuture"],
			props: { numArgs: 0, allowedInText: !0, primitive: !0 },
			handler(r) {
				var { parser: e, funcName: t } = r,
					n = ia(e.gullet.popToken()),
					a = e.gullet.popToken(),
					i = e.gullet.popToken();
				return (
					sa(e, n, i, t === "\\\\globalfuture"),
					e.gullet.pushToken(i),
					e.gullet.pushToken(a),
					{ type: "internal", mode: e.mode }
				);
			},
		});
	var sr = function (e, t, n) {
			var a = fe.math[e] && fe.math[e].replace,
				i = f0(a || e, t, n);
			if (!i) throw new Error("Unsupported symbol " + e + " and font size " + t + ".");
			return i;
		},
		I0 = function (e, t, n, a) {
			var i = n.havingBaseStyle(t),
				s = k.makeSpan(a.concat(i.sizingClasses(n)), [e], n),
				l = i.sizeMultiplier / n.sizeMultiplier;
			return (s.height *= l), (s.depth *= l), (s.maxFontSize = i.sizeMultiplier), s;
		},
		oa = function (e, t, n) {
			var a = t.havingBaseStyle(n),
				i = (1 - t.sizeMultiplier / a.sizeMultiplier) * t.fontMetrics().axisHeight;
			e.classes.push("delimcenter"), (e.style.top = R(i)), (e.height -= i), (e.depth += i);
		},
		ko = function (e, t, n, a, i, s) {
			var l = k.makeSymbol(e, "Main-Regular", i, a),
				u = I0(l, t, a, s);
			return n && oa(u, a, t), u;
		},
		_o = function (e, t, n, a) {
			return k.makeSymbol(e, "Size" + t + "-Regular", n, a);
		},
		la = function (e, t, n, a, i, s) {
			var l = _o(e, t, i, a),
				u = I0(k.makeSpan(["delimsizing", "size" + t], [l], a), Z.TEXT, a, s);
			return n && oa(u, a, Z.TEXT), u;
		},
		D0 = function (e, t, n) {
			var a;
			t === "Size1-Regular" ? (a = "delim-size1") : (a = "delim-size4");
			var i = k.makeSpan(["delimsizinginner", a], [k.makeSpan([], [k.makeSymbol(e, t, n)])]);
			return { type: "elem", elem: i };
		},
		B0 = function (e, t, n) {
			var a = lt["Size4-Regular"][e.charCodeAt(0)]
					? lt["Size4-Regular"][e.charCodeAt(0)][4]
					: lt["Size1-Regular"][e.charCodeAt(0)][4],
				i = new At("inner", Ms(e, Math.round(1e3 * t))),
				s = new vt([i], {
					width: R(a),
					height: R(t),
					style: "width:" + R(a),
					viewBox: "0 0 " + 1e3 * a + " " + Math.round(1e3 * t),
					preserveAspectRatio: "xMinYMin",
				}),
				l = k.makeSvgSpan([], [s], n);
			return (
				(l.height = t), (l.style.height = R(t)), (l.style.width = R(a)), { type: "elem", elem: l }
			);
		},
		L0 = 0.008,
		Fr = { type: "kern", size: -1 * L0 },
		So = ["|", "\\lvert", "\\rvert", "\\vert"],
		Eo = ["\\|", "\\lVert", "\\rVert", "\\Vert"],
		ca = function (e, t, n, a, i, s) {
			var l,
				u,
				d,
				p,
				f = "",
				v = 0;
			(l = d = p = e), (u = null);
			var x = "Size1-Regular";
			e === "\\uparrow"
				? (d = p = "⏐")
				: e === "\\Uparrow"
					? (d = p = "‖")
					: e === "\\downarrow"
						? (l = d = "⏐")
						: e === "\\Downarrow"
							? (l = d = "‖")
							: e === "\\updownarrow"
								? ((l = "\\uparrow"), (d = "⏐"), (p = "\\downarrow"))
								: e === "\\Updownarrow"
									? ((l = "\\Uparrow"), (d = "‖"), (p = "\\Downarrow"))
									: V.contains(So, e)
										? ((d = "∣"), (f = "vert"), (v = 333))
										: V.contains(Eo, e)
											? ((d = "∥"), (f = "doublevert"), (v = 556))
											: e === "[" || e === "\\lbrack"
												? ((l = "⎡"),
													(d = "⎢"),
													(p = "⎣"),
													(x = "Size4-Regular"),
													(f = "lbrack"),
													(v = 667))
												: e === "]" || e === "\\rbrack"
													? ((l = "⎤"),
														(d = "⎥"),
														(p = "⎦"),
														(x = "Size4-Regular"),
														(f = "rbrack"),
														(v = 667))
													: e === "\\lfloor" || e === "⌊"
														? ((d = l = "⎢"),
															(p = "⎣"),
															(x = "Size4-Regular"),
															(f = "lfloor"),
															(v = 667))
														: e === "\\lceil" || e === "⌈"
															? ((l = "⎡"),
																(d = p = "⎢"),
																(x = "Size4-Regular"),
																(f = "lceil"),
																(v = 667))
															: e === "\\rfloor" || e === "⌋"
																? ((d = l = "⎥"),
																	(p = "⎦"),
																	(x = "Size4-Regular"),
																	(f = "rfloor"),
																	(v = 667))
																: e === "\\rceil" || e === "⌉"
																	? ((l = "⎤"),
																		(d = p = "⎥"),
																		(x = "Size4-Regular"),
																		(f = "rceil"),
																		(v = 667))
																	: e === "(" || e === "\\lparen"
																		? ((l = "⎛"),
																			(d = "⎜"),
																			(p = "⎝"),
																			(x = "Size4-Regular"),
																			(f = "lparen"),
																			(v = 875))
																		: e === ")" || e === "\\rparen"
																			? ((l = "⎞"),
																				(d = "⎟"),
																				(p = "⎠"),
																				(x = "Size4-Regular"),
																				(f = "rparen"),
																				(v = 875))
																			: e === "\\{" || e === "\\lbrace"
																				? ((l = "⎧"),
																					(u = "⎨"),
																					(p = "⎩"),
																					(d = "⎪"),
																					(x = "Size4-Regular"))
																				: e === "\\}" || e === "\\rbrace"
																					? ((l = "⎫"),
																						(u = "⎬"),
																						(p = "⎭"),
																						(d = "⎪"),
																						(x = "Size4-Regular"))
																					: e === "\\lgroup" || e === "⟮"
																						? ((l = "⎧"),
																							(p = "⎩"),
																							(d = "⎪"),
																							(x = "Size4-Regular"))
																						: e === "\\rgroup" || e === "⟯"
																							? ((l = "⎫"),
																								(p = "⎭"),
																								(d = "⎪"),
																								(x = "Size4-Regular"))
																							: e === "\\lmoustache" || e === "⎰"
																								? ((l = "⎧"),
																									(p = "⎭"),
																									(d = "⎪"),
																									(x = "Size4-Regular"))
																								: (e === "\\rmoustache" || e === "⎱") &&
																									((l = "⎫"),
																									(p = "⎩"),
																									(d = "⎪"),
																									(x = "Size4-Regular"));
			var _ = sr(l, x, i),
				S = _.height + _.depth,
				M = sr(d, x, i),
				O = M.height + M.depth,
				I = sr(p, x, i),
				$ = I.height + I.depth,
				P = 0,
				q = 1;
			if (u !== null) {
				var U = sr(u, x, i);
				(P = U.height + U.depth), (q = 2);
			}
			var Q = S + $ + P,
				ne = Math.max(0, Math.ceil((t - Q) / (q * O))),
				te = Q + ne * q * O,
				Pe = a.fontMetrics().axisHeight;
			n && (Pe *= a.sizeMultiplier);
			var Ee = te / 2 - Pe,
				ve = [];
			if (f.length > 0) {
				var Qe = te - S - $,
					we = Math.round(te * 1e3),
					$e = As(f, Math.round(Qe * 1e3)),
					Fe = new At(f, $e),
					nt = (v / 1e3).toFixed(3) + "em",
					ie = (we / 1e3).toFixed(3) + "em",
					De = new vt([Fe], { width: nt, height: ie, viewBox: "0 0 " + v + " " + we }),
					Te = k.makeSvgSpan([], [De], a);
				(Te.height = we / 1e3),
					(Te.style.width = nt),
					(Te.style.height = ie),
					ve.push({ type: "elem", elem: Te });
			} else {
				if ((ve.push(D0(p, x, i)), ve.push(Fr), u === null)) {
					var Ce = te - S - $ + 2 * L0;
					ve.push(B0(d, Ce, a));
				} else {
					var Me = (te - S - $ - P) / 2 + 2 * L0;
					ve.push(B0(d, Me, a)),
						ve.push(Fr),
						ve.push(D0(u, x, i)),
						ve.push(Fr),
						ve.push(B0(d, Me, a));
				}
				ve.push(Fr), ve.push(D0(l, x, i));
			}
			var Je = a.havingBaseStyle(Z.TEXT),
				vr = k.makeVList({ positionType: "bottom", positionData: Ee, children: ve }, Je);
			return I0(k.makeSpan(["delimsizing", "mult"], [vr], Je), Z.TEXT, a, s);
		},
		$0 = 80,
		q0 = 0.08,
		P0 = function (e, t, n, a, i) {
			var s = Ts(e, a, n),
				l = new At(e, s),
				u = new vt([l], {
					width: "400em",
					height: R(t),
					viewBox: "0 0 400000 " + n,
					preserveAspectRatio: "xMinYMin slice",
				});
			return k.makeSvgSpan(["hide-tail"], [u], i);
		},
		To = function (e, t) {
			var n = t.havingBaseSizing(),
				a = ma("\\surd", e * n.sizeMultiplier, da, n),
				i = n.sizeMultiplier,
				s = Math.max(0, t.minRuleThickness - t.fontMetrics().sqrtRuleThickness),
				l,
				u = 0,
				d = 0,
				p = 0,
				f;
			return (
				a.type === "small"
					? ((p = 1e3 + 1e3 * s + $0),
						e < 1 ? (i = 1) : e < 1.4 && (i = 0.7),
						(u = (1 + s + q0) / i),
						(d = (1 + s) / i),
						(l = P0("sqrtMain", u, p, s, t)),
						(l.style.minWidth = "0.853em"),
						(f = 0.833 / i))
					: a.type === "large"
						? ((p = (1e3 + $0) * or[a.size]),
							(d = (or[a.size] + s) / i),
							(u = (or[a.size] + s + q0) / i),
							(l = P0("sqrtSize" + a.size, u, p, s, t)),
							(l.style.minWidth = "1.02em"),
							(f = 1 / i))
						: ((u = e + s + q0),
							(d = e + s),
							(p = Math.floor(1e3 * e + s) + $0),
							(l = P0("sqrtTall", u, p, s, t)),
							(l.style.minWidth = "0.742em"),
							(f = 1.056)),
				(l.height = d),
				(l.style.height = R(u)),
				{ span: l, advanceWidth: f, ruleWidth: (t.fontMetrics().sqrtRuleThickness + s) * i }
			);
		},
		ua = [
			"(",
			"\\lparen",
			")",
			"\\rparen",
			"[",
			"\\lbrack",
			"]",
			"\\rbrack",
			"\\{",
			"\\lbrace",
			"\\}",
			"\\rbrace",
			"\\lfloor",
			"\\rfloor",
			"⌊",
			"⌋",
			"\\lceil",
			"\\rceil",
			"⌈",
			"⌉",
			"\\surd",
		],
		Mo = [
			"\\uparrow",
			"\\downarrow",
			"\\updownarrow",
			"\\Uparrow",
			"\\Downarrow",
			"\\Updownarrow",
			"|",
			"\\|",
			"\\vert",
			"\\Vert",
			"\\lvert",
			"\\rvert",
			"\\lVert",
			"\\rVert",
			"\\lgroup",
			"\\rgroup",
			"⟮",
			"⟯",
			"\\lmoustache",
			"\\rmoustache",
			"⎰",
			"⎱",
		],
		ha = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"],
		or = [0, 1.2, 1.8, 2.4, 3],
		Ao = function (e, t, n, a, i) {
			if (
				(e === "<" || e === "\\lt" || e === "⟨"
					? (e = "\\langle")
					: (e === ">" || e === "\\gt" || e === "⟩") && (e = "\\rangle"),
				V.contains(ua, e) || V.contains(ha, e))
			)
				return la(e, t, !1, n, a, i);
			if (V.contains(Mo, e)) return ca(e, or[t], !1, n, a, i);
			throw new A("Illegal delimiter: '" + e + "'");
		},
		No = [
			{ type: "small", style: Z.SCRIPTSCRIPT },
			{ type: "small", style: Z.SCRIPT },
			{ type: "small", style: Z.TEXT },
			{ type: "large", size: 1 },
			{ type: "large", size: 2 },
			{ type: "large", size: 3 },
			{ type: "large", size: 4 },
		],
		Oo = [
			{ type: "small", style: Z.SCRIPTSCRIPT },
			{ type: "small", style: Z.SCRIPT },
			{ type: "small", style: Z.TEXT },
			{ type: "stack" },
		],
		da = [
			{ type: "small", style: Z.SCRIPTSCRIPT },
			{ type: "small", style: Z.SCRIPT },
			{ type: "small", style: Z.TEXT },
			{ type: "large", size: 1 },
			{ type: "large", size: 2 },
			{ type: "large", size: 3 },
			{ type: "large", size: 4 },
			{ type: "stack" },
		],
		zo = function (e) {
			if (e.type === "small") return "Main-Regular";
			if (e.type === "large") return "Size" + e.size + "-Regular";
			if (e.type === "stack") return "Size4-Regular";
			throw new Error("Add support for delim type '" + e.type + "' here.");
		},
		ma = function (e, t, n, a) {
			for (
				var i = Math.min(2, 3 - a.style.size), s = i;
				s < n.length && n[s].type !== "stack";
				s++
			) {
				var l = sr(e, zo(n[s]), "math"),
					u = l.height + l.depth;
				if (n[s].type === "small") {
					var d = a.havingBaseStyle(n[s].style);
					u *= d.sizeMultiplier;
				}
				if (u > t) return n[s];
			}
			return n[n.length - 1];
		},
		pa = function (e, t, n, a, i, s) {
			e === "<" || e === "\\lt" || e === "⟨"
				? (e = "\\langle")
				: (e === ">" || e === "\\gt" || e === "⟩") && (e = "\\rangle");
			var l;
			V.contains(ha, e) ? (l = No) : V.contains(ua, e) ? (l = da) : (l = Oo);
			var u = ma(e, t, l, a);
			return u.type === "small"
				? ko(e, u.style, n, a, i, s)
				: u.type === "large"
					? la(e, u.size, n, a, i, s)
					: ca(e, t, n, a, i, s);
		},
		Co = function (e, t, n, a, i, s) {
			var l = a.fontMetrics().axisHeight * a.sizeMultiplier,
				u = 901,
				d = 5 / a.fontMetrics().ptPerEm,
				p = Math.max(t - l, n + l),
				f = Math.max((p / 500) * u, 2 * p - d);
			return pa(e, f, !0, a, i, s);
		},
		_t = {
			sqrtImage: To,
			sizedDelim: Ao,
			sizeToMaxHeight: or,
			customSizedDelim: pa,
			leftRightDelim: Co,
		},
		fa = {
			"\\bigl": { mclass: "mopen", size: 1 },
			"\\Bigl": { mclass: "mopen", size: 2 },
			"\\biggl": { mclass: "mopen", size: 3 },
			"\\Biggl": { mclass: "mopen", size: 4 },
			"\\bigr": { mclass: "mclose", size: 1 },
			"\\Bigr": { mclass: "mclose", size: 2 },
			"\\biggr": { mclass: "mclose", size: 3 },
			"\\Biggr": { mclass: "mclose", size: 4 },
			"\\bigm": { mclass: "mrel", size: 1 },
			"\\Bigm": { mclass: "mrel", size: 2 },
			"\\biggm": { mclass: "mrel", size: 3 },
			"\\Biggm": { mclass: "mrel", size: 4 },
			"\\big": { mclass: "mord", size: 1 },
			"\\Big": { mclass: "mord", size: 2 },
			"\\bigg": { mclass: "mord", size: 3 },
			"\\Bigg": { mclass: "mord", size: 4 },
		},
		Ro = [
			"(",
			"\\lparen",
			")",
			"\\rparen",
			"[",
			"\\lbrack",
			"]",
			"\\rbrack",
			"\\{",
			"\\lbrace",
			"\\}",
			"\\rbrace",
			"\\lfloor",
			"\\rfloor",
			"⌊",
			"⌋",
			"\\lceil",
			"\\rceil",
			"⌈",
			"⌉",
			"<",
			">",
			"\\langle",
			"⟨",
			"\\rangle",
			"⟩",
			"\\lt",
			"\\gt",
			"\\lvert",
			"\\rvert",
			"\\lVert",
			"\\rVert",
			"\\lgroup",
			"\\rgroup",
			"⟮",
			"⟯",
			"\\lmoustache",
			"\\rmoustache",
			"⎰",
			"⎱",
			"/",
			"\\backslash",
			"|",
			"\\vert",
			"\\|",
			"\\Vert",
			"\\uparrow",
			"\\Uparrow",
			"\\downarrow",
			"\\Downarrow",
			"\\updownarrow",
			"\\Updownarrow",
			".",
		];
	function Hr(r, e) {
		var t = $r(r);
		if (t && V.contains(Ro, t.text)) return t;
		throw t
			? new A("Invalid delimiter '" + t.text + "' after '" + e.funcName + "'", r)
			: new A("Invalid delimiter type '" + r.type + "'", r);
	}
	B({
		type: "delimsizing",
		names: [
			"\\bigl",
			"\\Bigl",
			"\\biggl",
			"\\Biggl",
			"\\bigr",
			"\\Bigr",
			"\\biggr",
			"\\Biggr",
			"\\bigm",
			"\\Bigm",
			"\\biggm",
			"\\Biggm",
			"\\big",
			"\\Big",
			"\\bigg",
			"\\Bigg",
		],
		props: { numArgs: 1, argTypes: ["primitive"] },
		handler: (r, e) => {
			var t = Hr(e[0], r);
			return {
				type: "delimsizing",
				mode: r.parser.mode,
				size: fa[r.funcName].size,
				mclass: fa[r.funcName].mclass,
				delim: t.text,
			};
		},
		htmlBuilder: (r, e) =>
			r.delim === "."
				? k.makeSpan([r.mclass])
				: _t.sizedDelim(r.delim, r.size, e, r.mode, [r.mclass]),
		mathmlBuilder: (r) => {
			var e = [];
			r.delim !== "." && e.push(rt(r.delim, r.mode));
			var t = new z.MathNode("mo", e);
			r.mclass === "mopen" || r.mclass === "mclose"
				? t.setAttribute("fence", "true")
				: t.setAttribute("fence", "false"),
				t.setAttribute("stretchy", "true");
			var n = R(_t.sizeToMaxHeight[r.size]);
			return t.setAttribute("minsize", n), t.setAttribute("maxsize", n), t;
		},
	});
	function ga(r) {
		if (!r.body) throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
	}
	B({
		type: "leftright-right",
		names: ["\\right"],
		props: { numArgs: 1, primitive: !0 },
		handler: (r, e) => {
			var t = r.parser.gullet.macros.get("\\current@color");
			if (t && typeof t != "string") throw new A("\\current@color set to non-string in \\right");
			return { type: "leftright-right", mode: r.parser.mode, delim: Hr(e[0], r).text, color: t };
		},
	}),
		B({
			type: "leftright",
			names: ["\\left"],
			props: { numArgs: 1, primitive: !0 },
			handler: (r, e) => {
				var t = Hr(e[0], r),
					n = r.parser;
				++n.leftrightDepth;
				var a = n.parseExpression(!1);
				--n.leftrightDepth, n.expect("\\right", !1);
				var i = re(n.parseFunction(), "leftright-right");
				return {
					type: "leftright",
					mode: n.mode,
					body: a,
					left: t.text,
					right: i.delim,
					rightColor: i.color,
				};
			},
			htmlBuilder: (r, e) => {
				ga(r);
				for (
					var t = Ie(r.body, e, !0, ["mopen", "mclose"]), n = 0, a = 0, i = !1, s = 0;
					s < t.length;
					s++
				)
					t[s].isMiddle
						? (i = !0)
						: ((n = Math.max(t[s].height, n)), (a = Math.max(t[s].depth, a)));
				(n *= e.sizeMultiplier), (a *= e.sizeMultiplier);
				var l;
				if (
					(r.left === "."
						? (l = ir(e, ["mopen"]))
						: (l = _t.leftRightDelim(r.left, n, a, e, r.mode, ["mopen"])),
					t.unshift(l),
					i)
				)
					for (var u = 1; u < t.length; u++) {
						var d = t[u],
							p = d.isMiddle;
						p && (t[u] = _t.leftRightDelim(p.delim, n, a, p.options, r.mode, []));
					}
				var f;
				if (r.right === ".") f = ir(e, ["mclose"]);
				else {
					var v = r.rightColor ? e.withColor(r.rightColor) : e;
					f = _t.leftRightDelim(r.right, n, a, v, r.mode, ["mclose"]);
				}
				return t.push(f), k.makeSpan(["minner"], t, e);
			},
			mathmlBuilder: (r, e) => {
				ga(r);
				var t = We(r.body, e);
				if (r.left !== ".") {
					var n = new z.MathNode("mo", [rt(r.left, r.mode)]);
					n.setAttribute("fence", "true"), t.unshift(n);
				}
				if (r.right !== ".") {
					var a = new z.MathNode("mo", [rt(r.right, r.mode)]);
					a.setAttribute("fence", "true"),
						r.rightColor && a.setAttribute("mathcolor", r.rightColor),
						t.push(a);
				}
				return A0(t);
			},
		}),
		B({
			type: "middle",
			names: ["\\middle"],
			props: { numArgs: 1, primitive: !0 },
			handler: (r, e) => {
				var t = Hr(e[0], r);
				if (!r.parser.leftrightDepth) throw new A("\\middle without preceding \\left", t);
				return { type: "middle", mode: r.parser.mode, delim: t.text };
			},
			htmlBuilder: (r, e) => {
				var t;
				if (r.delim === ".") t = ir(e, []);
				else {
					t = _t.sizedDelim(r.delim, 1, e, r.mode, []);
					var n = { delim: r.delim, options: e };
					t.isMiddle = n;
				}
				return t;
			},
			mathmlBuilder: (r, e) => {
				var t = r.delim === "\\vert" || r.delim === "|" ? rt("|", "text") : rt(r.delim, r.mode),
					n = new z.MathNode("mo", [t]);
				return (
					n.setAttribute("fence", "true"),
					n.setAttribute("lspace", "0.05em"),
					n.setAttribute("rspace", "0.05em"),
					n
				);
			},
		});
	var F0 = (r, e) => {
			var t = k.wrapFragment(oe(r.body, e), e),
				n = r.label.slice(1),
				a = e.sizeMultiplier,
				i,
				s = 0,
				l = V.isCharacterBox(r.body);
			if (n === "sout")
				(i = k.makeSpan(["stretchy", "sout"])),
					(i.height = e.fontMetrics().defaultRuleThickness / a),
					(s = -0.5 * e.fontMetrics().xHeight);
			else if (n === "phase") {
				var u = ke({ number: 0.6, unit: "pt" }, e),
					d = ke({ number: 0.35, unit: "ex" }, e),
					p = e.havingBaseSizing();
				a = a / p.sizeMultiplier;
				var f = t.height + t.depth + u + d;
				t.style.paddingLeft = R(f / 2 + u);
				var v = Math.floor(1e3 * f * a),
					x = Ss(v),
					_ = new vt([new At("phase", x)], {
						width: "400em",
						height: R(v / 1e3),
						viewBox: "0 0 400000 " + v,
						preserveAspectRatio: "xMinYMin slice",
					});
				(i = k.makeSvgSpan(["hide-tail"], [_], e)), (i.style.height = R(f)), (s = t.depth + u + d);
			} else {
				/cancel/.test(n)
					? l || t.classes.push("cancel-pad")
					: n === "angl"
						? t.classes.push("anglpad")
						: t.classes.push("boxpad");
				var S = 0,
					M = 0,
					O = 0;
				/box/.test(n)
					? ((O = Math.max(e.fontMetrics().fboxrule, e.minRuleThickness)),
						(S = e.fontMetrics().fboxsep + (n === "colorbox" ? 0 : O)),
						(M = S))
					: n === "angl"
						? ((O = Math.max(e.fontMetrics().defaultRuleThickness, e.minRuleThickness)),
							(S = 4 * O),
							(M = Math.max(0, 0.25 - t.depth)))
						: ((S = l ? 0.2 : 0), (M = S)),
					(i = kt.encloseSpan(t, n, S, M, e)),
					/fbox|boxed|fcolorbox/.test(n)
						? ((i.style.borderStyle = "solid"), (i.style.borderWidth = R(O)))
						: n === "angl" &&
							O !== 0.049 &&
							((i.style.borderTopWidth = R(O)), (i.style.borderRightWidth = R(O))),
					(s = t.depth + M),
					r.backgroundColor &&
						((i.style.backgroundColor = r.backgroundColor),
						r.borderColor && (i.style.borderColor = r.borderColor));
			}
			var I;
			if (r.backgroundColor)
				I = k.makeVList(
					{
						positionType: "individualShift",
						children: [
							{ type: "elem", elem: i, shift: s },
							{ type: "elem", elem: t, shift: 0 },
						],
					},
					e
				);
			else {
				var $ = /cancel|phase/.test(n) ? ["svg-align"] : [];
				I = k.makeVList(
					{
						positionType: "individualShift",
						children: [
							{ type: "elem", elem: t, shift: 0 },
							{ type: "elem", elem: i, shift: s, wrapperClasses: $ },
						],
					},
					e
				);
			}
			return (
				/cancel/.test(n) && ((I.height = t.height), (I.depth = t.depth)),
				/cancel/.test(n) && !l
					? k.makeSpan(["mord", "cancel-lap"], [I], e)
					: k.makeSpan(["mord"], [I], e)
			);
		},
		H0 = (r, e) => {
			var t = 0,
				n = new z.MathNode(r.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [
					me(r.body, e),
				]);
			switch (r.label) {
				case "\\cancel":
					n.setAttribute("notation", "updiagonalstrike");
					break;
				case "\\bcancel":
					n.setAttribute("notation", "downdiagonalstrike");
					break;
				case "\\phase":
					n.setAttribute("notation", "phasorangle");
					break;
				case "\\sout":
					n.setAttribute("notation", "horizontalstrike");
					break;
				case "\\fbox":
					n.setAttribute("notation", "box");
					break;
				case "\\angl":
					n.setAttribute("notation", "actuarial");
					break;
				case "\\fcolorbox":
				case "\\colorbox":
					if (
						((t = e.fontMetrics().fboxsep * e.fontMetrics().ptPerEm),
						n.setAttribute("width", "+" + 2 * t + "pt"),
						n.setAttribute("height", "+" + 2 * t + "pt"),
						n.setAttribute("lspace", t + "pt"),
						n.setAttribute("voffset", t + "pt"),
						r.label === "\\fcolorbox")
					) {
						var a = Math.max(e.fontMetrics().fboxrule, e.minRuleThickness);
						n.setAttribute("style", "border: " + a + "em solid " + String(r.borderColor));
					}
					break;
				case "\\xcancel":
					n.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
					break;
			}
			return r.backgroundColor && n.setAttribute("mathbackground", r.backgroundColor), n;
		};
	B({
		type: "enclose",
		names: ["\\colorbox"],
		props: { numArgs: 2, allowedInText: !0, argTypes: ["color", "text"] },
		handler(r, e, t) {
			var { parser: n, funcName: a } = r,
				i = re(e[0], "color-token").color,
				s = e[1];
			return { type: "enclose", mode: n.mode, label: a, backgroundColor: i, body: s };
		},
		htmlBuilder: F0,
		mathmlBuilder: H0,
	}),
		B({
			type: "enclose",
			names: ["\\fcolorbox"],
			props: { numArgs: 3, allowedInText: !0, argTypes: ["color", "color", "text"] },
			handler(r, e, t) {
				var { parser: n, funcName: a } = r,
					i = re(e[0], "color-token").color,
					s = re(e[1], "color-token").color,
					l = e[2];
				return {
					type: "enclose",
					mode: n.mode,
					label: a,
					backgroundColor: s,
					borderColor: i,
					body: l,
				};
			},
			htmlBuilder: F0,
			mathmlBuilder: H0,
		}),
		B({
			type: "enclose",
			names: ["\\fbox"],
			props: { numArgs: 1, argTypes: ["hbox"], allowedInText: !0 },
			handler(r, e) {
				var { parser: t } = r;
				return { type: "enclose", mode: t.mode, label: "\\fbox", body: e[0] };
			},
		}),
		B({
			type: "enclose",
			names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
			props: { numArgs: 1 },
			handler(r, e) {
				var { parser: t, funcName: n } = r,
					a = e[0];
				return { type: "enclose", mode: t.mode, label: n, body: a };
			},
			htmlBuilder: F0,
			mathmlBuilder: H0,
		}),
		B({
			type: "enclose",
			names: ["\\angl"],
			props: { numArgs: 1, argTypes: ["hbox"], allowedInText: !1 },
			handler(r, e) {
				var { parser: t } = r;
				return { type: "enclose", mode: t.mode, label: "\\angl", body: e[0] };
			},
		});
	var ba = {};
	function ut(r) {
		for (
			var { type: e, names: t, props: n, handler: a, htmlBuilder: i, mathmlBuilder: s } = r,
				l = { type: e, numArgs: n.numArgs || 0, allowedInText: !1, numOptionalArgs: 0, handler: a },
				u = 0;
			u < t.length;
			++u
		)
			ba[t[u]] = l;
		i && (Ir[e] = i), s && (Dr[e] = s);
	}
	var va = {};
	function m(r, e) {
		va[r] = e;
	}
	function ya(r) {
		var e = [];
		r.consumeSpaces();
		var t = r.fetch().text;
		for (
			t === "\\relax" && (r.consume(), r.consumeSpaces(), (t = r.fetch().text));
			t === "\\hline" || t === "\\hdashline";

		)
			r.consume(), e.push(t === "\\hdashline"), r.consumeSpaces(), (t = r.fetch().text);
		return e;
	}
	var Ur = (r) => {
		var e = r.parser.settings;
		if (!e.displayMode) throw new A("{" + r.envName + "} can be used only in display mode.");
	};
	function U0(r) {
		if (r.indexOf("ed") === -1) return r.indexOf("*") === -1;
	}
	function zt(r, e, t) {
		var {
			hskipBeforeAndAfter: n,
			addJot: a,
			cols: i,
			arraystretch: s,
			colSeparationType: l,
			autoTag: u,
			singleRow: d,
			emptySingleRow: p,
			maxNumCols: f,
			leqno: v,
		} = e;
		if ((r.gullet.beginGroup(), d || r.gullet.macros.set("\\cr", "\\\\\\relax"), !s)) {
			var x = r.gullet.expandMacroAsText("\\arraystretch");
			if (x == null) s = 1;
			else if (((s = parseFloat(x)), !s || s < 0)) throw new A("Invalid \\arraystretch: " + x);
		}
		r.gullet.beginGroup();
		var _ = [],
			S = [_],
			M = [],
			O = [],
			I = u != null ? [] : void 0;
		function $() {
			u && r.gullet.macros.set("\\@eqnsw", "1", !0);
		}
		function P() {
			I &&
				(r.gullet.macros.get("\\df@tag")
					? (I.push(r.subparse([new ce("\\df@tag")])), r.gullet.macros.set("\\df@tag", void 0, !0))
					: I.push(!!u && r.gullet.macros.get("\\@eqnsw") === "1"));
		}
		for ($(), O.push(ya(r)); ; ) {
			var q = r.parseExpression(!1, d ? "\\end" : "\\\\");
			r.gullet.endGroup(),
				r.gullet.beginGroup(),
				(q = { type: "ordgroup", mode: r.mode, body: q }),
				t && (q = { type: "styling", mode: r.mode, style: t, body: [q] }),
				_.push(q);
			var U = r.fetch().text;
			if (U === "&") {
				if (f && _.length === f) {
					if (d || l) throw new A("Too many tab characters: &", r.nextToken);
					r.settings.reportNonstrict(
						"textEnv",
						"Too few columns specified in the {array} column argument."
					);
				}
				r.consume();
			} else if (U === "\\end") {
				P(),
					_.length === 1 &&
						q.type === "styling" &&
						q.body[0].body.length === 0 &&
						(S.length > 1 || !p) &&
						S.pop(),
					O.length < S.length + 1 && O.push([]);
				break;
			} else if (U === "\\\\") {
				r.consume();
				var Q = void 0;
				r.gullet.future().text !== " " && (Q = r.parseSizeGroup(!0)),
					M.push(Q ? Q.value : null),
					P(),
					O.push(ya(r)),
					(_ = []),
					S.push(_),
					$();
			} else throw new A("Expected & or \\\\ or \\cr or \\end", r.nextToken);
		}
		return (
			r.gullet.endGroup(),
			r.gullet.endGroup(),
			{
				type: "array",
				mode: r.mode,
				addJot: a,
				arraystretch: s,
				body: S,
				cols: i,
				rowGaps: M,
				hskipBeforeAndAfter: n,
				hLinesBeforeRow: O,
				colSeparationType: l,
				tags: I,
				leqno: v,
			}
		);
	}
	function G0(r) {
		return r.slice(0, 1) === "d" ? "display" : "text";
	}
	var ht = function (e, t) {
			var n,
				a,
				i = e.body.length,
				s = e.hLinesBeforeRow,
				l = 0,
				u = new Array(i),
				d = [],
				p = Math.max(t.fontMetrics().arrayRuleWidth, t.minRuleThickness),
				f = 1 / t.fontMetrics().ptPerEm,
				v = 5 * f;
			if (e.colSeparationType && e.colSeparationType === "small") {
				var x = t.havingStyle(Z.SCRIPT).sizeMultiplier;
				v = 0.2778 * (x / t.sizeMultiplier);
			}
			var _ = e.colSeparationType === "CD" ? ke({ number: 3, unit: "ex" }, t) : 12 * f,
				S = 3 * f,
				M = e.arraystretch * _,
				O = 0.7 * M,
				I = 0.3 * M,
				$ = 0;
			function P(Jt) {
				for (var jt = 0; jt < Jt.length; ++jt)
					jt > 0 && ($ += 0.25), d.push({ pos: $, isDashed: Jt[jt] });
			}
			for (P(s[0]), n = 0; n < e.body.length; ++n) {
				var q = e.body[n],
					U = O,
					Q = I;
				l < q.length && (l = q.length);
				var ne = new Array(q.length);
				for (a = 0; a < q.length; ++a) {
					var te = oe(q[a], t);
					Q < te.depth && (Q = te.depth), U < te.height && (U = te.height), (ne[a] = te);
				}
				var Pe = e.rowGaps[n],
					Ee = 0;
				Pe && ((Ee = ke(Pe, t)), Ee > 0 && ((Ee += I), Q < Ee && (Q = Ee), (Ee = 0))),
					e.addJot && (Q += S),
					(ne.height = U),
					(ne.depth = Q),
					($ += U),
					(ne.pos = $),
					($ += Q + Ee),
					(u[n] = ne),
					P(s[n + 1]);
			}
			var ve = $ / 2 + t.fontMetrics().axisHeight,
				Qe = e.cols || [],
				we = [],
				$e,
				Fe,
				nt = [];
			if (e.tags && e.tags.some((Jt) => Jt))
				for (n = 0; n < i; ++n) {
					var ie = u[n],
						De = ie.pos - ve,
						Te = e.tags[n],
						Ce = void 0;
					Te === !0
						? (Ce = k.makeSpan(["eqn-num"], [], t))
						: Te === !1
							? (Ce = k.makeSpan([], [], t))
							: (Ce = k.makeSpan([], Ie(Te, t, !0), t)),
						(Ce.depth = ie.depth),
						(Ce.height = ie.height),
						nt.push({ type: "elem", elem: Ce, shift: De });
				}
			for (a = 0, Fe = 0; a < l || Fe < Qe.length; ++a, ++Fe) {
				for (var Me = Qe[Fe] || {}, Je = !0; Me.type === "separator"; ) {
					if (
						(Je ||
							(($e = k.makeSpan(["arraycolsep"], [])),
							($e.style.width = R(t.fontMetrics().doubleRuleSep)),
							we.push($e)),
						Me.separator === "|" || Me.separator === ":")
					) {
						var vr = Me.separator === "|" ? "solid" : "dashed",
							Rt = k.makeSpan(["vertical-separator"], [], t);
						(Rt.style.height = R($)),
							(Rt.style.borderRightWidth = R(p)),
							(Rt.style.borderRightStyle = vr),
							(Rt.style.margin = "0 " + R(-p / 2));
						var r0 = $ - ve;
						r0 && (Rt.style.verticalAlign = R(-r0)), we.push(Rt);
					} else throw new A("Invalid separator type: " + Me.separator);
					Fe++, (Me = Qe[Fe] || {}), (Je = !1);
				}
				if (!(a >= l)) {
					var It = void 0;
					(a > 0 || e.hskipBeforeAndAfter) &&
						((It = V.deflt(Me.pregap, v)),
						It !== 0 &&
							(($e = k.makeSpan(["arraycolsep"], [])), ($e.style.width = R(It)), we.push($e)));
					var Dt = [];
					for (n = 0; n < i; ++n) {
						var yr = u[n],
							St = yr[a];
						if (St) {
							var mn = yr.pos - ve;
							(St.depth = yr.depth),
								(St.height = yr.height),
								Dt.push({ type: "elem", elem: St, shift: mn });
						}
					}
					(Dt = k.makeVList({ positionType: "individualShift", children: Dt }, t)),
						(Dt = k.makeSpan(["col-align-" + (Me.align || "c")], [Dt])),
						we.push(Dt),
						(a < l - 1 || e.hskipBeforeAndAfter) &&
							((It = V.deflt(Me.postgap, v)),
							It !== 0 &&
								(($e = k.makeSpan(["arraycolsep"], [])), ($e.style.width = R(It)), we.push($e)));
				}
			}
			if (((u = k.makeSpan(["mtable"], we)), d.length > 0)) {
				for (
					var pn = k.makeLineSpan("hline", t, p),
						fn = k.makeLineSpan("hdashline", t, p),
						xr = [{ type: "elem", elem: u, shift: 0 }];
					d.length > 0;

				) {
					var n0 = d.pop(),
						a0 = n0.pos - ve;
					n0.isDashed
						? xr.push({ type: "elem", elem: fn, shift: a0 })
						: xr.push({ type: "elem", elem: pn, shift: a0 });
				}
				u = k.makeVList({ positionType: "individualShift", children: xr }, t);
			}
			if (nt.length === 0) return k.makeSpan(["mord"], [u], t);
			var wr = k.makeVList({ positionType: "individualShift", children: nt }, t);
			return (wr = k.makeSpan(["tag"], [wr], t)), k.makeFragment([u, wr]);
		},
		Io = { c: "center ", l: "left ", r: "right " },
		dt = function (e, t) {
			for (
				var n = [],
					a = new z.MathNode("mtd", [], ["mtr-glue"]),
					i = new z.MathNode("mtd", [], ["mml-eqn-num"]),
					s = 0;
				s < e.body.length;
				s++
			) {
				for (var l = e.body[s], u = [], d = 0; d < l.length; d++)
					u.push(new z.MathNode("mtd", [me(l[d], t)]));
				e.tags && e.tags[s] && (u.unshift(a), u.push(a), e.leqno ? u.unshift(i) : u.push(i)),
					n.push(new z.MathNode("mtr", u));
			}
			var p = new z.MathNode("mtable", n),
				f = e.arraystretch === 0.5 ? 0.1 : 0.16 + e.arraystretch - 1 + (e.addJot ? 0.09 : 0);
			p.setAttribute("rowspacing", R(f));
			var v = "",
				x = "";
			if (e.cols && e.cols.length > 0) {
				var _ = e.cols,
					S = "",
					M = !1,
					O = 0,
					I = _.length;
				_[0].type === "separator" && ((v += "top "), (O = 1)),
					_[_.length - 1].type === "separator" && ((v += "bottom "), (I -= 1));
				for (var $ = O; $ < I; $++)
					_[$].type === "align"
						? ((x += Io[_[$].align]), M && (S += "none "), (M = !0))
						: _[$].type === "separator" &&
							M &&
							((S += _[$].separator === "|" ? "solid " : "dashed "), (M = !1));
				p.setAttribute("columnalign", x.trim()),
					/[sd]/.test(S) && p.setAttribute("columnlines", S.trim());
			}
			if (e.colSeparationType === "align") {
				for (var P = e.cols || [], q = "", U = 1; U < P.length; U++) q += U % 2 ? "0em " : "1em ";
				p.setAttribute("columnspacing", q.trim());
			} else
				e.colSeparationType === "alignat" || e.colSeparationType === "gather"
					? p.setAttribute("columnspacing", "0em")
					: e.colSeparationType === "small"
						? p.setAttribute("columnspacing", "0.2778em")
						: e.colSeparationType === "CD"
							? p.setAttribute("columnspacing", "0.5em")
							: p.setAttribute("columnspacing", "1em");
			var Q = "",
				ne = e.hLinesBeforeRow;
			(v += ne[0].length > 0 ? "left " : ""), (v += ne[ne.length - 1].length > 0 ? "right " : "");
			for (var te = 1; te < ne.length - 1; te++)
				Q += ne[te].length === 0 ? "none " : ne[te][0] ? "dashed " : "solid ";
			return (
				/[sd]/.test(Q) && p.setAttribute("rowlines", Q.trim()),
				v !== "" && ((p = new z.MathNode("menclose", [p])), p.setAttribute("notation", v.trim())),
				e.arraystretch &&
					e.arraystretch < 1 &&
					((p = new z.MathNode("mstyle", [p])), p.setAttribute("scriptlevel", "1")),
				p
			);
		},
		xa = function (e, t) {
			e.envName.indexOf("ed") === -1 && Ur(e);
			var n = [],
				a = e.envName.indexOf("at") > -1 ? "alignat" : "align",
				i = e.envName === "split",
				s = zt(
					e.parser,
					{
						cols: n,
						addJot: !0,
						autoTag: i ? void 0 : U0(e.envName),
						emptySingleRow: !0,
						colSeparationType: a,
						maxNumCols: i ? 2 : void 0,
						leqno: e.parser.settings.leqno,
					},
					"display"
				),
				l,
				u = 0,
				d = { type: "ordgroup", mode: e.mode, body: [] };
			if (t[0] && t[0].type === "ordgroup") {
				for (var p = "", f = 0; f < t[0].body.length; f++) {
					var v = re(t[0].body[f], "textord");
					p += v.text;
				}
				(l = Number(p)), (u = l * 2);
			}
			var x = !u;
			s.body.forEach(function (O) {
				for (var I = 1; I < O.length; I += 2) {
					var $ = re(O[I], "styling"),
						P = re($.body[0], "ordgroup");
					P.body.unshift(d);
				}
				if (x) u < O.length && (u = O.length);
				else {
					var q = O.length / 2;
					if (l < q)
						throw new A("Too many math in a row: " + ("expected " + l + ", but got " + q), O[0]);
				}
			});
			for (var _ = 0; _ < u; ++_) {
				var S = "r",
					M = 0;
				_ % 2 === 1 ? (S = "l") : _ > 0 && x && (M = 1),
					(n[_] = { type: "align", align: S, pregap: M, postgap: 0 });
			}
			return (s.colSeparationType = x ? "align" : "alignat"), s;
		};
	ut({
		type: "array",
		names: ["array", "darray"],
		props: { numArgs: 1 },
		handler(r, e) {
			var t = $r(e[0]),
				n = t ? [e[0]] : re(e[0], "ordgroup").body,
				a = n.map(function (s) {
					var l = z0(s),
						u = l.text;
					if ("lcr".indexOf(u) !== -1) return { type: "align", align: u };
					if (u === "|") return { type: "separator", separator: "|" };
					if (u === ":") return { type: "separator", separator: ":" };
					throw new A("Unknown column alignment: " + u, s);
				}),
				i = { cols: a, hskipBeforeAndAfter: !0, maxNumCols: a.length };
			return zt(r.parser, i, G0(r.envName));
		},
		htmlBuilder: ht,
		mathmlBuilder: dt,
	}),
		ut({
			type: "array",
			names: [
				"matrix",
				"pmatrix",
				"bmatrix",
				"Bmatrix",
				"vmatrix",
				"Vmatrix",
				"matrix*",
				"pmatrix*",
				"bmatrix*",
				"Bmatrix*",
				"vmatrix*",
				"Vmatrix*",
			],
			props: { numArgs: 0 },
			handler(r) {
				var e = {
						matrix: null,
						pmatrix: ["(", ")"],
						bmatrix: ["[", "]"],
						Bmatrix: ["\\{", "\\}"],
						vmatrix: ["|", "|"],
						Vmatrix: ["\\Vert", "\\Vert"],
					}[r.envName.replace("*", "")],
					t = "c",
					n = { hskipBeforeAndAfter: !1, cols: [{ type: "align", align: t }] };
				if (r.envName.charAt(r.envName.length - 1) === "*") {
					var a = r.parser;
					if ((a.consumeSpaces(), a.fetch().text === "[")) {
						if ((a.consume(), a.consumeSpaces(), (t = a.fetch().text), "lcr".indexOf(t) === -1))
							throw new A("Expected l or c or r", a.nextToken);
						a.consume(),
							a.consumeSpaces(),
							a.expect("]"),
							a.consume(),
							(n.cols = [{ type: "align", align: t }]);
					}
				}
				var i = zt(r.parser, n, G0(r.envName)),
					s = Math.max(0, ...i.body.map((l) => l.length));
				return (
					(i.cols = new Array(s).fill({ type: "align", align: t })),
					e
						? {
								type: "leftright",
								mode: r.mode,
								body: [i],
								left: e[0],
								right: e[1],
								rightColor: void 0,
							}
						: i
				);
			},
			htmlBuilder: ht,
			mathmlBuilder: dt,
		}),
		ut({
			type: "array",
			names: ["smallmatrix"],
			props: { numArgs: 0 },
			handler(r) {
				var e = { arraystretch: 0.5 },
					t = zt(r.parser, e, "script");
				return (t.colSeparationType = "small"), t;
			},
			htmlBuilder: ht,
			mathmlBuilder: dt,
		}),
		ut({
			type: "array",
			names: ["subarray"],
			props: { numArgs: 1 },
			handler(r, e) {
				var t = $r(e[0]),
					n = t ? [e[0]] : re(e[0], "ordgroup").body,
					a = n.map(function (s) {
						var l = z0(s),
							u = l.text;
						if ("lc".indexOf(u) !== -1) return { type: "align", align: u };
						throw new A("Unknown column alignment: " + u, s);
					});
				if (a.length > 1) throw new A("{subarray} can contain only one column");
				var i = { cols: a, hskipBeforeAndAfter: !1, arraystretch: 0.5 };
				if (((i = zt(r.parser, i, "script")), i.body.length > 0 && i.body[0].length > 1))
					throw new A("{subarray} can contain only one column");
				return i;
			},
			htmlBuilder: ht,
			mathmlBuilder: dt,
		}),
		ut({
			type: "array",
			names: ["cases", "dcases", "rcases", "drcases"],
			props: { numArgs: 0 },
			handler(r) {
				var e = {
						arraystretch: 1.2,
						cols: [
							{ type: "align", align: "l", pregap: 0, postgap: 1 },
							{ type: "align", align: "l", pregap: 0, postgap: 0 },
						],
					},
					t = zt(r.parser, e, G0(r.envName));
				return {
					type: "leftright",
					mode: r.mode,
					body: [t],
					left: r.envName.indexOf("r") > -1 ? "." : "\\{",
					right: r.envName.indexOf("r") > -1 ? "\\}" : ".",
					rightColor: void 0,
				};
			},
			htmlBuilder: ht,
			mathmlBuilder: dt,
		}),
		ut({
			type: "array",
			names: ["align", "align*", "aligned", "split"],
			props: { numArgs: 0 },
			handler: xa,
			htmlBuilder: ht,
			mathmlBuilder: dt,
		}),
		ut({
			type: "array",
			names: ["gathered", "gather", "gather*"],
			props: { numArgs: 0 },
			handler(r) {
				V.contains(["gather", "gather*"], r.envName) && Ur(r);
				var e = {
					cols: [{ type: "align", align: "c" }],
					addJot: !0,
					colSeparationType: "gather",
					autoTag: U0(r.envName),
					emptySingleRow: !0,
					leqno: r.parser.settings.leqno,
				};
				return zt(r.parser, e, "display");
			},
			htmlBuilder: ht,
			mathmlBuilder: dt,
		}),
		ut({
			type: "array",
			names: ["alignat", "alignat*", "alignedat"],
			props: { numArgs: 1 },
			handler: xa,
			htmlBuilder: ht,
			mathmlBuilder: dt,
		}),
		ut({
			type: "array",
			names: ["equation", "equation*"],
			props: { numArgs: 0 },
			handler(r) {
				Ur(r);
				var e = {
					autoTag: U0(r.envName),
					emptySingleRow: !0,
					singleRow: !0,
					maxNumCols: 1,
					leqno: r.parser.settings.leqno,
				};
				return zt(r.parser, e, "display");
			},
			htmlBuilder: ht,
			mathmlBuilder: dt,
		}),
		ut({
			type: "array",
			names: ["CD"],
			props: { numArgs: 0 },
			handler(r) {
				return Ur(r), xo(r.parser);
			},
			htmlBuilder: ht,
			mathmlBuilder: dt,
		}),
		m("\\nonumber", "\\gdef\\@eqnsw{0}"),
		m("\\notag", "\\nonumber"),
		B({
			type: "text",
			names: ["\\hline", "\\hdashline"],
			props: { numArgs: 0, allowedInText: !0, allowedInMath: !0 },
			handler(r, e) {
				throw new A(r.funcName + " valid only within array environment");
			},
		});
	var wa = ba;
	B({
		type: "environment",
		names: ["\\begin", "\\end"],
		props: { numArgs: 1, argTypes: ["text"] },
		handler(r, e) {
			var { parser: t, funcName: n } = r,
				a = e[0];
			if (a.type !== "ordgroup") throw new A("Invalid environment name", a);
			for (var i = "", s = 0; s < a.body.length; ++s) i += re(a.body[s], "textord").text;
			if (n === "\\begin") {
				if (!wa.hasOwnProperty(i)) throw new A("No such environment: " + i, a);
				var l = wa[i],
					{ args: u, optArgs: d } = t.parseArguments("\\begin{" + i + "}", l),
					p = { mode: t.mode, envName: i, parser: t },
					f = l.handler(p, u, d);
				t.expect("\\end", !1);
				var v = t.nextToken,
					x = re(t.parseFunction(), "environment");
				if (x.name !== i)
					throw new A("Mismatch: \\begin{" + i + "} matched by \\end{" + x.name + "}", v);
				return f;
			}
			return { type: "environment", mode: t.mode, name: i, nameGroup: a };
		},
	});
	var ka = (r, e) => {
			var t = r.font,
				n = e.withFont(t);
			return oe(r.body, n);
		},
		_a = (r, e) => {
			var t = r.font,
				n = e.withFont(t);
			return me(r.body, n);
		},
		Sa = {
			"\\Bbb": "\\mathbb",
			"\\bold": "\\mathbf",
			"\\frak": "\\mathfrak",
			"\\bm": "\\boldsymbol",
		};
	B({
		type: "font",
		names: [
			"\\mathrm",
			"\\mathit",
			"\\mathbf",
			"\\mathnormal",
			"\\mathsfit",
			"\\mathbb",
			"\\mathcal",
			"\\mathfrak",
			"\\mathscr",
			"\\mathsf",
			"\\mathtt",
			"\\Bbb",
			"\\bold",
			"\\frak",
		],
		props: { numArgs: 1, allowedInArgument: !0 },
		handler: (r, e) => {
			var { parser: t, funcName: n } = r,
				a = Br(e[0]),
				i = n;
			return i in Sa && (i = Sa[i]), { type: "font", mode: t.mode, font: i.slice(1), body: a };
		},
		htmlBuilder: ka,
		mathmlBuilder: _a,
	}),
		B({
			type: "mclass",
			names: ["\\boldsymbol", "\\bm"],
			props: { numArgs: 1 },
			handler: (r, e) => {
				var { parser: t } = r,
					n = e[0],
					a = V.isCharacterBox(n);
				return {
					type: "mclass",
					mode: t.mode,
					mclass: Pr(n),
					body: [{ type: "font", mode: t.mode, font: "boldsymbol", body: n }],
					isCharacterBox: a,
				};
			},
		}),
		B({
			type: "font",
			names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
			props: { numArgs: 0, allowedInText: !0 },
			handler: (r, e) => {
				var { parser: t, funcName: n, breakOnTokenText: a } = r,
					{ mode: i } = t,
					s = t.parseExpression(!0, a),
					l = "math" + n.slice(1);
				return {
					type: "font",
					mode: i,
					font: l,
					body: { type: "ordgroup", mode: t.mode, body: s },
				};
			},
			htmlBuilder: ka,
			mathmlBuilder: _a,
		});
	var Ea = (r, e) => {
			var t = e;
			return (
				r === "display"
					? (t = t.id >= Z.SCRIPT.id ? t.text() : Z.DISPLAY)
					: r === "text" && t.size === Z.DISPLAY.size
						? (t = Z.TEXT)
						: r === "script"
							? (t = Z.SCRIPT)
							: r === "scriptscript" && (t = Z.SCRIPTSCRIPT),
				t
			);
		},
		K0 = (r, e) => {
			var t = Ea(r.size, e.style),
				n = t.fracNum(),
				a = t.fracDen(),
				i;
			i = e.havingStyle(n);
			var s = oe(r.numer, i, e);
			if (r.continued) {
				var l = 8.5 / e.fontMetrics().ptPerEm,
					u = 3.5 / e.fontMetrics().ptPerEm;
				(s.height = s.height < l ? l : s.height), (s.depth = s.depth < u ? u : s.depth);
			}
			i = e.havingStyle(a);
			var d = oe(r.denom, i, e),
				p,
				f,
				v;
			r.hasBarLine
				? (r.barSize
						? ((f = ke(r.barSize, e)), (p = k.makeLineSpan("frac-line", e, f)))
						: (p = k.makeLineSpan("frac-line", e)),
					(f = p.height),
					(v = p.height))
				: ((p = null), (f = 0), (v = e.fontMetrics().defaultRuleThickness));
			var x, _, S;
			t.size === Z.DISPLAY.size || r.size === "display"
				? ((x = e.fontMetrics().num1),
					f > 0 ? (_ = 3 * v) : (_ = 7 * v),
					(S = e.fontMetrics().denom1))
				: (f > 0
						? ((x = e.fontMetrics().num2), (_ = v))
						: ((x = e.fontMetrics().num3), (_ = 3 * v)),
					(S = e.fontMetrics().denom2));
			var M;
			if (p) {
				var I = e.fontMetrics().axisHeight;
				x - s.depth - (I + 0.5 * f) < _ && (x += _ - (x - s.depth - (I + 0.5 * f))),
					I - 0.5 * f - (d.height - S) < _ && (S += _ - (I - 0.5 * f - (d.height - S)));
				var $ = -(I - 0.5 * f);
				M = k.makeVList(
					{
						positionType: "individualShift",
						children: [
							{ type: "elem", elem: d, shift: S },
							{ type: "elem", elem: p, shift: $ },
							{ type: "elem", elem: s, shift: -x },
						],
					},
					e
				);
			} else {
				var O = x - s.depth - (d.height - S);
				O < _ && ((x += 0.5 * (_ - O)), (S += 0.5 * (_ - O))),
					(M = k.makeVList(
						{
							positionType: "individualShift",
							children: [
								{ type: "elem", elem: d, shift: S },
								{ type: "elem", elem: s, shift: -x },
							],
						},
						e
					));
			}
			(i = e.havingStyle(t)),
				(M.height *= i.sizeMultiplier / e.sizeMultiplier),
				(M.depth *= i.sizeMultiplier / e.sizeMultiplier);
			var P;
			t.size === Z.DISPLAY.size
				? (P = e.fontMetrics().delim1)
				: t.size === Z.SCRIPTSCRIPT.size
					? (P = e.havingStyle(Z.SCRIPT).fontMetrics().delim2)
					: (P = e.fontMetrics().delim2);
			var q, U;
			return (
				r.leftDelim == null
					? (q = ir(e, ["mopen"]))
					: (q = _t.customSizedDelim(r.leftDelim, P, !0, e.havingStyle(t), r.mode, ["mopen"])),
				r.continued
					? (U = k.makeSpan([]))
					: r.rightDelim == null
						? (U = ir(e, ["mclose"]))
						: (U = _t.customSizedDelim(r.rightDelim, P, !0, e.havingStyle(t), r.mode, ["mclose"])),
				k.makeSpan(["mord"].concat(i.sizingClasses(e)), [q, k.makeSpan(["mfrac"], [M]), U], e)
			);
		},
		V0 = (r, e) => {
			var t = new z.MathNode("mfrac", [me(r.numer, e), me(r.denom, e)]);
			if (!r.hasBarLine) t.setAttribute("linethickness", "0px");
			else if (r.barSize) {
				var n = ke(r.barSize, e);
				t.setAttribute("linethickness", R(n));
			}
			var a = Ea(r.size, e.style);
			if (a.size !== e.style.size) {
				t = new z.MathNode("mstyle", [t]);
				var i = a.size === Z.DISPLAY.size ? "true" : "false";
				t.setAttribute("displaystyle", i), t.setAttribute("scriptlevel", "0");
			}
			if (r.leftDelim != null || r.rightDelim != null) {
				var s = [];
				if (r.leftDelim != null) {
					var l = new z.MathNode("mo", [new z.TextNode(r.leftDelim.replace("\\", ""))]);
					l.setAttribute("fence", "true"), s.push(l);
				}
				if ((s.push(t), r.rightDelim != null)) {
					var u = new z.MathNode("mo", [new z.TextNode(r.rightDelim.replace("\\", ""))]);
					u.setAttribute("fence", "true"), s.push(u);
				}
				return A0(s);
			}
			return t;
		};
	B({
		type: "genfrac",
		names: [
			"\\dfrac",
			"\\frac",
			"\\tfrac",
			"\\dbinom",
			"\\binom",
			"\\tbinom",
			"\\\\atopfrac",
			"\\\\bracefrac",
			"\\\\brackfrac",
		],
		props: { numArgs: 2, allowedInArgument: !0 },
		handler: (r, e) => {
			var { parser: t, funcName: n } = r,
				a = e[0],
				i = e[1],
				s,
				l = null,
				u = null,
				d = "auto";
			switch (n) {
				case "\\dfrac":
				case "\\frac":
				case "\\tfrac":
					s = !0;
					break;
				case "\\\\atopfrac":
					s = !1;
					break;
				case "\\dbinom":
				case "\\binom":
				case "\\tbinom":
					(s = !1), (l = "("), (u = ")");
					break;
				case "\\\\bracefrac":
					(s = !1), (l = "\\{"), (u = "\\}");
					break;
				case "\\\\brackfrac":
					(s = !1), (l = "["), (u = "]");
					break;
				default:
					throw new Error("Unrecognized genfrac command");
			}
			switch (n) {
				case "\\dfrac":
				case "\\dbinom":
					d = "display";
					break;
				case "\\tfrac":
				case "\\tbinom":
					d = "text";
					break;
			}
			return {
				type: "genfrac",
				mode: t.mode,
				continued: !1,
				numer: a,
				denom: i,
				hasBarLine: s,
				leftDelim: l,
				rightDelim: u,
				size: d,
				barSize: null,
			};
		},
		htmlBuilder: K0,
		mathmlBuilder: V0,
	}),
		B({
			type: "genfrac",
			names: ["\\cfrac"],
			props: { numArgs: 2 },
			handler: (r, e) => {
				var { parser: t, funcName: n } = r,
					a = e[0],
					i = e[1];
				return {
					type: "genfrac",
					mode: t.mode,
					continued: !0,
					numer: a,
					denom: i,
					hasBarLine: !0,
					leftDelim: null,
					rightDelim: null,
					size: "display",
					barSize: null,
				};
			},
		}),
		B({
			type: "infix",
			names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
			props: { numArgs: 0, infix: !0 },
			handler(r) {
				var { parser: e, funcName: t, token: n } = r,
					a;
				switch (t) {
					case "\\over":
						a = "\\frac";
						break;
					case "\\choose":
						a = "\\binom";
						break;
					case "\\atop":
						a = "\\\\atopfrac";
						break;
					case "\\brace":
						a = "\\\\bracefrac";
						break;
					case "\\brack":
						a = "\\\\brackfrac";
						break;
					default:
						throw new Error("Unrecognized infix genfrac command");
				}
				return { type: "infix", mode: e.mode, replaceWith: a, token: n };
			},
		});
	var Ta = ["display", "text", "script", "scriptscript"],
		Ma = function (e) {
			var t = null;
			return e.length > 0 && ((t = e), (t = t === "." ? null : t)), t;
		};
	B({
		type: "genfrac",
		names: ["\\genfrac"],
		props: {
			numArgs: 6,
			allowedInArgument: !0,
			argTypes: ["math", "math", "size", "text", "math", "math"],
		},
		handler(r, e) {
			var { parser: t } = r,
				n = e[4],
				a = e[5],
				i = Br(e[0]),
				s = i.type === "atom" && i.family === "open" ? Ma(i.text) : null,
				l = Br(e[1]),
				u = l.type === "atom" && l.family === "close" ? Ma(l.text) : null,
				d = re(e[2], "size"),
				p,
				f = null;
			d.isBlank ? (p = !0) : ((f = d.value), (p = f.number > 0));
			var v = "auto",
				x = e[3];
			if (x.type === "ordgroup") {
				if (x.body.length > 0) {
					var _ = re(x.body[0], "textord");
					v = Ta[Number(_.text)];
				}
			} else (x = re(x, "textord")), (v = Ta[Number(x.text)]);
			return {
				type: "genfrac",
				mode: t.mode,
				numer: n,
				denom: a,
				continued: !1,
				hasBarLine: p,
				barSize: f,
				leftDelim: s,
				rightDelim: u,
				size: v,
			};
		},
		htmlBuilder: K0,
		mathmlBuilder: V0,
	}),
		B({
			type: "infix",
			names: ["\\above"],
			props: { numArgs: 1, argTypes: ["size"], infix: !0 },
			handler(r, e) {
				var { parser: t, funcName: n, token: a } = r;
				return {
					type: "infix",
					mode: t.mode,
					replaceWith: "\\\\abovefrac",
					size: re(e[0], "size").value,
					token: a,
				};
			},
		}),
		B({
			type: "genfrac",
			names: ["\\\\abovefrac"],
			props: { numArgs: 3, argTypes: ["math", "size", "math"] },
			handler: (r, e) => {
				var { parser: t, funcName: n } = r,
					a = e[0],
					i = cs(re(e[1], "infix").size),
					s = e[2],
					l = i.number > 0;
				return {
					type: "genfrac",
					mode: t.mode,
					numer: a,
					denom: s,
					continued: !1,
					hasBarLine: l,
					barSize: i,
					leftDelim: null,
					rightDelim: null,
					size: "auto",
				};
			},
			htmlBuilder: K0,
			mathmlBuilder: V0,
		});
	var Aa = (r, e) => {
			var t = e.style,
				n,
				a;
			r.type === "supsub"
				? ((n = r.sup
						? oe(r.sup, e.havingStyle(t.sup()), e)
						: oe(r.sub, e.havingStyle(t.sub()), e)),
					(a = re(r.base, "horizBrace")))
				: (a = re(r, "horizBrace"));
			var i = oe(a.base, e.havingBaseStyle(Z.DISPLAY)),
				s = kt.svgSpan(a, e),
				l;
			if (
				(a.isOver
					? ((l = k.makeVList(
							{
								positionType: "firstBaseline",
								children: [
									{ type: "elem", elem: i },
									{ type: "kern", size: 0.1 },
									{ type: "elem", elem: s },
								],
							},
							e
						)),
						l.children[0].children[0].children[1].classes.push("svg-align"))
					: ((l = k.makeVList(
							{
								positionType: "bottom",
								positionData: i.depth + 0.1 + s.height,
								children: [
									{ type: "elem", elem: s },
									{ type: "kern", size: 0.1 },
									{ type: "elem", elem: i },
								],
							},
							e
						)),
						l.children[0].children[0].children[0].classes.push("svg-align")),
				n)
			) {
				var u = k.makeSpan(["mord", a.isOver ? "mover" : "munder"], [l], e);
				a.isOver
					? (l = k.makeVList(
							{
								positionType: "firstBaseline",
								children: [
									{ type: "elem", elem: u },
									{ type: "kern", size: 0.2 },
									{ type: "elem", elem: n },
								],
							},
							e
						))
					: (l = k.makeVList(
							{
								positionType: "bottom",
								positionData: u.depth + 0.2 + n.height + n.depth,
								children: [
									{ type: "elem", elem: n },
									{ type: "kern", size: 0.2 },
									{ type: "elem", elem: u },
								],
							},
							e
						));
			}
			return k.makeSpan(["mord", a.isOver ? "mover" : "munder"], [l], e);
		},
		Do = (r, e) => {
			var t = kt.mathMLnode(r.label);
			return new z.MathNode(r.isOver ? "mover" : "munder", [me(r.base, e), t]);
		};
	B({
		type: "horizBrace",
		names: ["\\overbrace", "\\underbrace"],
		props: { numArgs: 1 },
		handler(r, e) {
			var { parser: t, funcName: n } = r;
			return { type: "horizBrace", mode: t.mode, label: n, isOver: /^\\over/.test(n), base: e[0] };
		},
		htmlBuilder: Aa,
		mathmlBuilder: Do,
	}),
		B({
			type: "href",
			names: ["\\href"],
			props: { numArgs: 2, argTypes: ["url", "original"], allowedInText: !0 },
			handler: (r, e) => {
				var { parser: t } = r,
					n = e[1],
					a = re(e[0], "url").url;
				return t.settings.isTrusted({ command: "\\href", url: a })
					? { type: "href", mode: t.mode, href: a, body: Ae(n) }
					: t.formatUnsupportedCmd("\\href");
			},
			htmlBuilder: (r, e) => {
				var t = Ie(r.body, e, !1);
				return k.makeAnchor(r.href, [], t, e);
			},
			mathmlBuilder: (r, e) => {
				var t = Ot(r.body, e);
				return t instanceof Xe || (t = new Xe("mrow", [t])), t.setAttribute("href", r.href), t;
			},
		}),
		B({
			type: "href",
			names: ["\\url"],
			props: { numArgs: 1, argTypes: ["url"], allowedInText: !0 },
			handler: (r, e) => {
				var { parser: t } = r,
					n = re(e[0], "url").url;
				if (!t.settings.isTrusted({ command: "\\url", url: n }))
					return t.formatUnsupportedCmd("\\url");
				for (var a = [], i = 0; i < n.length; i++) {
					var s = n[i];
					s === "~" && (s = "\\textasciitilde"), a.push({ type: "textord", mode: "text", text: s });
				}
				var l = { type: "text", mode: t.mode, font: "\\texttt", body: a };
				return { type: "href", mode: t.mode, href: n, body: Ae(l) };
			},
		}),
		B({
			type: "hbox",
			names: ["\\hbox"],
			props: { numArgs: 1, argTypes: ["text"], allowedInText: !0, primitive: !0 },
			handler(r, e) {
				var { parser: t } = r;
				return { type: "hbox", mode: t.mode, body: Ae(e[0]) };
			},
			htmlBuilder(r, e) {
				var t = Ie(r.body, e, !1);
				return k.makeFragment(t);
			},
			mathmlBuilder(r, e) {
				return new z.MathNode("mrow", We(r.body, e));
			},
		}),
		B({
			type: "html",
			names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
			props: { numArgs: 2, argTypes: ["raw", "original"], allowedInText: !0 },
			handler: (r, e) => {
				var { parser: t, funcName: n, token: a } = r,
					i = re(e[0], "raw").string,
					s = e[1];
				t.settings.strict &&
					t.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
				var l,
					u = {};
				switch (n) {
					case "\\htmlClass":
						(u.class = i), (l = { command: "\\htmlClass", class: i });
						break;
					case "\\htmlId":
						(u.id = i), (l = { command: "\\htmlId", id: i });
						break;
					case "\\htmlStyle":
						(u.style = i), (l = { command: "\\htmlStyle", style: i });
						break;
					case "\\htmlData": {
						for (var d = i.split(","), p = 0; p < d.length; p++) {
							var f = d[p].split("=");
							if (f.length !== 2) throw new A("Error parsing key-value for \\htmlData");
							u["data-" + f[0].trim()] = f[1].trim();
						}
						l = { command: "\\htmlData", attributes: u };
						break;
					}
					default:
						throw new Error("Unrecognized html command");
				}
				return t.settings.isTrusted(l)
					? { type: "html", mode: t.mode, attributes: u, body: Ae(s) }
					: t.formatUnsupportedCmd(n);
			},
			htmlBuilder: (r, e) => {
				var t = Ie(r.body, e, !1),
					n = ["enclosing"];
				r.attributes.class && n.push(...r.attributes.class.trim().split(/\s+/));
				var a = k.makeSpan(n, t, e);
				for (var i in r.attributes)
					i !== "class" && r.attributes.hasOwnProperty(i) && a.setAttribute(i, r.attributes[i]);
				return a;
			},
			mathmlBuilder: (r, e) => Ot(r.body, e),
		}),
		B({
			type: "htmlmathml",
			names: ["\\html@mathml"],
			props: { numArgs: 2, allowedInText: !0 },
			handler: (r, e) => {
				var { parser: t } = r;
				return { type: "htmlmathml", mode: t.mode, html: Ae(e[0]), mathml: Ae(e[1]) };
			},
			htmlBuilder: (r, e) => {
				var t = Ie(r.html, e, !1);
				return k.makeFragment(t);
			},
			mathmlBuilder: (r, e) => Ot(r.mathml, e),
		});
	var W0 = function (e) {
		if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(e)) return { number: +e, unit: "bp" };
		var t = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(e);
		if (!t) throw new A("Invalid size: '" + e + "' in \\includegraphics");
		var n = { number: +(t[1] + t[2]), unit: t[3] };
		if (!On(n)) throw new A("Invalid unit: '" + n.unit + "' in \\includegraphics.");
		return n;
	};
	B({
		type: "includegraphics",
		names: ["\\includegraphics"],
		props: { numArgs: 1, numOptionalArgs: 1, argTypes: ["raw", "url"], allowedInText: !1 },
		handler: (r, e, t) => {
			var { parser: n } = r,
				a = { number: 0, unit: "em" },
				i = { number: 0.9, unit: "em" },
				s = { number: 0, unit: "em" },
				l = "";
			if (t[0])
				for (var u = re(t[0], "raw").string, d = u.split(","), p = 0; p < d.length; p++) {
					var f = d[p].split("=");
					if (f.length === 2) {
						var v = f[1].trim();
						switch (f[0].trim()) {
							case "alt":
								l = v;
								break;
							case "width":
								a = W0(v);
								break;
							case "height":
								i = W0(v);
								break;
							case "totalheight":
								s = W0(v);
								break;
							default:
								throw new A("Invalid key: '" + f[0] + "' in \\includegraphics.");
						}
					}
				}
			var x = re(e[0], "url").url;
			return (
				l === "" &&
					((l = x), (l = l.replace(/^.*[\\/]/, "")), (l = l.substring(0, l.lastIndexOf(".")))),
				n.settings.isTrusted({ command: "\\includegraphics", url: x })
					? {
							type: "includegraphics",
							mode: n.mode,
							alt: l,
							width: a,
							height: i,
							totalheight: s,
							src: x,
						}
					: n.formatUnsupportedCmd("\\includegraphics")
			);
		},
		htmlBuilder: (r, e) => {
			var t = ke(r.height, e),
				n = 0;
			r.totalheight.number > 0 && (n = ke(r.totalheight, e) - t);
			var a = 0;
			r.width.number > 0 && (a = ke(r.width, e));
			var i = { height: R(t + n) };
			a > 0 && (i.width = R(a)), n > 0 && (i.verticalAlign = R(-n));
			var s = new Is(r.src, r.alt, i);
			return (s.height = t), (s.depth = n), s;
		},
		mathmlBuilder: (r, e) => {
			var t = new z.MathNode("mglyph", []);
			t.setAttribute("alt", r.alt);
			var n = ke(r.height, e),
				a = 0;
			if (
				(r.totalheight.number > 0 &&
					((a = ke(r.totalheight, e) - n), t.setAttribute("valign", R(-a))),
				t.setAttribute("height", R(n + a)),
				r.width.number > 0)
			) {
				var i = ke(r.width, e);
				t.setAttribute("width", R(i));
			}
			return t.setAttribute("src", r.src), t;
		},
	}),
		B({
			type: "kern",
			names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
			props: { numArgs: 1, argTypes: ["size"], primitive: !0, allowedInText: !0 },
			handler(r, e) {
				var { parser: t, funcName: n } = r,
					a = re(e[0], "size");
				if (t.settings.strict) {
					var i = n[1] === "m",
						s = a.value.unit === "mu";
					i
						? (s ||
								t.settings.reportNonstrict(
									"mathVsTextUnits",
									"LaTeX's " + n + " supports only mu units, " + ("not " + a.value.unit + " units")
								),
							t.mode !== "math" &&
								t.settings.reportNonstrict(
									"mathVsTextUnits",
									"LaTeX's " + n + " works only in math mode"
								))
						: s &&
							t.settings.reportNonstrict(
								"mathVsTextUnits",
								"LaTeX's " + n + " doesn't support mu units"
							);
				}
				return { type: "kern", mode: t.mode, dimension: a.value };
			},
			htmlBuilder(r, e) {
				return k.makeGlue(r.dimension, e);
			},
			mathmlBuilder(r, e) {
				var t = ke(r.dimension, e);
				return new z.SpaceNode(t);
			},
		}),
		B({
			type: "lap",
			names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
			props: { numArgs: 1, allowedInText: !0 },
			handler: (r, e) => {
				var { parser: t, funcName: n } = r,
					a = e[0];
				return { type: "lap", mode: t.mode, alignment: n.slice(5), body: a };
			},
			htmlBuilder: (r, e) => {
				var t;
				r.alignment === "clap"
					? ((t = k.makeSpan([], [oe(r.body, e)])), (t = k.makeSpan(["inner"], [t], e)))
					: (t = k.makeSpan(["inner"], [oe(r.body, e)]));
				var n = k.makeSpan(["fix"], []),
					a = k.makeSpan([r.alignment], [t, n], e),
					i = k.makeSpan(["strut"]);
				return (
					(i.style.height = R(a.height + a.depth)),
					a.depth && (i.style.verticalAlign = R(-a.depth)),
					a.children.unshift(i),
					(a = k.makeSpan(["thinbox"], [a], e)),
					k.makeSpan(["mord", "vbox"], [a], e)
				);
			},
			mathmlBuilder: (r, e) => {
				var t = new z.MathNode("mpadded", [me(r.body, e)]);
				if (r.alignment !== "rlap") {
					var n = r.alignment === "llap" ? "-1" : "-0.5";
					t.setAttribute("lspace", n + "width");
				}
				return t.setAttribute("width", "0px"), t;
			},
		}),
		B({
			type: "styling",
			names: ["\\(", "$"],
			props: { numArgs: 0, allowedInText: !0, allowedInMath: !1 },
			handler(r, e) {
				var { funcName: t, parser: n } = r,
					a = n.mode;
				n.switchMode("math");
				var i = t === "\\(" ? "\\)" : "$",
					s = n.parseExpression(!1, i);
				return (
					n.expect(i), n.switchMode(a), { type: "styling", mode: n.mode, style: "text", body: s }
				);
			},
		}),
		B({
			type: "text",
			names: ["\\)", "\\]"],
			props: { numArgs: 0, allowedInText: !0, allowedInMath: !1 },
			handler(r, e) {
				throw new A("Mismatched " + r.funcName);
			},
		});
	var Na = (r, e) => {
		switch (e.style.size) {
			case Z.DISPLAY.size:
				return r.display;
			case Z.TEXT.size:
				return r.text;
			case Z.SCRIPT.size:
				return r.script;
			case Z.SCRIPTSCRIPT.size:
				return r.scriptscript;
			default:
				return r.text;
		}
	};
	B({
		type: "mathchoice",
		names: ["\\mathchoice"],
		props: { numArgs: 4, primitive: !0 },
		handler: (r, e) => {
			var { parser: t } = r;
			return {
				type: "mathchoice",
				mode: t.mode,
				display: Ae(e[0]),
				text: Ae(e[1]),
				script: Ae(e[2]),
				scriptscript: Ae(e[3]),
			};
		},
		htmlBuilder: (r, e) => {
			var t = Na(r, e),
				n = Ie(t, e, !1);
			return k.makeFragment(n);
		},
		mathmlBuilder: (r, e) => {
			var t = Na(r, e);
			return Ot(t, e);
		},
	});
	var Oa = (r, e, t, n, a, i, s) => {
			r = k.makeSpan([], [r]);
			var l = t && V.isCharacterBox(t),
				u,
				d;
			if (e) {
				var p = oe(e, n.havingStyle(a.sup()), n);
				d = {
					elem: p,
					kern: Math.max(n.fontMetrics().bigOpSpacing1, n.fontMetrics().bigOpSpacing3 - p.depth),
				};
			}
			if (t) {
				var f = oe(t, n.havingStyle(a.sub()), n);
				u = {
					elem: f,
					kern: Math.max(n.fontMetrics().bigOpSpacing2, n.fontMetrics().bigOpSpacing4 - f.height),
				};
			}
			var v;
			if (d && u) {
				var x = n.fontMetrics().bigOpSpacing5 + u.elem.height + u.elem.depth + u.kern + r.depth + s;
				v = k.makeVList(
					{
						positionType: "bottom",
						positionData: x,
						children: [
							{ type: "kern", size: n.fontMetrics().bigOpSpacing5 },
							{ type: "elem", elem: u.elem, marginLeft: R(-i) },
							{ type: "kern", size: u.kern },
							{ type: "elem", elem: r },
							{ type: "kern", size: d.kern },
							{ type: "elem", elem: d.elem, marginLeft: R(i) },
							{ type: "kern", size: n.fontMetrics().bigOpSpacing5 },
						],
					},
					n
				);
			} else if (u) {
				var _ = r.height - s;
				v = k.makeVList(
					{
						positionType: "top",
						positionData: _,
						children: [
							{ type: "kern", size: n.fontMetrics().bigOpSpacing5 },
							{ type: "elem", elem: u.elem, marginLeft: R(-i) },
							{ type: "kern", size: u.kern },
							{ type: "elem", elem: r },
						],
					},
					n
				);
			} else if (d) {
				var S = r.depth + s;
				v = k.makeVList(
					{
						positionType: "bottom",
						positionData: S,
						children: [
							{ type: "elem", elem: r },
							{ type: "kern", size: d.kern },
							{ type: "elem", elem: d.elem, marginLeft: R(i) },
							{ type: "kern", size: n.fontMetrics().bigOpSpacing5 },
						],
					},
					n
				);
			} else return r;
			var M = [v];
			if (u && i !== 0 && !l) {
				var O = k.makeSpan(["mspace"], [], n);
				(O.style.marginRight = R(i)), M.unshift(O);
			}
			return k.makeSpan(["mop", "op-limits"], M, n);
		},
		za = ["\\smallint"],
		Yt = (r, e) => {
			var t,
				n,
				a = !1,
				i;
			r.type === "supsub"
				? ((t = r.sup), (n = r.sub), (i = re(r.base, "op")), (a = !0))
				: (i = re(r, "op"));
			var s = e.style,
				l = !1;
			s.size === Z.DISPLAY.size && i.symbol && !V.contains(za, i.name) && (l = !0);
			var u;
			if (i.symbol) {
				var d = l ? "Size2-Regular" : "Size1-Regular",
					p = "";
				if (
					((i.name === "\\oiint" || i.name === "\\oiiint") &&
						((p = i.name.slice(1)), (i.name = p === "oiint" ? "\\iint" : "\\iiint")),
					(u = k.makeSymbol(i.name, d, "math", e, [
						"mop",
						"op-symbol",
						l ? "large-op" : "small-op",
					])),
					p.length > 0)
				) {
					var f = u.italic,
						v = k.staticSvg(p + "Size" + (l ? "2" : "1"), e);
					(u = k.makeVList(
						{
							positionType: "individualShift",
							children: [
								{ type: "elem", elem: u, shift: 0 },
								{ type: "elem", elem: v, shift: l ? 0.08 : 0 },
							],
						},
						e
					)),
						(i.name = "\\" + p),
						u.classes.unshift("mop"),
						(u.italic = f);
				}
			} else if (i.body) {
				var x = Ie(i.body, e, !0);
				x.length === 1 && x[0] instanceof tt
					? ((u = x[0]), (u.classes[0] = "mop"))
					: (u = k.makeSpan(["mop"], x, e));
			} else {
				for (var _ = [], S = 1; S < i.name.length; S++) _.push(k.mathsym(i.name[S], i.mode, e));
				u = k.makeSpan(["mop"], _, e);
			}
			var M = 0,
				O = 0;
			return (
				(u instanceof tt || i.name === "\\oiint" || i.name === "\\oiiint") &&
					!i.suppressBaseShift &&
					((M = (u.height - u.depth) / 2 - e.fontMetrics().axisHeight), (O = u.italic)),
				a
					? Oa(u, t, n, e, s, O, M)
					: (M && ((u.style.position = "relative"), (u.style.top = R(M))), u)
			);
		},
		lr = (r, e) => {
			var t;
			if (r.symbol)
				(t = new Xe("mo", [rt(r.name, r.mode)])),
					V.contains(za, r.name) && t.setAttribute("largeop", "false");
			else if (r.body) t = new Xe("mo", We(r.body, e));
			else {
				t = new Xe("mi", [new ct(r.name.slice(1))]);
				var n = new Xe("mo", [rt("⁡", "text")]);
				r.parentIsSupSub ? (t = new Xe("mrow", [t, n])) : (t = Zn([t, n]));
			}
			return t;
		},
		Bo = {
			"∏": "\\prod",
			"∐": "\\coprod",
			"∑": "\\sum",
			"⋀": "\\bigwedge",
			"⋁": "\\bigvee",
			"⋂": "\\bigcap",
			"⋃": "\\bigcup",
			"⨀": "\\bigodot",
			"⨁": "\\bigoplus",
			"⨂": "\\bigotimes",
			"⨄": "\\biguplus",
			"⨆": "\\bigsqcup",
		};
	B({
		type: "op",
		names: [
			"\\coprod",
			"\\bigvee",
			"\\bigwedge",
			"\\biguplus",
			"\\bigcap",
			"\\bigcup",
			"\\intop",
			"\\prod",
			"\\sum",
			"\\bigotimes",
			"\\bigoplus",
			"\\bigodot",
			"\\bigsqcup",
			"\\smallint",
			"∏",
			"∐",
			"∑",
			"⋀",
			"⋁",
			"⋂",
			"⋃",
			"⨀",
			"⨁",
			"⨂",
			"⨄",
			"⨆",
		],
		props: { numArgs: 0 },
		handler: (r, e) => {
			var { parser: t, funcName: n } = r,
				a = n;
			return (
				a.length === 1 && (a = Bo[a]),
				{ type: "op", mode: t.mode, limits: !0, parentIsSupSub: !1, symbol: !0, name: a }
			);
		},
		htmlBuilder: Yt,
		mathmlBuilder: lr,
	}),
		B({
			type: "op",
			names: ["\\mathop"],
			props: { numArgs: 1, primitive: !0 },
			handler: (r, e) => {
				var { parser: t } = r,
					n = e[0];
				return {
					type: "op",
					mode: t.mode,
					limits: !1,
					parentIsSupSub: !1,
					symbol: !1,
					body: Ae(n),
				};
			},
			htmlBuilder: Yt,
			mathmlBuilder: lr,
		});
	var Lo = {
		"∫": "\\int",
		"∬": "\\iint",
		"∭": "\\iiint",
		"∮": "\\oint",
		"∯": "\\oiint",
		"∰": "\\oiiint",
	};
	B({
		type: "op",
		names: [
			"\\arcsin",
			"\\arccos",
			"\\arctan",
			"\\arctg",
			"\\arcctg",
			"\\arg",
			"\\ch",
			"\\cos",
			"\\cosec",
			"\\cosh",
			"\\cot",
			"\\cotg",
			"\\coth",
			"\\csc",
			"\\ctg",
			"\\cth",
			"\\deg",
			"\\dim",
			"\\exp",
			"\\hom",
			"\\ker",
			"\\lg",
			"\\ln",
			"\\log",
			"\\sec",
			"\\sin",
			"\\sinh",
			"\\sh",
			"\\tan",
			"\\tanh",
			"\\tg",
			"\\th",
		],
		props: { numArgs: 0 },
		handler(r) {
			var { parser: e, funcName: t } = r;
			return { type: "op", mode: e.mode, limits: !1, parentIsSupSub: !1, symbol: !1, name: t };
		},
		htmlBuilder: Yt,
		mathmlBuilder: lr,
	}),
		B({
			type: "op",
			names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
			props: { numArgs: 0 },
			handler(r) {
				var { parser: e, funcName: t } = r;
				return { type: "op", mode: e.mode, limits: !0, parentIsSupSub: !1, symbol: !1, name: t };
			},
			htmlBuilder: Yt,
			mathmlBuilder: lr,
		}),
		B({
			type: "op",
			names: [
				"\\int",
				"\\iint",
				"\\iiint",
				"\\oint",
				"\\oiint",
				"\\oiiint",
				"∫",
				"∬",
				"∭",
				"∮",
				"∯",
				"∰",
			],
			props: { numArgs: 0 },
			handler(r) {
				var { parser: e, funcName: t } = r,
					n = t;
				return (
					n.length === 1 && (n = Lo[n]),
					{ type: "op", mode: e.mode, limits: !1, parentIsSupSub: !1, symbol: !0, name: n }
				);
			},
			htmlBuilder: Yt,
			mathmlBuilder: lr,
		});
	var Ca = (r, e) => {
			var t,
				n,
				a = !1,
				i;
			r.type === "supsub"
				? ((t = r.sup), (n = r.sub), (i = re(r.base, "operatorname")), (a = !0))
				: (i = re(r, "operatorname"));
			var s;
			if (i.body.length > 0) {
				for (
					var l = i.body.map((f) => {
							var v = f.text;
							return typeof v == "string" ? { type: "textord", mode: f.mode, text: v } : f;
						}),
						u = Ie(l, e.withFont("mathrm"), !0),
						d = 0;
					d < u.length;
					d++
				) {
					var p = u[d];
					p instanceof tt && (p.text = p.text.replace(/\u2212/, "-").replace(/\u2217/, "*"));
				}
				s = k.makeSpan(["mop"], u, e);
			} else s = k.makeSpan(["mop"], [], e);
			return a ? Oa(s, t, n, e, e.style, 0, 0) : s;
		},
		$o = (r, e) => {
			for (var t = We(r.body, e.withFont("mathrm")), n = !0, a = 0; a < t.length; a++) {
				var i = t[a];
				if (!(i instanceof z.SpaceNode))
					if (i instanceof z.MathNode)
						switch (i.type) {
							case "mi":
							case "mn":
							case "ms":
							case "mspace":
							case "mtext":
								break;
							case "mo": {
								var s = i.children[0];
								i.children.length === 1 && s instanceof z.TextNode
									? (s.text = s.text.replace(/\u2212/, "-").replace(/\u2217/, "*"))
									: (n = !1);
								break;
							}
							default:
								n = !1;
						}
					else n = !1;
			}
			if (n) {
				var l = t.map((p) => p.toText()).join("");
				t = [new z.TextNode(l)];
			}
			var u = new z.MathNode("mi", t);
			u.setAttribute("mathvariant", "normal");
			var d = new z.MathNode("mo", [rt("⁡", "text")]);
			return r.parentIsSupSub ? new z.MathNode("mrow", [u, d]) : z.newDocumentFragment([u, d]);
		};
	B({
		type: "operatorname",
		names: ["\\operatorname@", "\\operatornamewithlimits"],
		props: { numArgs: 1 },
		handler: (r, e) => {
			var { parser: t, funcName: n } = r,
				a = e[0];
			return {
				type: "operatorname",
				mode: t.mode,
				body: Ae(a),
				alwaysHandleSupSub: n === "\\operatornamewithlimits",
				limits: !1,
				parentIsSupSub: !1,
			};
		},
		htmlBuilder: Ca,
		mathmlBuilder: $o,
	}),
		m("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@"),
		Pt({
			type: "ordgroup",
			htmlBuilder(r, e) {
				return r.semisimple
					? k.makeFragment(Ie(r.body, e, !1))
					: k.makeSpan(["mord"], Ie(r.body, e, !0), e);
			},
			mathmlBuilder(r, e) {
				return Ot(r.body, e, !0);
			},
		}),
		B({
			type: "overline",
			names: ["\\overline"],
			props: { numArgs: 1 },
			handler(r, e) {
				var { parser: t } = r,
					n = e[0];
				return { type: "overline", mode: t.mode, body: n };
			},
			htmlBuilder(r, e) {
				var t = oe(r.body, e.havingCrampedStyle()),
					n = k.makeLineSpan("overline-line", e),
					a = e.fontMetrics().defaultRuleThickness,
					i = k.makeVList(
						{
							positionType: "firstBaseline",
							children: [
								{ type: "elem", elem: t },
								{ type: "kern", size: 3 * a },
								{ type: "elem", elem: n },
								{ type: "kern", size: a },
							],
						},
						e
					);
				return k.makeSpan(["mord", "overline"], [i], e);
			},
			mathmlBuilder(r, e) {
				var t = new z.MathNode("mo", [new z.TextNode("‾")]);
				t.setAttribute("stretchy", "true");
				var n = new z.MathNode("mover", [me(r.body, e), t]);
				return n.setAttribute("accent", "true"), n;
			},
		}),
		B({
			type: "phantom",
			names: ["\\phantom"],
			props: { numArgs: 1, allowedInText: !0 },
			handler: (r, e) => {
				var { parser: t } = r,
					n = e[0];
				return { type: "phantom", mode: t.mode, body: Ae(n) };
			},
			htmlBuilder: (r, e) => {
				var t = Ie(r.body, e.withPhantom(), !1);
				return k.makeFragment(t);
			},
			mathmlBuilder: (r, e) => {
				var t = We(r.body, e);
				return new z.MathNode("mphantom", t);
			},
		}),
		B({
			type: "hphantom",
			names: ["\\hphantom"],
			props: { numArgs: 1, allowedInText: !0 },
			handler: (r, e) => {
				var { parser: t } = r,
					n = e[0];
				return { type: "hphantom", mode: t.mode, body: n };
			},
			htmlBuilder: (r, e) => {
				var t = k.makeSpan([], [oe(r.body, e.withPhantom())]);
				if (((t.height = 0), (t.depth = 0), t.children))
					for (var n = 0; n < t.children.length; n++)
						(t.children[n].height = 0), (t.children[n].depth = 0);
				return (
					(t = k.makeVList(
						{ positionType: "firstBaseline", children: [{ type: "elem", elem: t }] },
						e
					)),
					k.makeSpan(["mord"], [t], e)
				);
			},
			mathmlBuilder: (r, e) => {
				var t = We(Ae(r.body), e),
					n = new z.MathNode("mphantom", t),
					a = new z.MathNode("mpadded", [n]);
				return a.setAttribute("height", "0px"), a.setAttribute("depth", "0px"), a;
			},
		}),
		B({
			type: "vphantom",
			names: ["\\vphantom"],
			props: { numArgs: 1, allowedInText: !0 },
			handler: (r, e) => {
				var { parser: t } = r,
					n = e[0];
				return { type: "vphantom", mode: t.mode, body: n };
			},
			htmlBuilder: (r, e) => {
				var t = k.makeSpan(["inner"], [oe(r.body, e.withPhantom())]),
					n = k.makeSpan(["fix"], []);
				return k.makeSpan(["mord", "rlap"], [t, n], e);
			},
			mathmlBuilder: (r, e) => {
				var t = We(Ae(r.body), e),
					n = new z.MathNode("mphantom", t),
					a = new z.MathNode("mpadded", [n]);
				return a.setAttribute("width", "0px"), a;
			},
		}),
		B({
			type: "raisebox",
			names: ["\\raisebox"],
			props: { numArgs: 2, argTypes: ["size", "hbox"], allowedInText: !0 },
			handler(r, e) {
				var { parser: t } = r,
					n = re(e[0], "size").value,
					a = e[1];
				return { type: "raisebox", mode: t.mode, dy: n, body: a };
			},
			htmlBuilder(r, e) {
				var t = oe(r.body, e),
					n = ke(r.dy, e);
				return k.makeVList(
					{ positionType: "shift", positionData: -n, children: [{ type: "elem", elem: t }] },
					e
				);
			},
			mathmlBuilder(r, e) {
				var t = new z.MathNode("mpadded", [me(r.body, e)]),
					n = r.dy.number + r.dy.unit;
				return t.setAttribute("voffset", n), t;
			},
		}),
		B({
			type: "internal",
			names: ["\\relax"],
			props: { numArgs: 0, allowedInText: !0, allowedInArgument: !0 },
			handler(r) {
				var { parser: e } = r;
				return { type: "internal", mode: e.mode };
			},
		}),
		B({
			type: "rule",
			names: ["\\rule"],
			props: {
				numArgs: 2,
				numOptionalArgs: 1,
				allowedInText: !0,
				allowedInMath: !0,
				argTypes: ["size", "size", "size"],
			},
			handler(r, e, t) {
				var { parser: n } = r,
					a = t[0],
					i = re(e[0], "size"),
					s = re(e[1], "size");
				return {
					type: "rule",
					mode: n.mode,
					shift: a && re(a, "size").value,
					width: i.value,
					height: s.value,
				};
			},
			htmlBuilder(r, e) {
				var t = k.makeSpan(["mord", "rule"], [], e),
					n = ke(r.width, e),
					a = ke(r.height, e),
					i = r.shift ? ke(r.shift, e) : 0;
				return (
					(t.style.borderRightWidth = R(n)),
					(t.style.borderTopWidth = R(a)),
					(t.style.bottom = R(i)),
					(t.width = n),
					(t.height = a + i),
					(t.depth = -i),
					(t.maxFontSize = a * 1.125 * e.sizeMultiplier),
					t
				);
			},
			mathmlBuilder(r, e) {
				var t = ke(r.width, e),
					n = ke(r.height, e),
					a = r.shift ? ke(r.shift, e) : 0,
					i = (e.color && e.getColor()) || "black",
					s = new z.MathNode("mspace");
				s.setAttribute("mathbackground", i),
					s.setAttribute("width", R(t)),
					s.setAttribute("height", R(n));
				var l = new z.MathNode("mpadded", [s]);
				return (
					a >= 0
						? l.setAttribute("height", R(a))
						: (l.setAttribute("height", R(a)), l.setAttribute("depth", R(-a))),
					l.setAttribute("voffset", R(a)),
					l
				);
			},
		});
	function Ra(r, e, t) {
		for (var n = Ie(r, e, !1), a = e.sizeMultiplier / t.sizeMultiplier, i = 0; i < n.length; i++) {
			var s = n[i].classes.indexOf("sizing");
			s < 0
				? Array.prototype.push.apply(n[i].classes, e.sizingClasses(t))
				: n[i].classes[s + 1] === "reset-size" + e.size &&
					(n[i].classes[s + 1] = "reset-size" + t.size),
				(n[i].height *= a),
				(n[i].depth *= a);
		}
		return k.makeFragment(n);
	}
	var Ia = [
			"\\tiny",
			"\\sixptsize",
			"\\scriptsize",
			"\\footnotesize",
			"\\small",
			"\\normalsize",
			"\\large",
			"\\Large",
			"\\LARGE",
			"\\huge",
			"\\Huge",
		],
		qo = (r, e) => {
			var t = e.havingSize(r.size);
			return Ra(r.body, t, e);
		};
	B({
		type: "sizing",
		names: Ia,
		props: { numArgs: 0, allowedInText: !0 },
		handler: (r, e) => {
			var { breakOnTokenText: t, funcName: n, parser: a } = r,
				i = a.parseExpression(!1, t);
			return { type: "sizing", mode: a.mode, size: Ia.indexOf(n) + 1, body: i };
		},
		htmlBuilder: qo,
		mathmlBuilder: (r, e) => {
			var t = e.havingSize(r.size),
				n = We(r.body, t),
				a = new z.MathNode("mstyle", n);
			return a.setAttribute("mathsize", R(t.sizeMultiplier)), a;
		},
	}),
		B({
			type: "smash",
			names: ["\\smash"],
			props: { numArgs: 1, numOptionalArgs: 1, allowedInText: !0 },
			handler: (r, e, t) => {
				var { parser: n } = r,
					a = !1,
					i = !1,
					s = t[0] && re(t[0], "ordgroup");
				if (s)
					for (var l = "", u = 0; u < s.body.length; ++u) {
						var d = s.body[u];
						if (((l = d.text), l === "t")) a = !0;
						else if (l === "b") i = !0;
						else {
							(a = !1), (i = !1);
							break;
						}
					}
				else (a = !0), (i = !0);
				var p = e[0];
				return { type: "smash", mode: n.mode, body: p, smashHeight: a, smashDepth: i };
			},
			htmlBuilder: (r, e) => {
				var t = k.makeSpan([], [oe(r.body, e)]);
				if (!r.smashHeight && !r.smashDepth) return t;
				if (r.smashHeight && ((t.height = 0), t.children))
					for (var n = 0; n < t.children.length; n++) t.children[n].height = 0;
				if (r.smashDepth && ((t.depth = 0), t.children))
					for (var a = 0; a < t.children.length; a++) t.children[a].depth = 0;
				var i = k.makeVList(
					{ positionType: "firstBaseline", children: [{ type: "elem", elem: t }] },
					e
				);
				return k.makeSpan(["mord"], [i], e);
			},
			mathmlBuilder: (r, e) => {
				var t = new z.MathNode("mpadded", [me(r.body, e)]);
				return (
					r.smashHeight && t.setAttribute("height", "0px"),
					r.smashDepth && t.setAttribute("depth", "0px"),
					t
				);
			},
		}),
		B({
			type: "sqrt",
			names: ["\\sqrt"],
			props: { numArgs: 1, numOptionalArgs: 1 },
			handler(r, e, t) {
				var { parser: n } = r,
					a = t[0],
					i = e[0];
				return { type: "sqrt", mode: n.mode, body: i, index: a };
			},
			htmlBuilder(r, e) {
				var t = oe(r.body, e.havingCrampedStyle());
				t.height === 0 && (t.height = e.fontMetrics().xHeight), (t = k.wrapFragment(t, e));
				var n = e.fontMetrics(),
					a = n.defaultRuleThickness,
					i = a;
				e.style.id < Z.TEXT.id && (i = e.fontMetrics().xHeight);
				var s = a + i / 4,
					l = t.height + t.depth + s + a,
					{ span: u, ruleWidth: d, advanceWidth: p } = _t.sqrtImage(l, e),
					f = u.height - d;
				f > t.height + t.depth + s && (s = (s + f - t.height - t.depth) / 2);
				var v = u.height - t.height - s - d;
				t.style.paddingLeft = R(p);
				var x = k.makeVList(
					{
						positionType: "firstBaseline",
						children: [
							{ type: "elem", elem: t, wrapperClasses: ["svg-align"] },
							{ type: "kern", size: -(t.height + v) },
							{ type: "elem", elem: u },
							{ type: "kern", size: d },
						],
					},
					e
				);
				if (r.index) {
					var _ = e.havingStyle(Z.SCRIPTSCRIPT),
						S = oe(r.index, _, e),
						M = 0.6 * (x.height - x.depth),
						O = k.makeVList(
							{ positionType: "shift", positionData: -M, children: [{ type: "elem", elem: S }] },
							e
						),
						I = k.makeSpan(["root"], [O]);
					return k.makeSpan(["mord", "sqrt"], [I, x], e);
				} else return k.makeSpan(["mord", "sqrt"], [x], e);
			},
			mathmlBuilder(r, e) {
				var { body: t, index: n } = r;
				return n
					? new z.MathNode("mroot", [me(t, e), me(n, e)])
					: new z.MathNode("msqrt", [me(t, e)]);
			},
		});
	var Da = { display: Z.DISPLAY, text: Z.TEXT, script: Z.SCRIPT, scriptscript: Z.SCRIPTSCRIPT };
	B({
		type: "styling",
		names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
		props: { numArgs: 0, allowedInText: !0, primitive: !0 },
		handler(r, e) {
			var { breakOnTokenText: t, funcName: n, parser: a } = r,
				i = a.parseExpression(!0, t),
				s = n.slice(1, n.length - 5);
			return { type: "styling", mode: a.mode, style: s, body: i };
		},
		htmlBuilder(r, e) {
			var t = Da[r.style],
				n = e.havingStyle(t).withFont("");
			return Ra(r.body, n, e);
		},
		mathmlBuilder(r, e) {
			var t = Da[r.style],
				n = e.havingStyle(t),
				a = We(r.body, n),
				i = new z.MathNode("mstyle", a),
				s = {
					display: ["0", "true"],
					text: ["0", "false"],
					script: ["1", "false"],
					scriptscript: ["2", "false"],
				},
				l = s[r.style];
			return i.setAttribute("scriptlevel", l[0]), i.setAttribute("displaystyle", l[1]), i;
		},
	});
	var Po = function (e, t) {
		var n = e.base;
		if (n)
			if (n.type === "op") {
				var a = n.limits && (t.style.size === Z.DISPLAY.size || n.alwaysHandleSupSub);
				return a ? Yt : null;
			} else if (n.type === "operatorname") {
				var i = n.alwaysHandleSupSub && (t.style.size === Z.DISPLAY.size || n.limits);
				return i ? Ca : null;
			} else {
				if (n.type === "accent") return V.isCharacterBox(n.base) ? C0 : null;
				if (n.type === "horizBrace") {
					var s = !e.sub;
					return s === n.isOver ? Aa : null;
				} else return null;
			}
		else return null;
	};
	Pt({
		type: "supsub",
		htmlBuilder(r, e) {
			var t = Po(r, e);
			if (t) return t(r, e);
			var { base: n, sup: a, sub: i } = r,
				s = oe(n, e),
				l,
				u,
				d = e.fontMetrics(),
				p = 0,
				f = 0,
				v = n && V.isCharacterBox(n);
			if (a) {
				var x = e.havingStyle(e.style.sup());
				(l = oe(a, x, e)),
					v || (p = s.height - (x.fontMetrics().supDrop * x.sizeMultiplier) / e.sizeMultiplier);
			}
			if (i) {
				var _ = e.havingStyle(e.style.sub());
				(u = oe(i, _, e)),
					v || (f = s.depth + (_.fontMetrics().subDrop * _.sizeMultiplier) / e.sizeMultiplier);
			}
			var S;
			e.style === Z.DISPLAY ? (S = d.sup1) : e.style.cramped ? (S = d.sup3) : (S = d.sup2);
			var M = e.sizeMultiplier,
				O = R(0.5 / d.ptPerEm / M),
				I = null;
			if (u) {
				var $ =
					r.base &&
					r.base.type === "op" &&
					r.base.name &&
					(r.base.name === "\\oiint" || r.base.name === "\\oiiint");
				(s instanceof tt || $) && (I = R(-s.italic));
			}
			var P;
			if (l && u) {
				(p = Math.max(p, S, l.depth + 0.25 * d.xHeight)), (f = Math.max(f, d.sub2));
				var q = d.defaultRuleThickness,
					U = 4 * q;
				if (p - l.depth - (u.height - f) < U) {
					f = U - (p - l.depth) + u.height;
					var Q = 0.8 * d.xHeight - (p - l.depth);
					Q > 0 && ((p += Q), (f -= Q));
				}
				var ne = [
					{ type: "elem", elem: u, shift: f, marginRight: O, marginLeft: I },
					{ type: "elem", elem: l, shift: -p, marginRight: O },
				];
				P = k.makeVList({ positionType: "individualShift", children: ne }, e);
			} else if (u) {
				f = Math.max(f, d.sub1, u.height - 0.8 * d.xHeight);
				var te = [{ type: "elem", elem: u, marginLeft: I, marginRight: O }];
				P = k.makeVList({ positionType: "shift", positionData: f, children: te }, e);
			} else if (l)
				(p = Math.max(p, S, l.depth + 0.25 * d.xHeight)),
					(P = k.makeVList(
						{
							positionType: "shift",
							positionData: -p,
							children: [{ type: "elem", elem: l, marginRight: O }],
						},
						e
					));
			else throw new Error("supsub must have either sup or sub.");
			var Pe = T0(s, "right") || "mord";
			return k.makeSpan([Pe], [s, k.makeSpan(["msupsub"], [P])], e);
		},
		mathmlBuilder(r, e) {
			var t = !1,
				n,
				a;
			r.base &&
				r.base.type === "horizBrace" &&
				((a = !!r.sup), a === r.base.isOver && ((t = !0), (n = r.base.isOver))),
				r.base &&
					(r.base.type === "op" || r.base.type === "operatorname") &&
					(r.base.parentIsSupSub = !0);
			var i = [me(r.base, e)];
			r.sub && i.push(me(r.sub, e)), r.sup && i.push(me(r.sup, e));
			var s;
			if (t) s = n ? "mover" : "munder";
			else if (r.sub)
				if (r.sup) {
					var d = r.base;
					(d && d.type === "op" && d.limits && e.style === Z.DISPLAY) ||
					(d &&
						d.type === "operatorname" &&
						d.alwaysHandleSupSub &&
						(e.style === Z.DISPLAY || d.limits))
						? (s = "munderover")
						: (s = "msubsup");
				} else {
					var u = r.base;
					(u && u.type === "op" && u.limits && (e.style === Z.DISPLAY || u.alwaysHandleSupSub)) ||
					(u &&
						u.type === "operatorname" &&
						u.alwaysHandleSupSub &&
						(u.limits || e.style === Z.DISPLAY))
						? (s = "munder")
						: (s = "msub");
				}
			else {
				var l = r.base;
				(l && l.type === "op" && l.limits && (e.style === Z.DISPLAY || l.alwaysHandleSupSub)) ||
				(l &&
					l.type === "operatorname" &&
					l.alwaysHandleSupSub &&
					(l.limits || e.style === Z.DISPLAY))
					? (s = "mover")
					: (s = "msup");
			}
			return new z.MathNode(s, i);
		},
	}),
		Pt({
			type: "atom",
			htmlBuilder(r, e) {
				return k.mathsym(r.text, r.mode, e, ["m" + r.family]);
			},
			mathmlBuilder(r, e) {
				var t = new z.MathNode("mo", [rt(r.text, r.mode)]);
				if (r.family === "bin") {
					var n = N0(r, e);
					n === "bold-italic" && t.setAttribute("mathvariant", n);
				} else
					r.family === "punct"
						? t.setAttribute("separator", "true")
						: (r.family === "open" || r.family === "close") && t.setAttribute("stretchy", "false");
				return t;
			},
		});
	var Ba = { mi: "italic", mn: "normal", mtext: "normal" };
	Pt({
		type: "mathord",
		htmlBuilder(r, e) {
			return k.makeOrd(r, e, "mathord");
		},
		mathmlBuilder(r, e) {
			var t = new z.MathNode("mi", [rt(r.text, r.mode, e)]),
				n = N0(r, e) || "italic";
			return n !== Ba[t.type] && t.setAttribute("mathvariant", n), t;
		},
	}),
		Pt({
			type: "textord",
			htmlBuilder(r, e) {
				return k.makeOrd(r, e, "textord");
			},
			mathmlBuilder(r, e) {
				var t = rt(r.text, r.mode, e),
					n = N0(r, e) || "normal",
					a;
				return (
					r.mode === "text"
						? (a = new z.MathNode("mtext", [t]))
						: /[0-9]/.test(r.text)
							? (a = new z.MathNode("mn", [t]))
							: r.text === "\\prime"
								? (a = new z.MathNode("mo", [t]))
								: (a = new z.MathNode("mi", [t])),
					n !== Ba[a.type] && a.setAttribute("mathvariant", n),
					a
				);
			},
		});
	var Z0 = { "\\nobreak": "nobreak", "\\allowbreak": "allowbreak" },
		X0 = {
			" ": {},
			"\\ ": {},
			"~": { className: "nobreak" },
			"\\space": {},
			"\\nobreakspace": { className: "nobreak" },
		};
	Pt({
		type: "spacing",
		htmlBuilder(r, e) {
			if (X0.hasOwnProperty(r.text)) {
				var t = X0[r.text].className || "";
				if (r.mode === "text") {
					var n = k.makeOrd(r, e, "textord");
					return n.classes.push(t), n;
				} else return k.makeSpan(["mspace", t], [k.mathsym(r.text, r.mode, e)], e);
			} else {
				if (Z0.hasOwnProperty(r.text)) return k.makeSpan(["mspace", Z0[r.text]], [], e);
				throw new A('Unknown type of space "' + r.text + '"');
			}
		},
		mathmlBuilder(r, e) {
			var t;
			if (X0.hasOwnProperty(r.text)) t = new z.MathNode("mtext", [new z.TextNode(" ")]);
			else {
				if (Z0.hasOwnProperty(r.text)) return new z.MathNode("mspace");
				throw new A('Unknown type of space "' + r.text + '"');
			}
			return t;
		},
	});
	var La = () => {
		var r = new z.MathNode("mtd", []);
		return r.setAttribute("width", "50%"), r;
	};
	Pt({
		type: "tag",
		mathmlBuilder(r, e) {
			var t = new z.MathNode("mtable", [
				new z.MathNode("mtr", [
					La(),
					new z.MathNode("mtd", [Ot(r.body, e)]),
					La(),
					new z.MathNode("mtd", [Ot(r.tag, e)]),
				]),
			]);
			return t.setAttribute("width", "100%"), t;
		},
	});
	var $a = {
			"\\text": void 0,
			"\\textrm": "textrm",
			"\\textsf": "textsf",
			"\\texttt": "texttt",
			"\\textnormal": "textrm",
		},
		qa = { "\\textbf": "textbf", "\\textmd": "textmd" },
		Fo = { "\\textit": "textit", "\\textup": "textup" },
		Pa = (r, e) => {
			var t = r.font;
			if (t) {
				if ($a[t]) return e.withTextFontFamily($a[t]);
				if (qa[t]) return e.withTextFontWeight(qa[t]);
				if (t === "\\emph")
					return e.fontShape === "textit"
						? e.withTextFontShape("textup")
						: e.withTextFontShape("textit");
			} else return e;
			return e.withTextFontShape(Fo[t]);
		};
	B({
		type: "text",
		names: [
			"\\text",
			"\\textrm",
			"\\textsf",
			"\\texttt",
			"\\textnormal",
			"\\textbf",
			"\\textmd",
			"\\textit",
			"\\textup",
			"\\emph",
		],
		props: { numArgs: 1, argTypes: ["text"], allowedInArgument: !0, allowedInText: !0 },
		handler(r, e) {
			var { parser: t, funcName: n } = r,
				a = e[0];
			return { type: "text", mode: t.mode, body: Ae(a), font: n };
		},
		htmlBuilder(r, e) {
			var t = Pa(r, e),
				n = Ie(r.body, t, !0);
			return k.makeSpan(["mord", "text"], n, t);
		},
		mathmlBuilder(r, e) {
			var t = Pa(r, e);
			return Ot(r.body, t);
		},
	}),
		B({
			type: "underline",
			names: ["\\underline"],
			props: { numArgs: 1, allowedInText: !0 },
			handler(r, e) {
				var { parser: t } = r;
				return { type: "underline", mode: t.mode, body: e[0] };
			},
			htmlBuilder(r, e) {
				var t = oe(r.body, e),
					n = k.makeLineSpan("underline-line", e),
					a = e.fontMetrics().defaultRuleThickness,
					i = k.makeVList(
						{
							positionType: "top",
							positionData: t.height,
							children: [
								{ type: "kern", size: a },
								{ type: "elem", elem: n },
								{ type: "kern", size: 3 * a },
								{ type: "elem", elem: t },
							],
						},
						e
					);
				return k.makeSpan(["mord", "underline"], [i], e);
			},
			mathmlBuilder(r, e) {
				var t = new z.MathNode("mo", [new z.TextNode("‾")]);
				t.setAttribute("stretchy", "true");
				var n = new z.MathNode("munder", [me(r.body, e), t]);
				return n.setAttribute("accentunder", "true"), n;
			},
		}),
		B({
			type: "vcenter",
			names: ["\\vcenter"],
			props: { numArgs: 1, argTypes: ["original"], allowedInText: !1 },
			handler(r, e) {
				var { parser: t } = r;
				return { type: "vcenter", mode: t.mode, body: e[0] };
			},
			htmlBuilder(r, e) {
				var t = oe(r.body, e),
					n = e.fontMetrics().axisHeight,
					a = 0.5 * (t.height - n - (t.depth + n));
				return k.makeVList(
					{ positionType: "shift", positionData: a, children: [{ type: "elem", elem: t }] },
					e
				);
			},
			mathmlBuilder(r, e) {
				return new z.MathNode("mpadded", [me(r.body, e)], ["vcenter"]);
			},
		}),
		B({
			type: "verb",
			names: ["\\verb"],
			props: { numArgs: 0, allowedInText: !0 },
			handler(r, e, t) {
				throw new A("\\verb ended by end of line instead of matching delimiter");
			},
			htmlBuilder(r, e) {
				for (var t = Fa(r), n = [], a = e.havingStyle(e.style.text()), i = 0; i < t.length; i++) {
					var s = t[i];
					s === "~" && (s = "\\textasciitilde"),
						n.push(k.makeSymbol(s, "Typewriter-Regular", r.mode, a, ["mord", "texttt"]));
				}
				return k.makeSpan(["mord", "text"].concat(a.sizingClasses(e)), k.tryCombineChars(n), a);
			},
			mathmlBuilder(r, e) {
				var t = new z.TextNode(Fa(r)),
					n = new z.MathNode("mtext", [t]);
				return n.setAttribute("mathvariant", "monospace"), n;
			},
		});
	var Fa = (r) => r.body.replace(/ /g, r.star ? "␣" : " "),
		Ct = Kn,
		Ha = `[ \r
	]`,
		Ho = "\\\\[a-zA-Z@]+",
		Uo = "\\\\[^\uD800-\uDFFF]",
		Go = "(" + Ho + ")" + Ha + "*",
		Ko = `\\\\(
|[ \r	]+
?)[ \r	]*`,
		Y0 = "[̀-ͯ]",
		Vo = new RegExp(Y0 + "+$"),
		Wo =
			"(" +
			Ha +
			"+)|" +
			(Ko + "|") +
			"([!-\\[\\]-‧‪-퟿豈-￿]" +
			(Y0 + "*") +
			"|[\uD800-\uDBFF][\uDC00-\uDFFF]" +
			(Y0 + "*") +
			"|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" +
			("|" + Go) +
			("|" + Uo + ")");
	class Ua {
		constructor(e, t) {
			(this.input = void 0),
				(this.settings = void 0),
				(this.tokenRegex = void 0),
				(this.catcodes = void 0),
				(this.input = e),
				(this.settings = t),
				(this.tokenRegex = new RegExp(Wo, "g")),
				(this.catcodes = { "%": 14, "~": 13 });
		}
		setCatcode(e, t) {
			this.catcodes[e] = t;
		}
		lex() {
			var e = this.input,
				t = this.tokenRegex.lastIndex;
			if (t === e.length) return new ce("EOF", new le(this, t, t));
			var n = this.tokenRegex.exec(e);
			if (n === null || n.index !== t)
				throw new A("Unexpected character: '" + e[t] + "'", new ce(e[t], new le(this, t, t + 1)));
			var a = n[6] || n[3] || (n[2] ? "\\ " : " ");
			if (this.catcodes[a] === 14) {
				var i = e.indexOf(
					`
`,
					this.tokenRegex.lastIndex
				);
				return (
					i === -1
						? ((this.tokenRegex.lastIndex = e.length),
							this.settings.reportNonstrict(
								"commentAtEnd",
								"% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)"
							))
						: (this.tokenRegex.lastIndex = i + 1),
					this.lex()
				);
			}
			return new ce(a, new le(this, t, this.tokenRegex.lastIndex));
		}
	}
	class Zo {
		constructor(e, t) {
			e === void 0 && (e = {}),
				t === void 0 && (t = {}),
				(this.current = void 0),
				(this.builtins = void 0),
				(this.undefStack = void 0),
				(this.current = t),
				(this.builtins = e),
				(this.undefStack = []);
		}
		beginGroup() {
			this.undefStack.push({});
		}
		endGroup() {
			if (this.undefStack.length === 0)
				throw new A(
					"Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug"
				);
			var e = this.undefStack.pop();
			for (var t in e)
				e.hasOwnProperty(t) && (e[t] == null ? delete this.current[t] : (this.current[t] = e[t]));
		}
		endGroups() {
			for (; this.undefStack.length > 0; ) this.endGroup();
		}
		has(e) {
			return this.current.hasOwnProperty(e) || this.builtins.hasOwnProperty(e);
		}
		get(e) {
			return this.current.hasOwnProperty(e) ? this.current[e] : this.builtins[e];
		}
		set(e, t, n) {
			if ((n === void 0 && (n = !1), n)) {
				for (var a = 0; a < this.undefStack.length; a++) delete this.undefStack[a][e];
				this.undefStack.length > 0 && (this.undefStack[this.undefStack.length - 1][e] = t);
			} else {
				var i = this.undefStack[this.undefStack.length - 1];
				i && !i.hasOwnProperty(e) && (i[e] = this.current[e]);
			}
			t == null ? delete this.current[e] : (this.current[e] = t);
		}
	}
	var Xo = va;
	m("\\noexpand", function (r) {
		var e = r.popToken();
		return (
			r.isExpandable(e.text) && ((e.noexpand = !0), (e.treatAsRelax = !0)),
			{ tokens: [e], numArgs: 0 }
		);
	}),
		m("\\expandafter", function (r) {
			var e = r.popToken();
			return r.expandOnce(!0), { tokens: [e], numArgs: 0 };
		}),
		m("\\@firstoftwo", function (r) {
			var e = r.consumeArgs(2);
			return { tokens: e[0], numArgs: 0 };
		}),
		m("\\@secondoftwo", function (r) {
			var e = r.consumeArgs(2);
			return { tokens: e[1], numArgs: 0 };
		}),
		m("\\@ifnextchar", function (r) {
			var e = r.consumeArgs(3);
			r.consumeSpaces();
			var t = r.future();
			return e[0].length === 1 && e[0][0].text === t.text
				? { tokens: e[1], numArgs: 0 }
				: { tokens: e[2], numArgs: 0 };
		}),
		m("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}"),
		m("\\TextOrMath", function (r) {
			var e = r.consumeArgs(2);
			return r.mode === "text" ? { tokens: e[0], numArgs: 0 } : { tokens: e[1], numArgs: 0 };
		});
	var Ga = {
		0: 0,
		1: 1,
		2: 2,
		3: 3,
		4: 4,
		5: 5,
		6: 6,
		7: 7,
		8: 8,
		9: 9,
		a: 10,
		A: 10,
		b: 11,
		B: 11,
		c: 12,
		C: 12,
		d: 13,
		D: 13,
		e: 14,
		E: 14,
		f: 15,
		F: 15,
	};
	m("\\char", function (r) {
		var e = r.popToken(),
			t,
			n = "";
		if (e.text === "'") (t = 8), (e = r.popToken());
		else if (e.text === '"') (t = 16), (e = r.popToken());
		else if (e.text === "`")
			if (((e = r.popToken()), e.text[0] === "\\")) n = e.text.charCodeAt(1);
			else {
				if (e.text === "EOF") throw new A("\\char` missing argument");
				n = e.text.charCodeAt(0);
			}
		else t = 10;
		if (t) {
			if (((n = Ga[e.text]), n == null || n >= t))
				throw new A("Invalid base-" + t + " digit " + e.text);
			for (var a; (a = Ga[r.future().text]) != null && a < t; ) (n *= t), (n += a), r.popToken();
		}
		return "\\@char{" + n + "}";
	});
	var Q0 = (r, e, t, n) => {
		var a = r.consumeArg().tokens;
		if (a.length !== 1) throw new A("\\newcommand's first argument must be a macro name");
		var i = a[0].text,
			s = r.isDefined(i);
		if (s && !e)
			throw new A("\\newcommand{" + i + "} attempting to redefine " + (i + "; use \\renewcommand"));
		if (!s && !t)
			throw new A(
				"\\renewcommand{" + i + "} when command " + i + " does not yet exist; use \\newcommand"
			);
		var l = 0;
		if (((a = r.consumeArg().tokens), a.length === 1 && a[0].text === "[")) {
			for (var u = "", d = r.expandNextToken(); d.text !== "]" && d.text !== "EOF"; )
				(u += d.text), (d = r.expandNextToken());
			if (!u.match(/^\s*[0-9]+\s*$/)) throw new A("Invalid number of arguments: " + u);
			(l = parseInt(u)), (a = r.consumeArg().tokens);
		}
		return (s && n) || r.macros.set(i, { tokens: a, numArgs: l }), "";
	};
	m("\\newcommand", (r) => Q0(r, !1, !0, !1)),
		m("\\renewcommand", (r) => Q0(r, !0, !1, !1)),
		m("\\providecommand", (r) => Q0(r, !0, !0, !0)),
		m("\\message", (r) => {
			var e = r.consumeArgs(1)[0];
			return (
				console.log(
					e
						.reverse()
						.map((t) => t.text)
						.join("")
				),
				""
			);
		}),
		m("\\errmessage", (r) => {
			var e = r.consumeArgs(1)[0];
			return (
				console.error(
					e
						.reverse()
						.map((t) => t.text)
						.join("")
				),
				""
			);
		}),
		m("\\show", (r) => {
			var e = r.popToken(),
				t = e.text;
			return console.log(e, r.macros.get(t), Ct[t], fe.math[t], fe.text[t]), "";
		}),
		m("\\bgroup", "{"),
		m("\\egroup", "}"),
		m("~", "\\nobreakspace"),
		m("\\lq", "`"),
		m("\\rq", "'"),
		m("\\aa", "\\r a"),
		m("\\AA", "\\r A"),
		m("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`©}"),
		m("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}"),
		m("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`®}"),
		m("ℬ", "\\mathscr{B}"),
		m("ℰ", "\\mathscr{E}"),
		m("ℱ", "\\mathscr{F}"),
		m("ℋ", "\\mathscr{H}"),
		m("ℐ", "\\mathscr{I}"),
		m("ℒ", "\\mathscr{L}"),
		m("ℳ", "\\mathscr{M}"),
		m("ℛ", "\\mathscr{R}"),
		m("ℭ", "\\mathfrak{C}"),
		m("ℌ", "\\mathfrak{H}"),
		m("ℨ", "\\mathfrak{Z}"),
		m("\\Bbbk", "\\Bbb{k}"),
		m("·", "\\cdotp"),
		m("\\llap", "\\mathllap{\\textrm{#1}}"),
		m("\\rlap", "\\mathrlap{\\textrm{#1}}"),
		m("\\clap", "\\mathclap{\\textrm{#1}}"),
		m("\\mathstrut", "\\vphantom{(}"),
		m("\\underbar", "\\underline{\\text{#1}}"),
		m("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}'),
		m("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`≠}}"),
		m("\\ne", "\\neq"),
		m("≠", "\\neq"),
		m("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`∉}}"),
		m("∉", "\\notin"),
		m(
			"≘",
			"\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`≘}}"
		),
		m("≙", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`≘}}"),
		m("≚", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`≚}}"),
		m("≛", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`≛}}"),
		m("≝", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`≝}}"),
		m("≞", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`≞}}"),
		m("≟", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`≟}}"),
		m("⟂", "\\perp"),
		m("‼", "\\mathclose{!\\mkern-0.8mu!}"),
		m("∌", "\\notni"),
		m("⌜", "\\ulcorner"),
		m("⌝", "\\urcorner"),
		m("⌞", "\\llcorner"),
		m("⌟", "\\lrcorner"),
		m("©", "\\copyright"),
		m("®", "\\textregistered"),
		m("️", "\\textregistered"),
		m("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}'),
		m("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}'),
		m("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}'),
		m("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}'),
		m("\\vdots", "{\\varvdots\\rule{0pt}{15pt}}"),
		m("⋮", "\\vdots"),
		m("\\varGamma", "\\mathit{\\Gamma}"),
		m("\\varDelta", "\\mathit{\\Delta}"),
		m("\\varTheta", "\\mathit{\\Theta}"),
		m("\\varLambda", "\\mathit{\\Lambda}"),
		m("\\varXi", "\\mathit{\\Xi}"),
		m("\\varPi", "\\mathit{\\Pi}"),
		m("\\varSigma", "\\mathit{\\Sigma}"),
		m("\\varUpsilon", "\\mathit{\\Upsilon}"),
		m("\\varPhi", "\\mathit{\\Phi}"),
		m("\\varPsi", "\\mathit{\\Psi}"),
		m("\\varOmega", "\\mathit{\\Omega}"),
		m("\\substack", "\\begin{subarray}{c}#1\\end{subarray}"),
		m(
			"\\colon",
			"\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax"
		),
		m("\\boxed", "\\fbox{$\\displaystyle{#1}$}"),
		m("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;"),
		m("\\implies", "\\DOTSB\\;\\Longrightarrow\\;"),
		m("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;"),
		m("\\dddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ...}}{#1}}"),
		m("\\ddddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ....}}{#1}}");
	var Ka = {
		",": "\\dotsc",
		"\\not": "\\dotsb",
		"+": "\\dotsb",
		"=": "\\dotsb",
		"<": "\\dotsb",
		">": "\\dotsb",
		"-": "\\dotsb",
		"*": "\\dotsb",
		":": "\\dotsb",
		"\\DOTSB": "\\dotsb",
		"\\coprod": "\\dotsb",
		"\\bigvee": "\\dotsb",
		"\\bigwedge": "\\dotsb",
		"\\biguplus": "\\dotsb",
		"\\bigcap": "\\dotsb",
		"\\bigcup": "\\dotsb",
		"\\prod": "\\dotsb",
		"\\sum": "\\dotsb",
		"\\bigotimes": "\\dotsb",
		"\\bigoplus": "\\dotsb",
		"\\bigodot": "\\dotsb",
		"\\bigsqcup": "\\dotsb",
		"\\And": "\\dotsb",
		"\\longrightarrow": "\\dotsb",
		"\\Longrightarrow": "\\dotsb",
		"\\longleftarrow": "\\dotsb",
		"\\Longleftarrow": "\\dotsb",
		"\\longleftrightarrow": "\\dotsb",
		"\\Longleftrightarrow": "\\dotsb",
		"\\mapsto": "\\dotsb",
		"\\longmapsto": "\\dotsb",
		"\\hookrightarrow": "\\dotsb",
		"\\doteq": "\\dotsb",
		"\\mathbin": "\\dotsb",
		"\\mathrel": "\\dotsb",
		"\\relbar": "\\dotsb",
		"\\Relbar": "\\dotsb",
		"\\xrightarrow": "\\dotsb",
		"\\xleftarrow": "\\dotsb",
		"\\DOTSI": "\\dotsi",
		"\\int": "\\dotsi",
		"\\oint": "\\dotsi",
		"\\iint": "\\dotsi",
		"\\iiint": "\\dotsi",
		"\\iiiint": "\\dotsi",
		"\\idotsint": "\\dotsi",
		"\\DOTSX": "\\dotsx",
	};
	m("\\dots", function (r) {
		var e = "\\dotso",
			t = r.expandAfterFuture().text;
		return (
			t in Ka
				? (e = Ka[t])
				: (t.slice(0, 4) === "\\not" ||
						(t in fe.math && V.contains(["bin", "rel"], fe.math[t].group))) &&
					(e = "\\dotsb"),
			e
		);
	});
	var J0 = {
		")": !0,
		"]": !0,
		"\\rbrack": !0,
		"\\}": !0,
		"\\rbrace": !0,
		"\\rangle": !0,
		"\\rceil": !0,
		"\\rfloor": !0,
		"\\rgroup": !0,
		"\\rmoustache": !0,
		"\\right": !0,
		"\\bigr": !0,
		"\\biggr": !0,
		"\\Bigr": !0,
		"\\Biggr": !0,
		$: !0,
		";": !0,
		".": !0,
		",": !0,
	};
	m("\\dotso", function (r) {
		var e = r.future().text;
		return e in J0 ? "\\ldots\\," : "\\ldots";
	}),
		m("\\dotsc", function (r) {
			var e = r.future().text;
			return e in J0 && e !== "," ? "\\ldots\\," : "\\ldots";
		}),
		m("\\cdots", function (r) {
			var e = r.future().text;
			return e in J0 ? "\\@cdots\\," : "\\@cdots";
		}),
		m("\\dotsb", "\\cdots"),
		m("\\dotsm", "\\cdots"),
		m("\\dotsi", "\\!\\cdots"),
		m("\\dotsx", "\\ldots\\,"),
		m("\\DOTSI", "\\relax"),
		m("\\DOTSB", "\\relax"),
		m("\\DOTSX", "\\relax"),
		m("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax"),
		m("\\,", "\\tmspace+{3mu}{.1667em}"),
		m("\\thinspace", "\\,"),
		m("\\>", "\\mskip{4mu}"),
		m("\\:", "\\tmspace+{4mu}{.2222em}"),
		m("\\medspace", "\\:"),
		m("\\;", "\\tmspace+{5mu}{.2777em}"),
		m("\\thickspace", "\\;"),
		m("\\!", "\\tmspace-{3mu}{.1667em}"),
		m("\\negthinspace", "\\!"),
		m("\\negmedspace", "\\tmspace-{4mu}{.2222em}"),
		m("\\negthickspace", "\\tmspace-{5mu}{.277em}"),
		m("\\enspace", "\\kern.5em "),
		m("\\enskip", "\\hskip.5em\\relax"),
		m("\\quad", "\\hskip1em\\relax"),
		m("\\qquad", "\\hskip2em\\relax"),
		m("\\tag", "\\@ifstar\\tag@literal\\tag@paren"),
		m("\\tag@paren", "\\tag@literal{({#1})}"),
		m("\\tag@literal", (r) => {
			if (r.macros.get("\\df@tag")) throw new A("Multiple \\tag");
			return "\\gdef\\df@tag{\\text{#1}}";
		}),
		m(
			"\\bmod",
			"\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}"
		),
		m("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)"),
		m("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}"),
		m(
			"\\mod",
			"\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1"
		),
		m("\\newline", "\\\\\\relax"),
		m("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
	var Va = R(lt["Main-Regular"][84][1] - 0.7 * lt["Main-Regular"][65][1]);
	m(
		"\\LaTeX",
		"\\textrm{\\html@mathml{" +
			("L\\kern-.36em\\raisebox{" + Va + "}{\\scriptstyle A}") +
			"\\kern-.15em\\TeX}{LaTeX}}"
	),
		m(
			"\\KaTeX",
			"\\textrm{\\html@mathml{" +
				("K\\kern-.17em\\raisebox{" + Va + "}{\\scriptstyle A}") +
				"\\kern-.15em\\TeX}{KaTeX}}"
		),
		m("\\hspace", "\\@ifstar\\@hspacer\\@hspace"),
		m("\\@hspace", "\\hskip #1\\relax"),
		m("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax"),
		m("\\ordinarycolon", ":"),
		m("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}"),
		m(
			"\\dblcolon",
			'\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}'
		),
		m(
			"\\coloneqq",
			'\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}'
		),
		m(
			"\\Coloneqq",
			'\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}'
		),
		m(
			"\\coloneq",
			'\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}'
		),
		m(
			"\\Coloneq",
			'\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}'
		),
		m(
			"\\eqqcolon",
			'\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}'
		),
		m(
			"\\Eqqcolon",
			'\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}'
		),
		m(
			"\\eqcolon",
			'\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}'
		),
		m(
			"\\Eqcolon",
			'\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}'
		),
		m(
			"\\colonapprox",
			'\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}'
		),
		m(
			"\\Colonapprox",
			'\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}'
		),
		m(
			"\\colonsim",
			'\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}'
		),
		m(
			"\\Colonsim",
			'\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}'
		),
		m("∷", "\\dblcolon"),
		m("∹", "\\eqcolon"),
		m("≔", "\\coloneqq"),
		m("≕", "\\eqqcolon"),
		m("⩴", "\\Coloneqq"),
		m("\\ratio", "\\vcentcolon"),
		m("\\coloncolon", "\\dblcolon"),
		m("\\colonequals", "\\coloneqq"),
		m("\\coloncolonequals", "\\Coloneqq"),
		m("\\equalscolon", "\\eqqcolon"),
		m("\\equalscoloncolon", "\\Eqqcolon"),
		m("\\colonminus", "\\coloneq"),
		m("\\coloncolonminus", "\\Coloneq"),
		m("\\minuscolon", "\\eqcolon"),
		m("\\minuscoloncolon", "\\Eqcolon"),
		m("\\coloncolonapprox", "\\Colonapprox"),
		m("\\coloncolonsim", "\\Colonsim"),
		m("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}"),
		m("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}"),
		m("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}"),
		m("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}"),
		m("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`∌}}"),
		m("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}"),
		m("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}"),
		m("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}"),
		m("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}"),
		m("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}"),
		m("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}"),
		m("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}"),
		m("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}"),
		m("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{≩}"),
		m("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{≨}"),
		m("\\ngeqq", "\\html@mathml{\\@ngeqq}{≱}"),
		m("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{≱}"),
		m("\\nleqq", "\\html@mathml{\\@nleqq}{≰}"),
		m("\\nleqslant", "\\html@mathml{\\@nleqslant}{≰}"),
		m("\\nshortmid", "\\html@mathml{\\@nshortmid}{∤}"),
		m("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{∦}"),
		m("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{⊈}"),
		m("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{⊉}"),
		m("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{⊊}"),
		m("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{⫋}"),
		m("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{⊋}"),
		m("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{⫌}"),
		m("\\imath", "\\html@mathml{\\@imath}{ı}"),
		m("\\jmath", "\\html@mathml{\\@jmath}{ȷ}"),
		m("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`⟦}}"),
		m("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`⟧}}"),
		m("⟦", "\\llbracket"),
		m("⟧", "\\rrbracket"),
		m("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`⦃}}"),
		m("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`⦄}}"),
		m("⦃", "\\lBrace"),
		m("⦄", "\\rBrace"),
		m(
			"\\minuso",
			"\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`⦵}}"
		),
		m("⦵", "\\minuso"),
		m("\\darr", "\\downarrow"),
		m("\\dArr", "\\Downarrow"),
		m("\\Darr", "\\Downarrow"),
		m("\\lang", "\\langle"),
		m("\\rang", "\\rangle"),
		m("\\uarr", "\\uparrow"),
		m("\\uArr", "\\Uparrow"),
		m("\\Uarr", "\\Uparrow"),
		m("\\N", "\\mathbb{N}"),
		m("\\R", "\\mathbb{R}"),
		m("\\Z", "\\mathbb{Z}"),
		m("\\alef", "\\aleph"),
		m("\\alefsym", "\\aleph"),
		m("\\Alpha", "\\mathrm{A}"),
		m("\\Beta", "\\mathrm{B}"),
		m("\\bull", "\\bullet"),
		m("\\Chi", "\\mathrm{X}"),
		m("\\clubs", "\\clubsuit"),
		m("\\cnums", "\\mathbb{C}"),
		m("\\Complex", "\\mathbb{C}"),
		m("\\Dagger", "\\ddagger"),
		m("\\diamonds", "\\diamondsuit"),
		m("\\empty", "\\emptyset"),
		m("\\Epsilon", "\\mathrm{E}"),
		m("\\Eta", "\\mathrm{H}"),
		m("\\exist", "\\exists"),
		m("\\harr", "\\leftrightarrow"),
		m("\\hArr", "\\Leftrightarrow"),
		m("\\Harr", "\\Leftrightarrow"),
		m("\\hearts", "\\heartsuit"),
		m("\\image", "\\Im"),
		m("\\infin", "\\infty"),
		m("\\Iota", "\\mathrm{I}"),
		m("\\isin", "\\in"),
		m("\\Kappa", "\\mathrm{K}"),
		m("\\larr", "\\leftarrow"),
		m("\\lArr", "\\Leftarrow"),
		m("\\Larr", "\\Leftarrow"),
		m("\\lrarr", "\\leftrightarrow"),
		m("\\lrArr", "\\Leftrightarrow"),
		m("\\Lrarr", "\\Leftrightarrow"),
		m("\\Mu", "\\mathrm{M}"),
		m("\\natnums", "\\mathbb{N}"),
		m("\\Nu", "\\mathrm{N}"),
		m("\\Omicron", "\\mathrm{O}"),
		m("\\plusmn", "\\pm"),
		m("\\rarr", "\\rightarrow"),
		m("\\rArr", "\\Rightarrow"),
		m("\\Rarr", "\\Rightarrow"),
		m("\\real", "\\Re"),
		m("\\reals", "\\mathbb{R}"),
		m("\\Reals", "\\mathbb{R}"),
		m("\\Rho", "\\mathrm{P}"),
		m("\\sdot", "\\cdot"),
		m("\\sect", "\\S"),
		m("\\spades", "\\spadesuit"),
		m("\\sub", "\\subset"),
		m("\\sube", "\\subseteq"),
		m("\\supe", "\\supseteq"),
		m("\\Tau", "\\mathrm{T}"),
		m("\\thetasym", "\\vartheta"),
		m("\\weierp", "\\wp"),
		m("\\Zeta", "\\mathrm{Z}"),
		m("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}"),
		m("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}"),
		m("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits"),
		m("\\bra", "\\mathinner{\\langle{#1}|}"),
		m("\\ket", "\\mathinner{|{#1}\\rangle}"),
		m("\\braket", "\\mathinner{\\langle{#1}\\rangle}"),
		m("\\Bra", "\\left\\langle#1\\right|"),
		m("\\Ket", "\\left|#1\\right\\rangle");
	var Wa = (r) => (e) => {
		var t = e.consumeArg().tokens,
			n = e.consumeArg().tokens,
			a = e.consumeArg().tokens,
			i = e.consumeArg().tokens,
			s = e.macros.get("|"),
			l = e.macros.get("\\|");
		e.macros.beginGroup();
		var u = (f) => (v) => {
			r && (v.macros.set("|", s), a.length && v.macros.set("\\|", l));
			var x = f;
			if (!f && a.length) {
				var _ = v.future();
				_.text === "|" && (v.popToken(), (x = !0));
			}
			return { tokens: x ? a : n, numArgs: 0 };
		};
		e.macros.set("|", u(!1)), a.length && e.macros.set("\\|", u(!0));
		var d = e.consumeArg().tokens,
			p = e.expandTokens([...i, ...d, ...t]);
		return e.macros.endGroup(), { tokens: p.reverse(), numArgs: 0 };
	};
	m("\\bra@ket", Wa(!1)),
		m("\\bra@set", Wa(!0)),
		m(
			"\\Braket",
			"\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}"
		),
		m(
			"\\Set",
			"\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}"
		),
		m("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}"),
		m("\\angln", "{\\angl n}"),
		m("\\blue", "\\textcolor{##6495ed}{#1}"),
		m("\\orange", "\\textcolor{##ffa500}{#1}"),
		m("\\pink", "\\textcolor{##ff00af}{#1}"),
		m("\\red", "\\textcolor{##df0030}{#1}"),
		m("\\green", "\\textcolor{##28ae7b}{#1}"),
		m("\\gray", "\\textcolor{gray}{#1}"),
		m("\\purple", "\\textcolor{##9d38bd}{#1}"),
		m("\\blueA", "\\textcolor{##ccfaff}{#1}"),
		m("\\blueB", "\\textcolor{##80f6ff}{#1}"),
		m("\\blueC", "\\textcolor{##63d9ea}{#1}"),
		m("\\blueD", "\\textcolor{##11accd}{#1}"),
		m("\\blueE", "\\textcolor{##0c7f99}{#1}"),
		m("\\tealA", "\\textcolor{##94fff5}{#1}"),
		m("\\tealB", "\\textcolor{##26edd5}{#1}"),
		m("\\tealC", "\\textcolor{##01d1c1}{#1}"),
		m("\\tealD", "\\textcolor{##01a995}{#1}"),
		m("\\tealE", "\\textcolor{##208170}{#1}"),
		m("\\greenA", "\\textcolor{##b6ffb0}{#1}"),
		m("\\greenB", "\\textcolor{##8af281}{#1}"),
		m("\\greenC", "\\textcolor{##74cf70}{#1}"),
		m("\\greenD", "\\textcolor{##1fab54}{#1}"),
		m("\\greenE", "\\textcolor{##0d923f}{#1}"),
		m("\\goldA", "\\textcolor{##ffd0a9}{#1}"),
		m("\\goldB", "\\textcolor{##ffbb71}{#1}"),
		m("\\goldC", "\\textcolor{##ff9c39}{#1}"),
		m("\\goldD", "\\textcolor{##e07d10}{#1}"),
		m("\\goldE", "\\textcolor{##a75a05}{#1}"),
		m("\\redA", "\\textcolor{##fca9a9}{#1}"),
		m("\\redB", "\\textcolor{##ff8482}{#1}"),
		m("\\redC", "\\textcolor{##f9685d}{#1}"),
		m("\\redD", "\\textcolor{##e84d39}{#1}"),
		m("\\redE", "\\textcolor{##bc2612}{#1}"),
		m("\\maroonA", "\\textcolor{##ffbde0}{#1}"),
		m("\\maroonB", "\\textcolor{##ff92c6}{#1}"),
		m("\\maroonC", "\\textcolor{##ed5fa6}{#1}"),
		m("\\maroonD", "\\textcolor{##ca337c}{#1}"),
		m("\\maroonE", "\\textcolor{##9e034e}{#1}"),
		m("\\purpleA", "\\textcolor{##ddd7ff}{#1}"),
		m("\\purpleB", "\\textcolor{##c6b9fc}{#1}"),
		m("\\purpleC", "\\textcolor{##aa87ff}{#1}"),
		m("\\purpleD", "\\textcolor{##7854ab}{#1}"),
		m("\\purpleE", "\\textcolor{##543b78}{#1}"),
		m("\\mintA", "\\textcolor{##f5f9e8}{#1}"),
		m("\\mintB", "\\textcolor{##edf2df}{#1}"),
		m("\\mintC", "\\textcolor{##e0e5cc}{#1}"),
		m("\\grayA", "\\textcolor{##f6f7f7}{#1}"),
		m("\\grayB", "\\textcolor{##f0f1f2}{#1}"),
		m("\\grayC", "\\textcolor{##e3e5e6}{#1}"),
		m("\\grayD", "\\textcolor{##d6d8da}{#1}"),
		m("\\grayE", "\\textcolor{##babec2}{#1}"),
		m("\\grayF", "\\textcolor{##888d93}{#1}"),
		m("\\grayG", "\\textcolor{##626569}{#1}"),
		m("\\grayH", "\\textcolor{##3b3e40}{#1}"),
		m("\\grayI", "\\textcolor{##21242c}{#1}"),
		m("\\kaBlue", "\\textcolor{##314453}{#1}"),
		m("\\kaGreen", "\\textcolor{##71B307}{#1}");
	var Za = { "^": !0, _: !0, "\\limits": !0, "\\nolimits": !0 };
	class Yo {
		constructor(e, t, n) {
			(this.settings = void 0),
				(this.expansionCount = void 0),
				(this.lexer = void 0),
				(this.macros = void 0),
				(this.stack = void 0),
				(this.mode = void 0),
				(this.settings = t),
				(this.expansionCount = 0),
				this.feed(e),
				(this.macros = new Zo(Xo, t.macros)),
				(this.mode = n),
				(this.stack = []);
		}
		feed(e) {
			this.lexer = new Ua(e, this.settings);
		}
		switchMode(e) {
			this.mode = e;
		}
		beginGroup() {
			this.macros.beginGroup();
		}
		endGroup() {
			this.macros.endGroup();
		}
		endGroups() {
			this.macros.endGroups();
		}
		future() {
			return (
				this.stack.length === 0 && this.pushToken(this.lexer.lex()),
				this.stack[this.stack.length - 1]
			);
		}
		popToken() {
			return this.future(), this.stack.pop();
		}
		pushToken(e) {
			this.stack.push(e);
		}
		pushTokens(e) {
			this.stack.push(...e);
		}
		scanArgument(e) {
			var t, n, a;
			if (e) {
				if ((this.consumeSpaces(), this.future().text !== "[")) return null;
				(t = this.popToken()), ({ tokens: a, end: n } = this.consumeArg(["]"]));
			} else ({ tokens: a, start: t, end: n } = this.consumeArg());
			return this.pushToken(new ce("EOF", n.loc)), this.pushTokens(a), t.range(n, "");
		}
		consumeSpaces() {
			for (;;) {
				var e = this.future();
				if (e.text === " ") this.stack.pop();
				else break;
			}
		}
		consumeArg(e) {
			var t = [],
				n = e && e.length > 0;
			n || this.consumeSpaces();
			var a = this.future(),
				i,
				s = 0,
				l = 0;
			do {
				if (((i = this.popToken()), t.push(i), i.text === "{")) ++s;
				else if (i.text === "}") {
					if ((--s, s === -1)) throw new A("Extra }", i);
				} else if (i.text === "EOF")
					throw new A(
						"Unexpected end of input in a macro argument, expected '" + (e && n ? e[l] : "}") + "'",
						i
					);
				if (e && n)
					if ((s === 0 || (s === 1 && e[l] === "{")) && i.text === e[l]) {
						if ((++l, l === e.length)) {
							t.splice(-l, l);
							break;
						}
					} else l = 0;
			} while (s !== 0 || n);
			return (
				a.text === "{" && t[t.length - 1].text === "}" && (t.pop(), t.shift()),
				t.reverse(),
				{ tokens: t, start: a, end: i }
			);
		}
		consumeArgs(e, t) {
			if (t) {
				if (t.length !== e + 1)
					throw new A("The length of delimiters doesn't match the number of args!");
				for (var n = t[0], a = 0; a < n.length; a++) {
					var i = this.popToken();
					if (n[a] !== i.text) throw new A("Use of the macro doesn't match its definition", i);
				}
			}
			for (var s = [], l = 0; l < e; l++) s.push(this.consumeArg(t && t[l + 1]).tokens);
			return s;
		}
		countExpansion(e) {
			if (((this.expansionCount += e), this.expansionCount > this.settings.maxExpand))
				throw new A("Too many expansions: infinite loop or need to increase maxExpand setting");
		}
		expandOnce(e) {
			var t = this.popToken(),
				n = t.text,
				a = t.noexpand ? null : this._getExpansion(n);
			if (a == null || (e && a.unexpandable)) {
				if (e && a == null && n[0] === "\\" && !this.isDefined(n))
					throw new A("Undefined control sequence: " + n);
				return this.pushToken(t), !1;
			}
			this.countExpansion(1);
			var i = a.tokens,
				s = this.consumeArgs(a.numArgs, a.delimiters);
			if (a.numArgs) {
				i = i.slice();
				for (var l = i.length - 1; l >= 0; --l) {
					var u = i[l];
					if (u.text === "#") {
						if (l === 0) throw new A("Incomplete placeholder at end of macro body", u);
						if (((u = i[--l]), u.text === "#")) i.splice(l + 1, 1);
						else if (/^[1-9]$/.test(u.text)) i.splice(l, 2, ...s[+u.text - 1]);
						else throw new A("Not a valid argument number", u);
					}
				}
			}
			return this.pushTokens(i), i.length;
		}
		expandAfterFuture() {
			return this.expandOnce(), this.future();
		}
		expandNextToken() {
			for (;;)
				if (this.expandOnce() === !1) {
					var e = this.stack.pop();
					return e.treatAsRelax && (e.text = "\\relax"), e;
				}
			throw new Error();
		}
		expandMacro(e) {
			return this.macros.has(e) ? this.expandTokens([new ce(e)]) : void 0;
		}
		expandTokens(e) {
			var t = [],
				n = this.stack.length;
			for (this.pushTokens(e); this.stack.length > n; )
				if (this.expandOnce(!0) === !1) {
					var a = this.stack.pop();
					a.treatAsRelax && ((a.noexpand = !1), (a.treatAsRelax = !1)), t.push(a);
				}
			return this.countExpansion(t.length), t;
		}
		expandMacroAsText(e) {
			var t = this.expandMacro(e);
			return t && t.map((n) => n.text).join("");
		}
		_getExpansion(e) {
			var t = this.macros.get(e);
			if (t == null) return t;
			if (e.length === 1) {
				var n = this.lexer.catcodes[e];
				if (n != null && n !== 13) return;
			}
			var a = typeof t == "function" ? t(this) : t;
			if (typeof a == "string") {
				var i = 0;
				if (a.indexOf("#") !== -1)
					for (var s = a.replace(/##/g, ""); s.indexOf("#" + (i + 1)) !== -1; ) ++i;
				for (var l = new Ua(a, this.settings), u = [], d = l.lex(); d.text !== "EOF"; )
					u.push(d), (d = l.lex());
				u.reverse();
				var p = { tokens: u, numArgs: i };
				return p;
			}
			return a;
		}
		isDefined(e) {
			return (
				this.macros.has(e) ||
				Ct.hasOwnProperty(e) ||
				fe.math.hasOwnProperty(e) ||
				fe.text.hasOwnProperty(e) ||
				Za.hasOwnProperty(e)
			);
		}
		isExpandable(e) {
			var t = this.macros.get(e);
			return t != null
				? typeof t == "string" || typeof t == "function" || !t.unexpandable
				: Ct.hasOwnProperty(e) && !Ct[e].primitive;
		}
	}
	var Xa = /^[₊₋₌₍₎₀₁₂₃₄₅₆₇₈₉ₐₑₕᵢⱼₖₗₘₙₒₚᵣₛₜᵤᵥₓᵦᵧᵨᵩᵪ]/,
		Gr = Object.freeze({
			"₊": "+",
			"₋": "-",
			"₌": "=",
			"₍": "(",
			"₎": ")",
			"₀": "0",
			"₁": "1",
			"₂": "2",
			"₃": "3",
			"₄": "4",
			"₅": "5",
			"₆": "6",
			"₇": "7",
			"₈": "8",
			"₉": "9",
			ₐ: "a",
			ₑ: "e",
			ₕ: "h",
			ᵢ: "i",
			ⱼ: "j",
			ₖ: "k",
			ₗ: "l",
			ₘ: "m",
			ₙ: "n",
			ₒ: "o",
			ₚ: "p",
			ᵣ: "r",
			ₛ: "s",
			ₜ: "t",
			ᵤ: "u",
			ᵥ: "v",
			ₓ: "x",
			ᵦ: "β",
			ᵧ: "γ",
			ᵨ: "ρ",
			ᵩ: "ϕ",
			ᵪ: "χ",
			"⁺": "+",
			"⁻": "-",
			"⁼": "=",
			"⁽": "(",
			"⁾": ")",
			"⁰": "0",
			"¹": "1",
			"²": "2",
			"³": "3",
			"⁴": "4",
			"⁵": "5",
			"⁶": "6",
			"⁷": "7",
			"⁸": "8",
			"⁹": "9",
			ᴬ: "A",
			ᴮ: "B",
			ᴰ: "D",
			ᴱ: "E",
			ᴳ: "G",
			ᴴ: "H",
			ᴵ: "I",
			ᴶ: "J",
			ᴷ: "K",
			ᴸ: "L",
			ᴹ: "M",
			ᴺ: "N",
			ᴼ: "O",
			ᴾ: "P",
			ᴿ: "R",
			ᵀ: "T",
			ᵁ: "U",
			ⱽ: "V",
			ᵂ: "W",
			ᵃ: "a",
			ᵇ: "b",
			ᶜ: "c",
			ᵈ: "d",
			ᵉ: "e",
			ᶠ: "f",
			ᵍ: "g",
			ʰ: "h",
			ⁱ: "i",
			ʲ: "j",
			ᵏ: "k",
			ˡ: "l",
			ᵐ: "m",
			ⁿ: "n",
			ᵒ: "o",
			ᵖ: "p",
			ʳ: "r",
			ˢ: "s",
			ᵗ: "t",
			ᵘ: "u",
			ᵛ: "v",
			ʷ: "w",
			ˣ: "x",
			ʸ: "y",
			ᶻ: "z",
			ᵝ: "β",
			ᵞ: "γ",
			ᵟ: "δ",
			ᵠ: "ϕ",
			ᵡ: "χ",
			ᶿ: "θ",
		}),
		j0 = {
			"́": { text: "\\'", math: "\\acute" },
			"̀": { text: "\\`", math: "\\grave" },
			"̈": { text: '\\"', math: "\\ddot" },
			"̃": { text: "\\~", math: "\\tilde" },
			"̄": { text: "\\=", math: "\\bar" },
			"̆": { text: "\\u", math: "\\breve" },
			"̌": { text: "\\v", math: "\\check" },
			"̂": { text: "\\^", math: "\\hat" },
			"̇": { text: "\\.", math: "\\dot" },
			"̊": { text: "\\r", math: "\\mathring" },
			"̋": { text: "\\H" },
			"̧": { text: "\\c" },
		},
		Ya = {
			á: "á",
			à: "à",
			ä: "ä",
			ǟ: "ǟ",
			ã: "ã",
			ā: "ā",
			ă: "ă",
			ắ: "ắ",
			ằ: "ằ",
			ẵ: "ẵ",
			ǎ: "ǎ",
			â: "â",
			ấ: "ấ",
			ầ: "ầ",
			ẫ: "ẫ",
			ȧ: "ȧ",
			ǡ: "ǡ",
			å: "å",
			ǻ: "ǻ",
			ḃ: "ḃ",
			ć: "ć",
			ḉ: "ḉ",
			č: "č",
			ĉ: "ĉ",
			ċ: "ċ",
			ç: "ç",
			ď: "ď",
			ḋ: "ḋ",
			ḑ: "ḑ",
			é: "é",
			è: "è",
			ë: "ë",
			ẽ: "ẽ",
			ē: "ē",
			ḗ: "ḗ",
			ḕ: "ḕ",
			ĕ: "ĕ",
			ḝ: "ḝ",
			ě: "ě",
			ê: "ê",
			ế: "ế",
			ề: "ề",
			ễ: "ễ",
			ė: "ė",
			ȩ: "ȩ",
			ḟ: "ḟ",
			ǵ: "ǵ",
			ḡ: "ḡ",
			ğ: "ğ",
			ǧ: "ǧ",
			ĝ: "ĝ",
			ġ: "ġ",
			ģ: "ģ",
			ḧ: "ḧ",
			ȟ: "ȟ",
			ĥ: "ĥ",
			ḣ: "ḣ",
			ḩ: "ḩ",
			í: "í",
			ì: "ì",
			ï: "ï",
			ḯ: "ḯ",
			ĩ: "ĩ",
			ī: "ī",
			ĭ: "ĭ",
			ǐ: "ǐ",
			î: "î",
			ǰ: "ǰ",
			ĵ: "ĵ",
			ḱ: "ḱ",
			ǩ: "ǩ",
			ķ: "ķ",
			ĺ: "ĺ",
			ľ: "ľ",
			ļ: "ļ",
			ḿ: "ḿ",
			ṁ: "ṁ",
			ń: "ń",
			ǹ: "ǹ",
			ñ: "ñ",
			ň: "ň",
			ṅ: "ṅ",
			ņ: "ņ",
			ó: "ó",
			ò: "ò",
			ö: "ö",
			ȫ: "ȫ",
			õ: "õ",
			ṍ: "ṍ",
			ṏ: "ṏ",
			ȭ: "ȭ",
			ō: "ō",
			ṓ: "ṓ",
			ṑ: "ṑ",
			ŏ: "ŏ",
			ǒ: "ǒ",
			ô: "ô",
			ố: "ố",
			ồ: "ồ",
			ỗ: "ỗ",
			ȯ: "ȯ",
			ȱ: "ȱ",
			ő: "ő",
			ṕ: "ṕ",
			ṗ: "ṗ",
			ŕ: "ŕ",
			ř: "ř",
			ṙ: "ṙ",
			ŗ: "ŗ",
			ś: "ś",
			ṥ: "ṥ",
			š: "š",
			ṧ: "ṧ",
			ŝ: "ŝ",
			ṡ: "ṡ",
			ş: "ş",
			ẗ: "ẗ",
			ť: "ť",
			ṫ: "ṫ",
			ţ: "ţ",
			ú: "ú",
			ù: "ù",
			ü: "ü",
			ǘ: "ǘ",
			ǜ: "ǜ",
			ǖ: "ǖ",
			ǚ: "ǚ",
			ũ: "ũ",
			ṹ: "ṹ",
			ū: "ū",
			ṻ: "ṻ",
			ŭ: "ŭ",
			ǔ: "ǔ",
			û: "û",
			ů: "ů",
			ű: "ű",
			ṽ: "ṽ",
			ẃ: "ẃ",
			ẁ: "ẁ",
			ẅ: "ẅ",
			ŵ: "ŵ",
			ẇ: "ẇ",
			ẘ: "ẘ",
			ẍ: "ẍ",
			ẋ: "ẋ",
			ý: "ý",
			ỳ: "ỳ",
			ÿ: "ÿ",
			ỹ: "ỹ",
			ȳ: "ȳ",
			ŷ: "ŷ",
			ẏ: "ẏ",
			ẙ: "ẙ",
			ź: "ź",
			ž: "ž",
			ẑ: "ẑ",
			ż: "ż",
			Á: "Á",
			À: "À",
			Ä: "Ä",
			Ǟ: "Ǟ",
			Ã: "Ã",
			Ā: "Ā",
			Ă: "Ă",
			Ắ: "Ắ",
			Ằ: "Ằ",
			Ẵ: "Ẵ",
			Ǎ: "Ǎ",
			Â: "Â",
			Ấ: "Ấ",
			Ầ: "Ầ",
			Ẫ: "Ẫ",
			Ȧ: "Ȧ",
			Ǡ: "Ǡ",
			Å: "Å",
			Ǻ: "Ǻ",
			Ḃ: "Ḃ",
			Ć: "Ć",
			Ḉ: "Ḉ",
			Č: "Č",
			Ĉ: "Ĉ",
			Ċ: "Ċ",
			Ç: "Ç",
			Ď: "Ď",
			Ḋ: "Ḋ",
			Ḑ: "Ḑ",
			É: "É",
			È: "È",
			Ë: "Ë",
			Ẽ: "Ẽ",
			Ē: "Ē",
			Ḗ: "Ḗ",
			Ḕ: "Ḕ",
			Ĕ: "Ĕ",
			Ḝ: "Ḝ",
			Ě: "Ě",
			Ê: "Ê",
			Ế: "Ế",
			Ề: "Ề",
			Ễ: "Ễ",
			Ė: "Ė",
			Ȩ: "Ȩ",
			Ḟ: "Ḟ",
			Ǵ: "Ǵ",
			Ḡ: "Ḡ",
			Ğ: "Ğ",
			Ǧ: "Ǧ",
			Ĝ: "Ĝ",
			Ġ: "Ġ",
			Ģ: "Ģ",
			Ḧ: "Ḧ",
			Ȟ: "Ȟ",
			Ĥ: "Ĥ",
			Ḣ: "Ḣ",
			Ḩ: "Ḩ",
			Í: "Í",
			Ì: "Ì",
			Ï: "Ï",
			Ḯ: "Ḯ",
			Ĩ: "Ĩ",
			Ī: "Ī",
			Ĭ: "Ĭ",
			Ǐ: "Ǐ",
			Î: "Î",
			İ: "İ",
			Ĵ: "Ĵ",
			Ḱ: "Ḱ",
			Ǩ: "Ǩ",
			Ķ: "Ķ",
			Ĺ: "Ĺ",
			Ľ: "Ľ",
			Ļ: "Ļ",
			Ḿ: "Ḿ",
			Ṁ: "Ṁ",
			Ń: "Ń",
			Ǹ: "Ǹ",
			Ñ: "Ñ",
			Ň: "Ň",
			Ṅ: "Ṅ",
			Ņ: "Ņ",
			Ó: "Ó",
			Ò: "Ò",
			Ö: "Ö",
			Ȫ: "Ȫ",
			Õ: "Õ",
			Ṍ: "Ṍ",
			Ṏ: "Ṏ",
			Ȭ: "Ȭ",
			Ō: "Ō",
			Ṓ: "Ṓ",
			Ṑ: "Ṑ",
			Ŏ: "Ŏ",
			Ǒ: "Ǒ",
			Ô: "Ô",
			Ố: "Ố",
			Ồ: "Ồ",
			Ỗ: "Ỗ",
			Ȯ: "Ȯ",
			Ȱ: "Ȱ",
			Ő: "Ő",
			Ṕ: "Ṕ",
			Ṗ: "Ṗ",
			Ŕ: "Ŕ",
			Ř: "Ř",
			Ṙ: "Ṙ",
			Ŗ: "Ŗ",
			Ś: "Ś",
			Ṥ: "Ṥ",
			Š: "Š",
			Ṧ: "Ṧ",
			Ŝ: "Ŝ",
			Ṡ: "Ṡ",
			Ş: "Ş",
			Ť: "Ť",
			Ṫ: "Ṫ",
			Ţ: "Ţ",
			Ú: "Ú",
			Ù: "Ù",
			Ü: "Ü",
			Ǘ: "Ǘ",
			Ǜ: "Ǜ",
			Ǖ: "Ǖ",
			Ǚ: "Ǚ",
			Ũ: "Ũ",
			Ṹ: "Ṹ",
			Ū: "Ū",
			Ṻ: "Ṻ",
			Ŭ: "Ŭ",
			Ǔ: "Ǔ",
			Û: "Û",
			Ů: "Ů",
			Ű: "Ű",
			Ṽ: "Ṽ",
			Ẃ: "Ẃ",
			Ẁ: "Ẁ",
			Ẅ: "Ẅ",
			Ŵ: "Ŵ",
			Ẇ: "Ẇ",
			Ẍ: "Ẍ",
			Ẋ: "Ẋ",
			Ý: "Ý",
			Ỳ: "Ỳ",
			Ÿ: "Ÿ",
			Ỹ: "Ỹ",
			Ȳ: "Ȳ",
			Ŷ: "Ŷ",
			Ẏ: "Ẏ",
			Ź: "Ź",
			Ž: "Ž",
			Ẑ: "Ẑ",
			Ż: "Ż",
			ά: "ά",
			ὰ: "ὰ",
			ᾱ: "ᾱ",
			ᾰ: "ᾰ",
			έ: "έ",
			ὲ: "ὲ",
			ή: "ή",
			ὴ: "ὴ",
			ί: "ί",
			ὶ: "ὶ",
			ϊ: "ϊ",
			ΐ: "ΐ",
			ῒ: "ῒ",
			ῑ: "ῑ",
			ῐ: "ῐ",
			ό: "ό",
			ὸ: "ὸ",
			ύ: "ύ",
			ὺ: "ὺ",
			ϋ: "ϋ",
			ΰ: "ΰ",
			ῢ: "ῢ",
			ῡ: "ῡ",
			ῠ: "ῠ",
			ώ: "ώ",
			ὼ: "ὼ",
			Ύ: "Ύ",
			Ὺ: "Ὺ",
			Ϋ: "Ϋ",
			Ῡ: "Ῡ",
			Ῠ: "Ῠ",
			Ώ: "Ώ",
			Ὼ: "Ὼ",
		};
	class Kr {
		constructor(e, t) {
			(this.mode = void 0),
				(this.gullet = void 0),
				(this.settings = void 0),
				(this.leftrightDepth = void 0),
				(this.nextToken = void 0),
				(this.mode = "math"),
				(this.gullet = new Yo(e, t, this.mode)),
				(this.settings = t),
				(this.leftrightDepth = 0);
		}
		expect(e, t) {
			if ((t === void 0 && (t = !0), this.fetch().text !== e))
				throw new A("Expected '" + e + "', got '" + this.fetch().text + "'", this.fetch());
			t && this.consume();
		}
		consume() {
			this.nextToken = null;
		}
		fetch() {
			return (
				this.nextToken == null && (this.nextToken = this.gullet.expandNextToken()), this.nextToken
			);
		}
		switchMode(e) {
			(this.mode = e), this.gullet.switchMode(e);
		}
		parse() {
			this.settings.globalGroup || this.gullet.beginGroup(),
				this.settings.colorIsTextColor && this.gullet.macros.set("\\color", "\\textcolor");
			try {
				var e = this.parseExpression(!1);
				return this.expect("EOF"), this.settings.globalGroup || this.gullet.endGroup(), e;
			} finally {
				this.gullet.endGroups();
			}
		}
		subparse(e) {
			var t = this.nextToken;
			this.consume(), this.gullet.pushToken(new ce("}")), this.gullet.pushTokens(e);
			var n = this.parseExpression(!1);
			return this.expect("}"), (this.nextToken = t), n;
		}
		parseExpression(e, t) {
			for (var n = []; ; ) {
				this.mode === "math" && this.consumeSpaces();
				var a = this.fetch();
				if (
					Kr.endOfExpression.indexOf(a.text) !== -1 ||
					(t && a.text === t) ||
					(e && Ct[a.text] && Ct[a.text].infix)
				)
					break;
				var i = this.parseAtom(t);
				if (i) {
					if (i.type === "internal") continue;
				} else break;
				n.push(i);
			}
			return this.mode === "text" && this.formLigatures(n), this.handleInfixNodes(n);
		}
		handleInfixNodes(e) {
			for (var t = -1, n, a = 0; a < e.length; a++)
				if (e[a].type === "infix") {
					if (t !== -1) throw new A("only one infix operator per group", e[a].token);
					(t = a), (n = e[a].replaceWith);
				}
			if (t !== -1 && n) {
				var i,
					s,
					l = e.slice(0, t),
					u = e.slice(t + 1);
				l.length === 1 && l[0].type === "ordgroup"
					? (i = l[0])
					: (i = { type: "ordgroup", mode: this.mode, body: l }),
					u.length === 1 && u[0].type === "ordgroup"
						? (s = u[0])
						: (s = { type: "ordgroup", mode: this.mode, body: u });
				var d;
				return (
					n === "\\\\abovefrac"
						? (d = this.callFunction(n, [i, e[t], s], []))
						: (d = this.callFunction(n, [i, s], [])),
					[d]
				);
			} else return e;
		}
		handleSupSubscript(e) {
			var t = this.fetch(),
				n = t.text;
			this.consume(), this.consumeSpaces();
			var a;
			do {
				var i;
				a = this.parseGroup(e);
			} while (((i = a) == null ? void 0 : i.type) === "internal");
			if (!a) throw new A("Expected group after '" + n + "'", t);
			return a;
		}
		formatUnsupportedCmd(e) {
			for (var t = [], n = 0; n < e.length; n++)
				t.push({ type: "textord", mode: "text", text: e[n] });
			var a = { type: "text", mode: this.mode, body: t },
				i = { type: "color", mode: this.mode, color: this.settings.errorColor, body: [a] };
			return i;
		}
		parseAtom(e) {
			var t = this.parseGroup("atom", e);
			if ((t == null ? void 0 : t.type) === "internal" || this.mode === "text") return t;
			for (var n, a; ; ) {
				this.consumeSpaces();
				var i = this.fetch();
				if (i.text === "\\limits" || i.text === "\\nolimits") {
					if (t && t.type === "op") {
						var s = i.text === "\\limits";
						(t.limits = s), (t.alwaysHandleSupSub = !0);
					} else if (t && t.type === "operatorname")
						t.alwaysHandleSupSub && (t.limits = i.text === "\\limits");
					else throw new A("Limit controls must follow a math operator", i);
					this.consume();
				} else if (i.text === "^") {
					if (n) throw new A("Double superscript", i);
					n = this.handleSupSubscript("superscript");
				} else if (i.text === "_") {
					if (a) throw new A("Double subscript", i);
					a = this.handleSupSubscript("subscript");
				} else if (i.text === "'") {
					if (n) throw new A("Double superscript", i);
					var l = { type: "textord", mode: this.mode, text: "\\prime" },
						u = [l];
					for (this.consume(); this.fetch().text === "'"; ) u.push(l), this.consume();
					this.fetch().text === "^" && u.push(this.handleSupSubscript("superscript")),
						(n = { type: "ordgroup", mode: this.mode, body: u });
				} else if (Gr[i.text]) {
					var d = Xa.test(i.text),
						p = [];
					for (p.push(new ce(Gr[i.text])), this.consume(); ; ) {
						var f = this.fetch().text;
						if (!Gr[f] || Xa.test(f) !== d) break;
						p.unshift(new ce(Gr[f])), this.consume();
					}
					var v = this.subparse(p);
					d
						? (a = { type: "ordgroup", mode: "math", body: v })
						: (n = { type: "ordgroup", mode: "math", body: v });
				} else break;
			}
			return n || a ? { type: "supsub", mode: this.mode, base: t, sup: n, sub: a } : t;
		}
		parseFunction(e, t) {
			var n = this.fetch(),
				a = n.text,
				i = Ct[a];
			if (!i) return null;
			if ((this.consume(), t && t !== "atom" && !i.allowedInArgument))
				throw new A("Got function '" + a + "' with no arguments" + (t ? " as " + t : ""), n);
			if (this.mode === "text" && !i.allowedInText)
				throw new A("Can't use function '" + a + "' in text mode", n);
			if (this.mode === "math" && i.allowedInMath === !1)
				throw new A("Can't use function '" + a + "' in math mode", n);
			var { args: s, optArgs: l } = this.parseArguments(a, i);
			return this.callFunction(a, s, l, n, e);
		}
		callFunction(e, t, n, a, i) {
			var s = { funcName: e, parser: this, token: a, breakOnTokenText: i },
				l = Ct[e];
			if (l && l.handler) return l.handler(s, t, n);
			throw new A("No function handler for " + e);
		}
		parseArguments(e, t) {
			var n = t.numArgs + t.numOptionalArgs;
			if (n === 0) return { args: [], optArgs: [] };
			for (var a = [], i = [], s = 0; s < n; s++) {
				var l = t.argTypes && t.argTypes[s],
					u = s < t.numOptionalArgs;
				((t.primitive && l == null) || (t.type === "sqrt" && s === 1 && i[0] == null)) &&
					(l = "primitive");
				var d = this.parseGroupOfType("argument to '" + e + "'", l, u);
				if (u) i.push(d);
				else if (d != null) a.push(d);
				else throw new A("Null argument, please report this as a bug");
			}
			return { args: a, optArgs: i };
		}
		parseGroupOfType(e, t, n) {
			switch (t) {
				case "color":
					return this.parseColorGroup(n);
				case "size":
					return this.parseSizeGroup(n);
				case "url":
					return this.parseUrlGroup(n);
				case "math":
				case "text":
					return this.parseArgumentGroup(n, t);
				case "hbox": {
					var a = this.parseArgumentGroup(n, "text");
					return a != null ? { type: "styling", mode: a.mode, body: [a], style: "text" } : null;
				}
				case "raw": {
					var i = this.parseStringGroup("raw", n);
					return i != null ? { type: "raw", mode: "text", string: i.text } : null;
				}
				case "primitive": {
					if (n) throw new A("A primitive argument cannot be optional");
					var s = this.parseGroup(e);
					if (s == null) throw new A("Expected group as " + e, this.fetch());
					return s;
				}
				case "original":
				case null:
				case void 0:
					return this.parseArgumentGroup(n);
				default:
					throw new A("Unknown group type as " + e, this.fetch());
			}
		}
		consumeSpaces() {
			for (; this.fetch().text === " "; ) this.consume();
		}
		parseStringGroup(e, t) {
			var n = this.gullet.scanArgument(t);
			if (n == null) return null;
			for (var a = "", i; (i = this.fetch()).text !== "EOF"; ) (a += i.text), this.consume();
			return this.consume(), (n.text = a), n;
		}
		parseRegexGroup(e, t) {
			for (
				var n = this.fetch(), a = n, i = "", s;
				(s = this.fetch()).text !== "EOF" && e.test(i + s.text);

			)
				(a = s), (i += a.text), this.consume();
			if (i === "") throw new A("Invalid " + t + ": '" + n.text + "'", n);
			return n.range(a, i);
		}
		parseColorGroup(e) {
			var t = this.parseStringGroup("color", e);
			if (t == null) return null;
			var n = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(t.text);
			if (!n) throw new A("Invalid color: '" + t.text + "'", t);
			var a = n[0];
			return (
				/^[0-9a-f]{6}$/i.test(a) && (a = "#" + a),
				{ type: "color-token", mode: this.mode, color: a }
			);
		}
		parseSizeGroup(e) {
			var t,
				n = !1;
			if (
				(this.gullet.consumeSpaces(),
				!e && this.gullet.future().text !== "{"
					? (t = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size"))
					: (t = this.parseStringGroup("size", e)),
				!t)
			)
				return null;
			!e && t.text.length === 0 && ((t.text = "0pt"), (n = !0));
			var a = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(t.text);
			if (!a) throw new A("Invalid size: '" + t.text + "'", t);
			var i = { number: +(a[1] + a[2]), unit: a[3] };
			if (!On(i)) throw new A("Invalid unit: '" + i.unit + "'", t);
			return { type: "size", mode: this.mode, value: i, isBlank: n };
		}
		parseUrlGroup(e) {
			this.gullet.lexer.setCatcode("%", 13), this.gullet.lexer.setCatcode("~", 12);
			var t = this.parseStringGroup("url", e);
			if ((this.gullet.lexer.setCatcode("%", 14), this.gullet.lexer.setCatcode("~", 13), t == null))
				return null;
			var n = t.text.replace(/\\([#$%&~_^{}])/g, "$1");
			return { type: "url", mode: this.mode, url: n };
		}
		parseArgumentGroup(e, t) {
			var n = this.gullet.scanArgument(e);
			if (n == null) return null;
			var a = this.mode;
			t && this.switchMode(t), this.gullet.beginGroup();
			var i = this.parseExpression(!1, "EOF");
			this.expect("EOF"), this.gullet.endGroup();
			var s = { type: "ordgroup", mode: this.mode, loc: n.loc, body: i };
			return t && this.switchMode(a), s;
		}
		parseGroup(e, t) {
			var n = this.fetch(),
				a = n.text,
				i;
			if (a === "{" || a === "\\begingroup") {
				this.consume();
				var s = a === "{" ? "}" : "\\endgroup";
				this.gullet.beginGroup();
				var l = this.parseExpression(!1, s),
					u = this.fetch();
				this.expect(s),
					this.gullet.endGroup(),
					(i = {
						type: "ordgroup",
						mode: this.mode,
						loc: le.range(n, u),
						body: l,
						semisimple: a === "\\begingroup" || void 0,
					});
			} else if (
				((i = this.parseFunction(t, e) || this.parseSymbol()),
				i == null && a[0] === "\\" && !Za.hasOwnProperty(a))
			) {
				if (this.settings.throwOnError) throw new A("Undefined control sequence: " + a, n);
				(i = this.formatUnsupportedCmd(a)), this.consume();
			}
			return i;
		}
		formLigatures(e) {
			for (var t = e.length - 1, n = 0; n < t; ++n) {
				var a = e[n],
					i = a.text;
				i === "-" &&
					e[n + 1].text === "-" &&
					(n + 1 < t && e[n + 2].text === "-"
						? (e.splice(n, 3, {
								type: "textord",
								mode: "text",
								loc: le.range(a, e[n + 2]),
								text: "---",
							}),
							(t -= 2))
						: (e.splice(n, 2, {
								type: "textord",
								mode: "text",
								loc: le.range(a, e[n + 1]),
								text: "--",
							}),
							(t -= 1))),
					(i === "'" || i === "`") &&
						e[n + 1].text === i &&
						(e.splice(n, 2, {
							type: "textord",
							mode: "text",
							loc: le.range(a, e[n + 1]),
							text: i + i,
						}),
						(t -= 1));
			}
		}
		parseSymbol() {
			var e = this.fetch(),
				t = e.text;
			if (/^\\verb[^a-zA-Z]/.test(t)) {
				this.consume();
				var n = t.slice(5),
					a = n.charAt(0) === "*";
				if ((a && (n = n.slice(1)), n.length < 2 || n.charAt(0) !== n.slice(-1)))
					throw new A(`\\verb assertion failed --
                    please report what input caused this bug`);
				return (n = n.slice(1, -1)), { type: "verb", mode: "text", body: n, star: a };
			}
			Ya.hasOwnProperty(t[0]) &&
				!fe[this.mode][t[0]] &&
				(this.settings.strict &&
					this.mode === "math" &&
					this.settings.reportNonstrict(
						"unicodeTextInMathMode",
						'Accented Unicode text character "' + t[0] + '" used in math mode',
						e
					),
				(t = Ya[t[0]] + t.slice(1)));
			var i = Vo.exec(t);
			i && ((t = t.substring(0, i.index)), t === "i" ? (t = "ı") : t === "j" && (t = "ȷ"));
			var s;
			if (fe[this.mode][t]) {
				this.settings.strict &&
					this.mode === "math" &&
					_0.indexOf(t) >= 0 &&
					this.settings.reportNonstrict(
						"unicodeTextInMathMode",
						'Latin-1/Unicode text character "' + t[0] + '" used in math mode',
						e
					);
				var l = fe[this.mode][t].group,
					u = le.range(e),
					d;
				if (Ls.hasOwnProperty(l)) {
					var p = l;
					d = { type: "atom", mode: this.mode, family: p, loc: u, text: t };
				} else d = { type: l, mode: this.mode, loc: u, text: t };
				s = d;
			} else if (t.charCodeAt(0) >= 128)
				this.settings.strict &&
					(En(t.charCodeAt(0))
						? this.mode === "math" &&
							this.settings.reportNonstrict(
								"unicodeTextInMathMode",
								'Unicode text character "' + t[0] + '" used in math mode',
								e
							)
						: this.settings.reportNonstrict(
								"unknownSymbol",
								'Unrecognized Unicode character "' + t[0] + '"' + (" (" + t.charCodeAt(0) + ")"),
								e
							)),
					(s = { type: "textord", mode: "text", loc: le.range(e), text: t });
			else return null;
			if ((this.consume(), i))
				for (var f = 0; f < i[0].length; f++) {
					var v = i[0][f];
					if (!j0[v]) throw new A("Unknown accent ' " + v + "'", e);
					var x = j0[v][this.mode] || j0[v].text;
					if (!x) throw new A("Accent " + v + " unsupported in " + this.mode + " mode", e);
					s = {
						type: "accent",
						mode: this.mode,
						loc: le.range(e),
						label: x,
						isStretchy: !1,
						isShifty: !0,
						base: s,
					};
				}
			return s;
		}
	}
	Kr.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
	var en = function (e, t) {
			if (!(typeof e == "string" || e instanceof String))
				throw new TypeError("KaTeX can only parse string typed expression");
			var n = new Kr(e, t);
			delete n.gullet.macros.current["\\df@tag"];
			var a = n.parse();
			if (
				(delete n.gullet.macros.current["\\current@color"],
				delete n.gullet.macros.current["\\color"],
				n.gullet.macros.get("\\df@tag"))
			) {
				if (!t.displayMode) throw new A("\\tag works only in display equations");
				a = [{ type: "tag", mode: "text", body: a, tag: n.subparse([new ce("\\df@tag")]) }];
			}
			return a;
		},
		Qa = function (e, t, n) {
			t.textContent = "";
			var a = tn(e, n).toNode();
			t.appendChild(a);
		};
	typeof document < "u" &&
		document.compatMode !== "CSS1Compat" &&
		(typeof console < "u" &&
			console.warn(
				"Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype."
			),
		(Qa = function () {
			throw new A("KaTeX doesn't work in quirks mode.");
		}));
	var Qo = function (e, t) {
			var n = tn(e, t).toMarkup();
			return n;
		},
		Jo = function (e, t) {
			var n = new d0(t);
			return en(e, n);
		},
		Ja = function (e, t, n) {
			if (n.throwOnError || !(e instanceof A)) throw e;
			var a = k.makeSpan(["katex-error"], [new tt(t)]);
			return (
				a.setAttribute("title", e.toString()), a.setAttribute("style", "color:" + n.errorColor), a
			);
		},
		tn = function (e, t) {
			var n = new d0(t);
			try {
				var a = en(e, n);
				return so(a, e, n);
			} catch (i) {
				return Ja(i, e, n);
			}
		},
		jo = function (e, t) {
			var n = new d0(t);
			try {
				var a = en(e, n);
				return oo(a, e, n);
			} catch (i) {
				return Ja(i, e, n);
			}
		},
		el = "0.16.22",
		tl = { Span: ar, Anchor: v0, SymbolNode: tt, SvgNode: vt, PathNode: At, LineNode: y0 },
		cr = {
			version: el,
			render: Qa,
			renderToString: Qo,
			ParseError: A,
			SETTINGS_SCHEMA: _r,
			__parse: Jo,
			__renderToDomTree: tn,
			__renderToHTMLTree: jo,
			__setFontMetrics: Ns,
			__defineSymbol: o,
			__defineFunction: B,
			__defineMacro: m,
			__domTree: tl,
		};
	cr.__defineMacro("\\ce", function (r) {
		return ja(r.consumeArgs(1)[0], "ce");
	}),
		cr.__defineMacro("\\pu", function (r) {
			return ja(r.consumeArgs(1)[0], "pu");
		}),
		cr.__defineMacro(
			"\\tripledash",
			"{\\vphantom{-}\\raisebox{2.56mu}{$\\mkern2mu\\tiny\\text{-}\\mkern1mu\\text{-}\\mkern1mu\\text{-}\\mkern2mu$}}"
		);
	var ja = function (e, t) {
			for (var n = "", a = e.length && e[e.length - 1].loc.start, i = e.length - 1; i >= 0; i--)
				e[i].loc.start > a && ((n += " "), (a = e[i].loc.start)),
					(n += e[i].text),
					(a += e[i].text.length);
			var s = pe.go(T.go(n, t));
			return s;
		},
		T = {
			go: function (e, t) {
				if (!e) return [];
				t === void 0 && (t = "ce");
				var n = "0",
					a = {};
				(a.parenthesisLevel = 0),
					(e = e.replace(/\n/g, " ")),
					(e = e.replace(/[\u2212\u2013\u2014\u2010]/g, "-")),
					(e = e.replace(/[\u2026]/g, "..."));
				for (var i, s = 10, l = []; ; ) {
					i !== e ? ((s = 10), (i = e)) : s--;
					var u = T.stateMachines[t],
						d = u.transitions[n] || u.transitions["*"];
					e: for (var p = 0; p < d.length; p++) {
						var f = T.patterns.match_(d[p].pattern, e);
						if (f) {
							for (var v = d[p].task, x = 0; x < v.action_.length; x++) {
								var _;
								if (u.actions[v.action_[x].type_])
									_ = u.actions[v.action_[x].type_](a, f.match_, v.action_[x].option);
								else if (T.actions[v.action_[x].type_])
									_ = T.actions[v.action_[x].type_](a, f.match_, v.action_[x].option);
								else
									throw ["MhchemBugA", "mhchem bug A. Please report. (" + v.action_[x].type_ + ")"];
								T.concatArray(l, _);
							}
							if (((n = v.nextState || n), e.length > 0)) {
								if ((v.revisit || (e = f.remainder), !v.toContinue)) break e;
							} else return l;
						}
					}
					if (s <= 0) throw ["MhchemBugU", "mhchem bug U. Please report."];
				}
			},
			concatArray: function (e, t) {
				if (t)
					if (Array.isArray(t)) for (var n = 0; n < t.length; n++) e.push(t[n]);
					else e.push(t);
			},
			patterns: {
				patterns: {
					empty: /^$/,
					else: /^./,
					else2: /^./,
					space: /^\s/,
					"space A": /^\s(?=[A-Z\\$])/,
					space$: /^\s$/,
					"a-z": /^[a-z]/,
					x: /^x/,
					x$: /^x$/,
					i$: /^i$/,
					letters:
						/^(?:[a-zA-Z\u03B1-\u03C9\u0391-\u03A9?@]|(?:\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega)(?:\s+|\{\}|(?![a-zA-Z]))))+/,
					"\\greek":
						/^\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega)(?:\s+|\{\}|(?![a-zA-Z]))/,
					"one lowercase latin letter $": /^(?:([a-z])(?:$|[^a-zA-Z]))$/,
					"$one lowercase latin letter$ $": /^\$(?:([a-z])(?:$|[^a-zA-Z]))\$$/,
					"one lowercase greek letter $":
						/^(?:\$?[\u03B1-\u03C9]\$?|\$?\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega)\s*\$?)(?:\s+|\{\}|(?![a-zA-Z]))$/,
					digits: /^[0-9]+/,
					"-9.,9": /^[+\-]?(?:[0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))/,
					"-9.,9 no missing 0": /^[+\-]?[0-9]+(?:[.,][0-9]+)?/,
					"(-)(9.,9)(e)(99)": function (e) {
						var t = e.match(
							/^(\+\-|\+\/\-|\+|\-|\\pm\s?)?([0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))?(\((?:[0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))\))?(?:([eE]|\s*(\*|x|\\times|\u00D7)\s*10\^)([+\-]?[0-9]+|\{[+\-]?[0-9]+\}))?/
						);
						return t && t[0] ? { match_: t.splice(1), remainder: e.substr(t[0].length) } : null;
					},
					"(-)(9)^(-9)": function (e) {
						var t = e.match(
							/^(\+\-|\+\/\-|\+|\-|\\pm\s?)?([0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+)?)\^([+\-]?[0-9]+|\{[+\-]?[0-9]+\})/
						);
						return t && t[0] ? { match_: t.splice(1), remainder: e.substr(t[0].length) } : null;
					},
					"state of aggregation $": function (e) {
						var t = T.patterns.findObserveGroups(e, "", /^\([a-z]{1,3}(?=[\),])/, ")", "");
						if (t && t.remainder.match(/^($|[\s,;\)\]\}])/)) return t;
						var n = e.match(/^(?:\((?:\\ca\s?)?\$[amothc]\$\))/);
						return n ? { match_: n[0], remainder: e.substr(n[0].length) } : null;
					},
					"_{(state of aggregation)}$": /^_\{(\([a-z]{1,3}\))\}/,
					"{[(": /^(?:\\\{|\[|\()/,
					")]}": /^(?:\)|\]|\\\})/,
					", ": /^[,;]\s*/,
					",": /^[,;]/,
					".": /^[.]/,
					". ": /^([.\u22C5\u00B7\u2022])\s*/,
					"...": /^\.\.\.(?=$|[^.])/,
					"* ": /^([*])\s*/,
					"^{(...)}": function (e) {
						return T.patterns.findObserveGroups(e, "^{", "", "", "}");
					},
					"^($...$)": function (e) {
						return T.patterns.findObserveGroups(e, "^", "$", "$", "");
					},
					"^a": /^\^([0-9]+|[^\\_])/,
					"^\\x{}{}": function (e) {
						return T.patterns.findObserveGroups(
							e,
							"^",
							/^\\[a-zA-Z]+\{/,
							"}",
							"",
							"",
							"{",
							"}",
							"",
							!0
						);
					},
					"^\\x{}": function (e) {
						return T.patterns.findObserveGroups(e, "^", /^\\[a-zA-Z]+\{/, "}", "");
					},
					"^\\x": /^\^(\\[a-zA-Z]+)\s*/,
					"^(-1)": /^\^(-?\d+)/,
					"'": /^'/,
					"_{(...)}": function (e) {
						return T.patterns.findObserveGroups(e, "_{", "", "", "}");
					},
					"_($...$)": function (e) {
						return T.patterns.findObserveGroups(e, "_", "$", "$", "");
					},
					_9: /^_([+\-]?[0-9]+|[^\\])/,
					"_\\x{}{}": function (e) {
						return T.patterns.findObserveGroups(
							e,
							"_",
							/^\\[a-zA-Z]+\{/,
							"}",
							"",
							"",
							"{",
							"}",
							"",
							!0
						);
					},
					"_\\x{}": function (e) {
						return T.patterns.findObserveGroups(e, "_", /^\\[a-zA-Z]+\{/, "}", "");
					},
					"_\\x": /^_(\\[a-zA-Z]+)\s*/,
					"^_": /^(?:\^(?=_)|\_(?=\^)|[\^_]$)/,
					"{}": /^\{\}/,
					"{...}": function (e) {
						return T.patterns.findObserveGroups(e, "", "{", "}", "");
					},
					"{(...)}": function (e) {
						return T.patterns.findObserveGroups(e, "{", "", "", "}");
					},
					"$...$": function (e) {
						return T.patterns.findObserveGroups(e, "", "$", "$", "");
					},
					"${(...)}$": function (e) {
						return T.patterns.findObserveGroups(e, "${", "", "", "}$");
					},
					"$(...)$": function (e) {
						return T.patterns.findObserveGroups(e, "$", "", "", "$");
					},
					"=<>": /^[=<>]/,
					"#": /^[#\u2261]/,
					"+": /^\+/,
					"-$": /^-(?=[\s_},;\]/]|$|\([a-z]+\))/,
					"-9": /^-(?=[0-9])/,
					"- orbital overlap": /^-(?=(?:[spd]|sp)(?:$|[\s,;\)\]\}]))/,
					"-": /^-/,
					"pm-operator": /^(?:\\pm|\$\\pm\$|\+-|\+\/-)/,
					operator: /^(?:\+|(?:[\-=<>]|<<|>>|\\approx|\$\\approx\$)(?=\s|$|-?[0-9]))/,
					arrowUpDown: /^(?:v|\(v\)|\^|\(\^\))(?=$|[\s,;\)\]\}])/,
					"\\bond{(...)}": function (e) {
						return T.patterns.findObserveGroups(e, "\\bond{", "", "", "}");
					},
					"->": /^(?:<->|<-->|->|<-|<=>>|<<=>|<=>|[\u2192\u27F6\u21CC])/,
					CMT: /^[CMT](?=\[)/,
					"[(...)]": function (e) {
						return T.patterns.findObserveGroups(e, "[", "", "", "]");
					},
					"1st-level escape": /^(&|\\\\|\\hline)\s*/,
					"\\,": /^(?:\\[,\ ;:])/,
					"\\x{}{}": function (e) {
						return T.patterns.findObserveGroups(
							e,
							"",
							/^\\[a-zA-Z]+\{/,
							"}",
							"",
							"",
							"{",
							"}",
							"",
							!0
						);
					},
					"\\x{}": function (e) {
						return T.patterns.findObserveGroups(e, "", /^\\[a-zA-Z]+\{/, "}", "");
					},
					"\\ca": /^\\ca(?:\s+|(?![a-zA-Z]))/,
					"\\x": /^(?:\\[a-zA-Z]+\s*|\\[_&{}%])/,
					orbital: /^(?:[0-9]{1,2}[spdfgh]|[0-9]{0,2}sp)(?=$|[^a-zA-Z])/,
					others: /^[\/~|]/,
					"\\frac{(...)}": function (e) {
						return T.patterns.findObserveGroups(e, "\\frac{", "", "", "}", "{", "", "", "}");
					},
					"\\overset{(...)}": function (e) {
						return T.patterns.findObserveGroups(e, "\\overset{", "", "", "}", "{", "", "", "}");
					},
					"\\underset{(...)}": function (e) {
						return T.patterns.findObserveGroups(e, "\\underset{", "", "", "}", "{", "", "", "}");
					},
					"\\underbrace{(...)}": function (e) {
						return T.patterns.findObserveGroups(e, "\\underbrace{", "", "", "}_", "{", "", "", "}");
					},
					"\\color{(...)}0": function (e) {
						return T.patterns.findObserveGroups(e, "\\color{", "", "", "}");
					},
					"\\color{(...)}{(...)}1": function (e) {
						return T.patterns.findObserveGroups(e, "\\color{", "", "", "}", "{", "", "", "}");
					},
					"\\color(...){(...)}2": function (e) {
						return T.patterns.findObserveGroups(
							e,
							"\\color",
							"\\",
							"",
							/^(?=\{)/,
							"{",
							"",
							"",
							"}"
						);
					},
					"\\ce{(...)}": function (e) {
						return T.patterns.findObserveGroups(e, "\\ce{", "", "", "}");
					},
					oxidation$: /^(?:[+-][IVX]+|\\pm\s*0|\$\\pm\$\s*0)$/,
					"d-oxidation$": /^(?:[+-]?\s?[IVX]+|\\pm\s*0|\$\\pm\$\s*0)$/,
					"roman numeral": /^[IVX]+/,
					"1/2$": /^[+\-]?(?:[0-9]+|\$[a-z]\$|[a-z])\/[0-9]+(?:\$[a-z]\$|[a-z])?$/,
					amount: function (e) {
						var t;
						if (
							((t = e.match(
								/^(?:(?:(?:\([+\-]?[0-9]+\/[0-9]+\)|[+\-]?(?:[0-9]+|\$[a-z]\$|[a-z])\/[0-9]+|[+\-]?[0-9]+[.,][0-9]+|[+\-]?\.[0-9]+|[+\-]?[0-9]+)(?:[a-z](?=\s*[A-Z]))?)|[+\-]?[a-z](?=\s*[A-Z])|\+(?!\s))/
							)),
							t)
						)
							return { match_: t[0], remainder: e.substr(t[0].length) };
						var n = T.patterns.findObserveGroups(e, "", "$", "$", "");
						return n &&
							((t = n.match_.match(
								/^\$(?:\(?[+\-]?(?:[0-9]*[a-z]?[+\-])?[0-9]*[a-z](?:[+\-][0-9]*[a-z]?)?\)?|\+|-)\$$/
							)),
							t)
							? { match_: t[0], remainder: e.substr(t[0].length) }
							: null;
					},
					amount2: function (e) {
						return this.amount(e);
					},
					"(KV letters),": /^(?:[A-Z][a-z]{0,2}|i)(?=,)/,
					formula$: function (e) {
						if (e.match(/^\([a-z]+\)$/)) return null;
						var t = e.match(
							/^(?:[a-z]|(?:[0-9\ \+\-\,\.\(\)]+[a-z])+[0-9\ \+\-\,\.\(\)]*|(?:[a-z][0-9\ \+\-\,\.\(\)]+)+[a-z]?)$/
						);
						return t ? { match_: t[0], remainder: e.substr(t[0].length) } : null;
					},
					uprightEntities: /^(?:pH|pOH|pC|pK|iPr|iBu)(?=$|[^a-zA-Z])/,
					"/": /^\s*(\/)\s*/,
					"//": /^\s*(\/\/)\s*/,
					"*": /^\s*[*.]\s*/,
				},
				findObserveGroups: function (e, t, n, a, i, s, l, u, d, p) {
					var f = function ($, P) {
							if (typeof P == "string") return $.indexOf(P) !== 0 ? null : P;
							var q = $.match(P);
							return q ? q[0] : null;
						},
						v = function ($, P, q) {
							for (var U = 0; P < $.length; ) {
								var Q = $.charAt(P),
									ne = f($.substr(P), q);
								if (ne !== null && U === 0) return { endMatchBegin: P, endMatchEnd: P + ne.length };
								if (Q === "{") U++;
								else if (Q === "}") {
									if (U === 0)
										throw ["ExtraCloseMissingOpen", "Extra close brace or missing open brace"];
									U--;
								}
								P++;
							}
							return U > 0, null;
						},
						x = f(e, t);
					if (x === null || ((e = e.substr(x.length)), (x = f(e, n)), x === null)) return null;
					var _ = v(e, x.length, a || i);
					if (_ === null) return null;
					var S = e.substring(0, a ? _.endMatchEnd : _.endMatchBegin);
					if (s || l) {
						var M = this.findObserveGroups(e.substr(_.endMatchEnd), s, l, u, d);
						if (M === null) return null;
						var O = [S, M.match_];
						return { match_: p ? O.join("") : O, remainder: M.remainder };
					} else return { match_: S, remainder: e.substr(_.endMatchEnd) };
				},
				match_: function (e, t) {
					var n = T.patterns.patterns[e];
					if (n === void 0) throw ["MhchemBugP", "mhchem bug P. Please report. (" + e + ")"];
					if (typeof n == "function") return T.patterns.patterns[e](t);
					var a = t.match(n);
					if (a) {
						var i;
						return (
							a[2] ? (i = [a[1], a[2]]) : a[1] ? (i = a[1]) : (i = a[0]),
							{ match_: i, remainder: t.substr(a[0].length) }
						);
					}
					return null;
				},
			},
			actions: {
				"a=": function (e, t) {
					e.a = (e.a || "") + t;
				},
				"b=": function (e, t) {
					e.b = (e.b || "") + t;
				},
				"p=": function (e, t) {
					e.p = (e.p || "") + t;
				},
				"o=": function (e, t) {
					e.o = (e.o || "") + t;
				},
				"q=": function (e, t) {
					e.q = (e.q || "") + t;
				},
				"d=": function (e, t) {
					e.d = (e.d || "") + t;
				},
				"rm=": function (e, t) {
					e.rm = (e.rm || "") + t;
				},
				"text=": function (e, t) {
					e.text_ = (e.text_ || "") + t;
				},
				insert: function (e, t, n) {
					return { type_: n };
				},
				"insert+p1": function (e, t, n) {
					return { type_: n, p1: t };
				},
				"insert+p1+p2": function (e, t, n) {
					return { type_: n, p1: t[0], p2: t[1] };
				},
				copy: function (e, t) {
					return t;
				},
				rm: function (e, t) {
					return { type_: "rm", p1: t || "" };
				},
				text: function (e, t) {
					return T.go(t, "text");
				},
				"{text}": function (e, t) {
					var n = ["{"];
					return T.concatArray(n, T.go(t, "text")), n.push("}"), n;
				},
				"tex-math": function (e, t) {
					return T.go(t, "tex-math");
				},
				"tex-math tight": function (e, t) {
					return T.go(t, "tex-math tight");
				},
				bond: function (e, t, n) {
					return { type_: "bond", kind_: n || t };
				},
				"color0-output": function (e, t) {
					return { type_: "color0", color: t[0] };
				},
				ce: function (e, t) {
					return T.go(t);
				},
				"1/2": function (e, t) {
					var n = [];
					t.match(/^[+\-]/) && (n.push(t.substr(0, 1)), (t = t.substr(1)));
					var a = t.match(/^([0-9]+|\$[a-z]\$|[a-z])\/([0-9]+)(\$[a-z]\$|[a-z])?$/);
					return (
						(a[1] = a[1].replace(/\$/g, "")),
						n.push({ type_: "frac", p1: a[1], p2: a[2] }),
						a[3] && ((a[3] = a[3].replace(/\$/g, "")), n.push({ type_: "tex-math", p1: a[3] })),
						n
					);
				},
				"9,9": function (e, t) {
					return T.go(t, "9,9");
				},
			},
			createTransitions: function (e) {
				var t,
					n,
					a,
					i,
					s = {};
				for (t in e)
					for (n in e[t])
						for (a = n.split("|"), e[t][n].stateArray = a, i = 0; i < a.length; i++) s[a[i]] = [];
				for (t in e)
					for (n in e[t])
						for (a = e[t][n].stateArray || [], i = 0; i < a.length; i++) {
							var l = e[t][n];
							if (l.action_) {
								l.action_ = [].concat(l.action_);
								for (var u = 0; u < l.action_.length; u++)
									typeof l.action_[u] == "string" && (l.action_[u] = { type_: l.action_[u] });
							} else l.action_ = [];
							for (var d = t.split("|"), p = 0; p < d.length; p++)
								if (a[i] === "*") for (var f in s) s[f].push({ pattern: d[p], task: l });
								else s[a[i]].push({ pattern: d[p], task: l });
						}
				return s;
			},
			stateMachines: {},
		};
	T.stateMachines = {
		ce: {
			transitions: T.createTransitions({
				empty: { "*": { action_: "output" } },
				else: { "0|1|2": { action_: "beginsWithBond=false", revisit: !0, toContinue: !0 } },
				oxidation$: { 0: { action_: "oxidation-output" } },
				CMT: { r: { action_: "rdt=", nextState: "rt" }, rd: { action_: "rqt=", nextState: "rdt" } },
				arrowUpDown: {
					"0|1|2|as": { action_: ["sb=false", "output", "operator"], nextState: "1" },
				},
				uprightEntities: { "0|1|2": { action_: ["o=", "output"], nextState: "1" } },
				orbital: { "0|1|2|3": { action_: "o=", nextState: "o" } },
				"->": {
					"0|1|2|3": { action_: "r=", nextState: "r" },
					"a|as": { action_: ["output", "r="], nextState: "r" },
					"*": { action_: ["output", "r="], nextState: "r" },
				},
				"+": {
					o: { action_: "d= kv", nextState: "d" },
					"d|D": { action_: "d=", nextState: "d" },
					q: { action_: "d=", nextState: "qd" },
					"qd|qD": { action_: "d=", nextState: "qd" },
					dq: { action_: ["output", "d="], nextState: "d" },
					3: { action_: ["sb=false", "output", "operator"], nextState: "0" },
				},
				amount: { "0|2": { action_: "a=", nextState: "a" } },
				"pm-operator": {
					"0|1|2|a|as": {
						action_: ["sb=false", "output", { type_: "operator", option: "\\pm" }],
						nextState: "0",
					},
				},
				operator: { "0|1|2|a|as": { action_: ["sb=false", "output", "operator"], nextState: "0" } },
				"-$": {
					"o|q": { action_: ["charge or bond", "output"], nextState: "qd" },
					d: { action_: "d=", nextState: "d" },
					D: { action_: ["output", { type_: "bond", option: "-" }], nextState: "3" },
					q: { action_: "d=", nextState: "qd" },
					qd: { action_: "d=", nextState: "qd" },
					"qD|dq": { action_: ["output", { type_: "bond", option: "-" }], nextState: "3" },
				},
				"-9": {
					"3|o": { action_: ["output", { type_: "insert", option: "hyphen" }], nextState: "3" },
				},
				"- orbital overlap": {
					o: { action_: ["output", { type_: "insert", option: "hyphen" }], nextState: "2" },
					d: { action_: ["output", { type_: "insert", option: "hyphen" }], nextState: "2" },
				},
				"-": {
					"0|1|2": {
						action_: [
							{ type_: "output", option: 1 },
							"beginsWithBond=true",
							{ type_: "bond", option: "-" },
						],
						nextState: "3",
					},
					3: { action_: { type_: "bond", option: "-" } },
					a: { action_: ["output", { type_: "insert", option: "hyphen" }], nextState: "2" },
					as: {
						action_: [
							{ type_: "output", option: 2 },
							{ type_: "bond", option: "-" },
						],
						nextState: "3",
					},
					b: { action_: "b=" },
					o: { action_: { type_: "- after o/d", option: !1 }, nextState: "2" },
					q: { action_: { type_: "- after o/d", option: !1 }, nextState: "2" },
					"d|qd|dq": { action_: { type_: "- after o/d", option: !0 }, nextState: "2" },
					"D|qD|p": { action_: ["output", { type_: "bond", option: "-" }], nextState: "3" },
				},
				amount2: { "1|3": { action_: "a=", nextState: "a" } },
				letters: {
					"0|1|2|3|a|as|b|p|bp|o": { action_: "o=", nextState: "o" },
					"q|dq": { action_: ["output", "o="], nextState: "o" },
					"d|D|qd|qD": { action_: "o after d", nextState: "o" },
				},
				digits: {
					o: { action_: "q=", nextState: "q" },
					"d|D": { action_: "q=", nextState: "dq" },
					q: { action_: ["output", "o="], nextState: "o" },
					a: { action_: "o=", nextState: "o" },
				},
				"space A": { "b|p|bp": {} },
				space: {
					a: { nextState: "as" },
					0: { action_: "sb=false" },
					"1|2": { action_: "sb=true" },
					"r|rt|rd|rdt|rdq": { action_: "output", nextState: "0" },
					"*": { action_: ["output", "sb=true"], nextState: "1" },
				},
				"1st-level escape": {
					"1|2": { action_: ["output", { type_: "insert+p1", option: "1st-level escape" }] },
					"*": {
						action_: ["output", { type_: "insert+p1", option: "1st-level escape" }],
						nextState: "0",
					},
				},
				"[(...)]": {
					"r|rt": { action_: "rd=", nextState: "rd" },
					"rd|rdt": { action_: "rq=", nextState: "rdq" },
				},
				"...": {
					"o|d|D|dq|qd|qD": {
						action_: ["output", { type_: "bond", option: "..." }],
						nextState: "3",
					},
					"*": {
						action_: [
							{ type_: "output", option: 1 },
							{ type_: "insert", option: "ellipsis" },
						],
						nextState: "1",
					},
				},
				". |* ": {
					"*": {
						action_: ["output", { type_: "insert", option: "addition compound" }],
						nextState: "1",
					},
				},
				"state of aggregation $": {
					"*": { action_: ["output", "state of aggregation"], nextState: "1" },
				},
				"{[(": {
					"a|as|o": { action_: ["o=", "output", "parenthesisLevel++"], nextState: "2" },
					"0|1|2|3": { action_: ["o=", "output", "parenthesisLevel++"], nextState: "2" },
					"*": { action_: ["output", "o=", "output", "parenthesisLevel++"], nextState: "2" },
				},
				")]}": {
					"0|1|2|3|b|p|bp|o": { action_: ["o=", "parenthesisLevel--"], nextState: "o" },
					"a|as|d|D|q|qd|qD|dq": {
						action_: ["output", "o=", "parenthesisLevel--"],
						nextState: "o",
					},
				},
				", ": { "*": { action_: ["output", "comma"], nextState: "0" } },
				"^_": { "*": {} },
				"^{(...)}|^($...$)": {
					"0|1|2|as": { action_: "b=", nextState: "b" },
					p: { action_: "b=", nextState: "bp" },
					"3|o": { action_: "d= kv", nextState: "D" },
					q: { action_: "d=", nextState: "qD" },
					"d|D|qd|qD|dq": { action_: ["output", "d="], nextState: "D" },
				},
				"^a|^\\x{}{}|^\\x{}|^\\x|'": {
					"0|1|2|as": { action_: "b=", nextState: "b" },
					p: { action_: "b=", nextState: "bp" },
					"3|o": { action_: "d= kv", nextState: "d" },
					q: { action_: "d=", nextState: "qd" },
					"d|qd|D|qD": { action_: "d=" },
					dq: { action_: ["output", "d="], nextState: "d" },
				},
				"_{(state of aggregation)}$": {
					"d|D|q|qd|qD|dq": { action_: ["output", "q="], nextState: "q" },
				},
				"_{(...)}|_($...$)|_9|_\\x{}{}|_\\x{}|_\\x": {
					"0|1|2|as": { action_: "p=", nextState: "p" },
					b: { action_: "p=", nextState: "bp" },
					"3|o": { action_: "q=", nextState: "q" },
					"d|D": { action_: "q=", nextState: "dq" },
					"q|qd|qD|dq": { action_: ["output", "q="], nextState: "q" },
				},
				"=<>": {
					"0|1|2|3|a|as|o|q|d|D|qd|qD|dq": {
						action_: [{ type_: "output", option: 2 }, "bond"],
						nextState: "3",
					},
				},
				"#": {
					"0|1|2|3|a|as|o": {
						action_: [
							{ type_: "output", option: 2 },
							{ type_: "bond", option: "#" },
						],
						nextState: "3",
					},
				},
				"{}": { "*": { action_: { type_: "output", option: 1 }, nextState: "1" } },
				"{...}": {
					"0|1|2|3|a|as|b|p|bp": { action_: "o=", nextState: "o" },
					"o|d|D|q|qd|qD|dq": { action_: ["output", "o="], nextState: "o" },
				},
				"$...$": {
					a: { action_: "a=" },
					"0|1|2|3|as|b|p|bp|o": { action_: "o=", nextState: "o" },
					"as|o": { action_: "o=" },
					"q|d|D|qd|qD|dq": { action_: ["output", "o="], nextState: "o" },
				},
				"\\bond{(...)}": {
					"*": { action_: [{ type_: "output", option: 2 }, "bond"], nextState: "3" },
				},
				"\\frac{(...)}": {
					"*": { action_: [{ type_: "output", option: 1 }, "frac-output"], nextState: "3" },
				},
				"\\overset{(...)}": {
					"*": { action_: [{ type_: "output", option: 2 }, "overset-output"], nextState: "3" },
				},
				"\\underset{(...)}": {
					"*": { action_: [{ type_: "output", option: 2 }, "underset-output"], nextState: "3" },
				},
				"\\underbrace{(...)}": {
					"*": { action_: [{ type_: "output", option: 2 }, "underbrace-output"], nextState: "3" },
				},
				"\\color{(...)}{(...)}1|\\color(...){(...)}2": {
					"*": { action_: [{ type_: "output", option: 2 }, "color-output"], nextState: "3" },
				},
				"\\color{(...)}0": { "*": { action_: [{ type_: "output", option: 2 }, "color0-output"] } },
				"\\ce{(...)}": { "*": { action_: [{ type_: "output", option: 2 }, "ce"], nextState: "3" } },
				"\\,": { "*": { action_: [{ type_: "output", option: 1 }, "copy"], nextState: "1" } },
				"\\x{}{}|\\x{}|\\x": {
					"0|1|2|3|a|as|b|p|bp|o|c0": { action_: ["o=", "output"], nextState: "3" },
					"*": { action_: ["output", "o=", "output"], nextState: "3" },
				},
				others: { "*": { action_: [{ type_: "output", option: 1 }, "copy"], nextState: "3" } },
				else2: {
					a: { action_: "a to o", nextState: "o", revisit: !0 },
					as: { action_: ["output", "sb=true"], nextState: "1", revisit: !0 },
					"r|rt|rd|rdt|rdq": { action_: ["output"], nextState: "0", revisit: !0 },
					"*": { action_: ["output", "copy"], nextState: "3" },
				},
			}),
			actions: {
				"o after d": function (e, t) {
					var n;
					if ((e.d || "").match(/^[0-9]+$/)) {
						var a = e.d;
						(e.d = void 0), (n = this.output(e)), (e.b = a);
					} else n = this.output(e);
					return T.actions["o="](e, t), n;
				},
				"d= kv": function (e, t) {
					(e.d = t), (e.dType = "kv");
				},
				"charge or bond": function (e, t) {
					if (e.beginsWithBond) {
						var n = [];
						return T.concatArray(n, this.output(e)), T.concatArray(n, T.actions.bond(e, t, "-")), n;
					} else e.d = t;
				},
				"- after o/d": function (e, t, n) {
					var a = T.patterns.match_("orbital", e.o || ""),
						i = T.patterns.match_("one lowercase greek letter $", e.o || ""),
						s = T.patterns.match_("one lowercase latin letter $", e.o || ""),
						l = T.patterns.match_("$one lowercase latin letter$ $", e.o || ""),
						u = t === "-" && ((a && a.remainder === "") || i || s || l);
					u && !e.a && !e.b && !e.p && !e.d && !e.q && !a && s && (e.o = "$" + e.o + "$");
					var d = [];
					return (
						u
							? (T.concatArray(d, this.output(e)), d.push({ type_: "hyphen" }))
							: ((a = T.patterns.match_("digits", e.d || "")),
								n && a && a.remainder === ""
									? (T.concatArray(d, T.actions["d="](e, t)), T.concatArray(d, this.output(e)))
									: (T.concatArray(d, this.output(e)),
										T.concatArray(d, T.actions.bond(e, t, "-")))),
						d
					);
				},
				"a to o": function (e) {
					(e.o = e.a), (e.a = void 0);
				},
				"sb=true": function (e) {
					e.sb = !0;
				},
				"sb=false": function (e) {
					e.sb = !1;
				},
				"beginsWithBond=true": function (e) {
					e.beginsWithBond = !0;
				},
				"beginsWithBond=false": function (e) {
					e.beginsWithBond = !1;
				},
				"parenthesisLevel++": function (e) {
					e.parenthesisLevel++;
				},
				"parenthesisLevel--": function (e) {
					e.parenthesisLevel--;
				},
				"state of aggregation": function (e, t) {
					return { type_: "state of aggregation", p1: T.go(t, "o") };
				},
				comma: function (e, t) {
					var n = t.replace(/\s*$/, ""),
						a = n !== t;
					return a && e.parenthesisLevel === 0
						? { type_: "comma enumeration L", p1: n }
						: { type_: "comma enumeration M", p1: n };
				},
				output: function (e, t, n) {
					var a;
					if (!e.r)
						(a = []),
							(!e.a && !e.b && !e.p && !e.o && !e.q && !e.d && !n) ||
								(e.sb && a.push({ type_: "entitySkip" }),
								!e.o && !e.q && !e.d && !e.b && !e.p && n !== 2
									? ((e.o = e.a), (e.a = void 0))
									: !e.o && !e.q && !e.d && (e.b || e.p)
										? ((e.o = e.a), (e.d = e.b), (e.q = e.p), (e.a = e.b = e.p = void 0))
										: e.o && e.dType === "kv" && T.patterns.match_("d-oxidation$", e.d || "")
											? (e.dType = "oxidation")
											: e.o && e.dType === "kv" && !e.q && (e.dType = void 0),
								a.push({
									type_: "chemfive",
									a: T.go(e.a, "a"),
									b: T.go(e.b, "bd"),
									p: T.go(e.p, "pq"),
									o: T.go(e.o, "o"),
									q: T.go(e.q, "pq"),
									d: T.go(e.d, e.dType === "oxidation" ? "oxidation" : "bd"),
									dType: e.dType,
								}));
					else {
						var i;
						e.rdt === "M"
							? (i = T.go(e.rd, "tex-math"))
							: e.rdt === "T"
								? (i = [{ type_: "text", p1: e.rd || "" }])
								: (i = T.go(e.rd));
						var s;
						e.rqt === "M"
							? (s = T.go(e.rq, "tex-math"))
							: e.rqt === "T"
								? (s = [{ type_: "text", p1: e.rq || "" }])
								: (s = T.go(e.rq)),
							(a = { type_: "arrow", r: e.r, rd: i, rq: s });
					}
					for (var l in e) l !== "parenthesisLevel" && l !== "beginsWithBond" && delete e[l];
					return a;
				},
				"oxidation-output": function (e, t) {
					var n = ["{"];
					return T.concatArray(n, T.go(t, "oxidation")), n.push("}"), n;
				},
				"frac-output": function (e, t) {
					return { type_: "frac-ce", p1: T.go(t[0]), p2: T.go(t[1]) };
				},
				"overset-output": function (e, t) {
					return { type_: "overset", p1: T.go(t[0]), p2: T.go(t[1]) };
				},
				"underset-output": function (e, t) {
					return { type_: "underset", p1: T.go(t[0]), p2: T.go(t[1]) };
				},
				"underbrace-output": function (e, t) {
					return { type_: "underbrace", p1: T.go(t[0]), p2: T.go(t[1]) };
				},
				"color-output": function (e, t) {
					return { type_: "color", color1: t[0], color2: T.go(t[1]) };
				},
				"r=": function (e, t) {
					e.r = t;
				},
				"rdt=": function (e, t) {
					e.rdt = t;
				},
				"rd=": function (e, t) {
					e.rd = t;
				},
				"rqt=": function (e, t) {
					e.rqt = t;
				},
				"rq=": function (e, t) {
					e.rq = t;
				},
				operator: function (e, t, n) {
					return { type_: "operator", kind_: n || t };
				},
			},
		},
		a: {
			transitions: T.createTransitions({
				empty: { "*": {} },
				"1/2$": { 0: { action_: "1/2" } },
				else: { 0: { nextState: "1", revisit: !0 } },
				"$(...)$": { "*": { action_: "tex-math tight", nextState: "1" } },
				",": { "*": { action_: { type_: "insert", option: "commaDecimal" } } },
				else2: { "*": { action_: "copy" } },
			}),
			actions: {},
		},
		o: {
			transitions: T.createTransitions({
				empty: { "*": {} },
				"1/2$": { 0: { action_: "1/2" } },
				else: { 0: { nextState: "1", revisit: !0 } },
				letters: { "*": { action_: "rm" } },
				"\\ca": { "*": { action_: { type_: "insert", option: "circa" } } },
				"\\x{}{}|\\x{}|\\x": { "*": { action_: "copy" } },
				"${(...)}$|$(...)$": { "*": { action_: "tex-math" } },
				"{(...)}": { "*": { action_: "{text}" } },
				else2: { "*": { action_: "copy" } },
			}),
			actions: {},
		},
		text: {
			transitions: T.createTransitions({
				empty: { "*": { action_: "output" } },
				"{...}": { "*": { action_: "text=" } },
				"${(...)}$|$(...)$": { "*": { action_: "tex-math" } },
				"\\greek": { "*": { action_: ["output", "rm"] } },
				"\\,|\\x{}{}|\\x{}|\\x": { "*": { action_: ["output", "copy"] } },
				else: { "*": { action_: "text=" } },
			}),
			actions: {
				output: function (e) {
					if (e.text_) {
						var t = { type_: "text", p1: e.text_ };
						for (var n in e) delete e[n];
						return t;
					}
				},
			},
		},
		pq: {
			transitions: T.createTransitions({
				empty: { "*": {} },
				"state of aggregation $": { "*": { action_: "state of aggregation" } },
				i$: { 0: { nextState: "!f", revisit: !0 } },
				"(KV letters),": { 0: { action_: "rm", nextState: "0" } },
				formula$: { 0: { nextState: "f", revisit: !0 } },
				"1/2$": { 0: { action_: "1/2" } },
				else: { 0: { nextState: "!f", revisit: !0 } },
				"${(...)}$|$(...)$": { "*": { action_: "tex-math" } },
				"{(...)}": { "*": { action_: "text" } },
				"a-z": { f: { action_: "tex-math" } },
				letters: { "*": { action_: "rm" } },
				"-9.,9": { "*": { action_: "9,9" } },
				",": { "*": { action_: { type_: "insert+p1", option: "comma enumeration S" } } },
				"\\color{(...)}{(...)}1|\\color(...){(...)}2": { "*": { action_: "color-output" } },
				"\\color{(...)}0": { "*": { action_: "color0-output" } },
				"\\ce{(...)}": { "*": { action_: "ce" } },
				"\\,|\\x{}{}|\\x{}|\\x": { "*": { action_: "copy" } },
				else2: { "*": { action_: "copy" } },
			}),
			actions: {
				"state of aggregation": function (e, t) {
					return { type_: "state of aggregation subscript", p1: T.go(t, "o") };
				},
				"color-output": function (e, t) {
					return { type_: "color", color1: t[0], color2: T.go(t[1], "pq") };
				},
			},
		},
		bd: {
			transitions: T.createTransitions({
				empty: { "*": {} },
				x$: { 0: { nextState: "!f", revisit: !0 } },
				formula$: { 0: { nextState: "f", revisit: !0 } },
				else: { 0: { nextState: "!f", revisit: !0 } },
				"-9.,9 no missing 0": { "*": { action_: "9,9" } },
				".": { "*": { action_: { type_: "insert", option: "electron dot" } } },
				"a-z": { f: { action_: "tex-math" } },
				x: { "*": { action_: { type_: "insert", option: "KV x" } } },
				letters: { "*": { action_: "rm" } },
				"'": { "*": { action_: { type_: "insert", option: "prime" } } },
				"${(...)}$|$(...)$": { "*": { action_: "tex-math" } },
				"{(...)}": { "*": { action_: "text" } },
				"\\color{(...)}{(...)}1|\\color(...){(...)}2": { "*": { action_: "color-output" } },
				"\\color{(...)}0": { "*": { action_: "color0-output" } },
				"\\ce{(...)}": { "*": { action_: "ce" } },
				"\\,|\\x{}{}|\\x{}|\\x": { "*": { action_: "copy" } },
				else2: { "*": { action_: "copy" } },
			}),
			actions: {
				"color-output": function (e, t) {
					return { type_: "color", color1: t[0], color2: T.go(t[1], "bd") };
				},
			},
		},
		oxidation: {
			transitions: T.createTransitions({
				empty: { "*": {} },
				"roman numeral": { "*": { action_: "roman-numeral" } },
				"${(...)}$|$(...)$": { "*": { action_: "tex-math" } },
				else: { "*": { action_: "copy" } },
			}),
			actions: {
				"roman-numeral": function (e, t) {
					return { type_: "roman numeral", p1: t || "" };
				},
			},
		},
		"tex-math": {
			transitions: T.createTransitions({
				empty: { "*": { action_: "output" } },
				"\\ce{(...)}": { "*": { action_: ["output", "ce"] } },
				"{...}|\\,|\\x{}{}|\\x{}|\\x": { "*": { action_: "o=" } },
				else: { "*": { action_: "o=" } },
			}),
			actions: {
				output: function (e) {
					if (e.o) {
						var t = { type_: "tex-math", p1: e.o };
						for (var n in e) delete e[n];
						return t;
					}
				},
			},
		},
		"tex-math tight": {
			transitions: T.createTransitions({
				empty: { "*": { action_: "output" } },
				"\\ce{(...)}": { "*": { action_: ["output", "ce"] } },
				"{...}|\\,|\\x{}{}|\\x{}|\\x": { "*": { action_: "o=" } },
				"-|+": { "*": { action_: "tight operator" } },
				else: { "*": { action_: "o=" } },
			}),
			actions: {
				"tight operator": function (e, t) {
					e.o = (e.o || "") + "{" + t + "}";
				},
				output: function (e) {
					if (e.o) {
						var t = { type_: "tex-math", p1: e.o };
						for (var n in e) delete e[n];
						return t;
					}
				},
			},
		},
		"9,9": {
			transitions: T.createTransitions({
				empty: { "*": {} },
				",": { "*": { action_: "comma" } },
				else: { "*": { action_: "copy" } },
			}),
			actions: {
				comma: function () {
					return { type_: "commaDecimal" };
				},
			},
		},
		pu: {
			transitions: T.createTransitions({
				empty: { "*": { action_: "output" } },
				space$: { "*": { action_: ["output", "space"] } },
				"{[(|)]}": { "0|a": { action_: "copy" } },
				"(-)(9)^(-9)": { 0: { action_: "number^", nextState: "a" } },
				"(-)(9.,9)(e)(99)": { 0: { action_: "enumber", nextState: "a" } },
				space: { "0|a": {} },
				"pm-operator": {
					"0|a": { action_: { type_: "operator", option: "\\pm" }, nextState: "0" },
				},
				operator: { "0|a": { action_: "copy", nextState: "0" } },
				"//": { d: { action_: "o=", nextState: "/" } },
				"/": { d: { action_: "o=", nextState: "/" } },
				"{...}|else": {
					"0|d": { action_: "d=", nextState: "d" },
					a: { action_: ["space", "d="], nextState: "d" },
					"/|q": { action_: "q=", nextState: "q" },
				},
			}),
			actions: {
				enumber: function (e, t) {
					var n = [];
					return (
						t[0] === "+-" || t[0] === "+/-" ? n.push("\\pm ") : t[0] && n.push(t[0]),
						t[1] &&
							(T.concatArray(n, T.go(t[1], "pu-9,9")),
							t[2] && (t[2].match(/[,.]/) ? T.concatArray(n, T.go(t[2], "pu-9,9")) : n.push(t[2])),
							(t[3] = t[4] || t[3]),
							t[3] &&
								((t[3] = t[3].trim()),
								t[3] === "e" || t[3].substr(0, 1) === "*"
									? n.push({ type_: "cdot" })
									: n.push({ type_: "times" }))),
						t[3] && n.push("10^{" + t[5] + "}"),
						n
					);
				},
				"number^": function (e, t) {
					var n = [];
					return (
						t[0] === "+-" || t[0] === "+/-" ? n.push("\\pm ") : t[0] && n.push(t[0]),
						T.concatArray(n, T.go(t[1], "pu-9,9")),
						n.push("^{" + t[2] + "}"),
						n
					);
				},
				operator: function (e, t, n) {
					return { type_: "operator", kind_: n || t };
				},
				space: function () {
					return { type_: "pu-space-1" };
				},
				output: function (e) {
					var t,
						n = T.patterns.match_("{(...)}", e.d || "");
					n && n.remainder === "" && (e.d = n.match_);
					var a = T.patterns.match_("{(...)}", e.q || "");
					if (
						(a && a.remainder === "" && (e.q = a.match_),
						e.d &&
							((e.d = e.d.replace(/\u00B0C|\^oC|\^{o}C/g, "{}^{\\circ}C")),
							(e.d = e.d.replace(/\u00B0F|\^oF|\^{o}F/g, "{}^{\\circ}F"))),
						e.q)
					) {
						(e.q = e.q.replace(/\u00B0C|\^oC|\^{o}C/g, "{}^{\\circ}C")),
							(e.q = e.q.replace(/\u00B0F|\^oF|\^{o}F/g, "{}^{\\circ}F"));
						var i = { d: T.go(e.d, "pu"), q: T.go(e.q, "pu") };
						e.o === "//"
							? (t = { type_: "pu-frac", p1: i.d, p2: i.q })
							: ((t = i.d),
								i.d.length > 1 || i.q.length > 1
									? t.push({ type_: " / " })
									: t.push({ type_: "/" }),
								T.concatArray(t, i.q));
					} else t = T.go(e.d, "pu-2");
					for (var s in e) delete e[s];
					return t;
				},
			},
		},
		"pu-2": {
			transitions: T.createTransitions({
				empty: { "*": { action_: "output" } },
				"*": { "*": { action_: ["output", "cdot"], nextState: "0" } },
				"\\x": { "*": { action_: "rm=" } },
				space: { "*": { action_: ["output", "space"], nextState: "0" } },
				"^{(...)}|^(-1)": { 1: { action_: "^(-1)" } },
				"-9.,9": { 0: { action_: "rm=", nextState: "0" }, 1: { action_: "^(-1)", nextState: "0" } },
				"{...}|else": { "*": { action_: "rm=", nextState: "1" } },
			}),
			actions: {
				cdot: function () {
					return { type_: "tight cdot" };
				},
				"^(-1)": function (e, t) {
					e.rm += "^{" + t + "}";
				},
				space: function () {
					return { type_: "pu-space-2" };
				},
				output: function (e) {
					var t = [];
					if (e.rm) {
						var n = T.patterns.match_("{(...)}", e.rm || "");
						n && n.remainder === "" ? (t = T.go(n.match_, "pu")) : (t = { type_: "rm", p1: e.rm });
					}
					for (var a in e) delete e[a];
					return t;
				},
			},
		},
		"pu-9,9": {
			transitions: T.createTransitions({
				empty: { 0: { action_: "output-0" }, o: { action_: "output-o" } },
				",": { 0: { action_: ["output-0", "comma"], nextState: "o" } },
				".": { 0: { action_: ["output-0", "copy"], nextState: "o" } },
				else: { "*": { action_: "text=" } },
			}),
			actions: {
				comma: function () {
					return { type_: "commaDecimal" };
				},
				"output-0": function (e) {
					var t = [];
					if (((e.text_ = e.text_ || ""), e.text_.length > 4)) {
						var n = e.text_.length % 3;
						n === 0 && (n = 3);
						for (var a = e.text_.length - 3; a > 0; a -= 3)
							t.push(e.text_.substr(a, 3)), t.push({ type_: "1000 separator" });
						t.push(e.text_.substr(0, n)), t.reverse();
					} else t.push(e.text_);
					for (var i in e) delete e[i];
					return t;
				},
				"output-o": function (e) {
					var t = [];
					if (((e.text_ = e.text_ || ""), e.text_.length > 4)) {
						for (var n = e.text_.length - 3, a = 0; a < n; a += 3)
							t.push(e.text_.substr(a, 3)), t.push({ type_: "1000 separator" });
						t.push(e.text_.substr(a));
					} else t.push(e.text_);
					for (var i in e) delete e[i];
					return t;
				},
			},
		},
	};
	var pe = {
		go: function (e, t) {
			if (!e) return "";
			for (var n = "", a = !1, i = 0; i < e.length; i++) {
				var s = e[i];
				typeof s == "string"
					? (n += s)
					: ((n += pe._go2(s)), s.type_ === "1st-level escape" && (a = !0));
			}
			return !t && !a && n && (n = "{" + n + "}"), n;
		},
		_goInner: function (e) {
			return e && pe.go(e, !0);
		},
		_go2: function (e) {
			var t;
			switch (e.type_) {
				case "chemfive":
					t = "";
					var n = {
						a: pe._goInner(e.a),
						b: pe._goInner(e.b),
						p: pe._goInner(e.p),
						o: pe._goInner(e.o),
						q: pe._goInner(e.q),
						d: pe._goInner(e.d),
					};
					n.a && (n.a.match(/^[+\-]/) && (n.a = "{" + n.a + "}"), (t += n.a + "\\,")),
						(n.b || n.p) &&
							((t += "{\\vphantom{X}}"),
							(t += "^{\\hphantom{" + (n.b || "") + "}}_{\\hphantom{" + (n.p || "") + "}}"),
							(t += "{\\vphantom{X}}"),
							(t += "^{\\smash[t]{\\vphantom{2}}\\mathllap{" + (n.b || "") + "}}"),
							(t += "_{\\vphantom{2}\\mathllap{\\smash[t]{" + (n.p || "") + "}}}")),
						n.o && (n.o.match(/^[+\-]/) && (n.o = "{" + n.o + "}"), (t += n.o)),
						e.dType === "kv"
							? ((n.d || n.q) && (t += "{\\vphantom{X}}"),
								n.d && (t += "^{" + n.d + "}"),
								n.q && (t += "_{\\smash[t]{" + n.q + "}}"))
							: e.dType === "oxidation"
								? (n.d && ((t += "{\\vphantom{X}}"), (t += "^{" + n.d + "}")),
									n.q && ((t += "{\\vphantom{X}}"), (t += "_{\\smash[t]{" + n.q + "}}")))
								: (n.q && ((t += "{\\vphantom{X}}"), (t += "_{\\smash[t]{" + n.q + "}}")),
									n.d && ((t += "{\\vphantom{X}}"), (t += "^{" + n.d + "}")));
					break;
				case "rm":
					t = "\\mathrm{" + e.p1 + "}";
					break;
				case "text":
					e.p1.match(/[\^_]/)
						? ((e.p1 = e.p1.replace(" ", "~").replace("-", "\\text{-}")),
							(t = "\\mathrm{" + e.p1 + "}"))
						: (t = "\\text{" + e.p1 + "}");
					break;
				case "roman numeral":
					t = "\\mathrm{" + e.p1 + "}";
					break;
				case "state of aggregation":
					t = "\\mskip2mu " + pe._goInner(e.p1);
					break;
				case "state of aggregation subscript":
					t = "\\mskip1mu " + pe._goInner(e.p1);
					break;
				case "bond":
					if (((t = pe._getBond(e.kind_)), !t))
						throw ["MhchemErrorBond", "mhchem Error. Unknown bond type (" + e.kind_ + ")"];
					break;
				case "frac":
					var a = "\\frac{" + e.p1 + "}{" + e.p2 + "}";
					t = "\\mathchoice{\\textstyle" + a + "}{" + a + "}{" + a + "}{" + a + "}";
					break;
				case "pu-frac":
					var i = "\\frac{" + pe._goInner(e.p1) + "}{" + pe._goInner(e.p2) + "}";
					t = "\\mathchoice{\\textstyle" + i + "}{" + i + "}{" + i + "}{" + i + "}";
					break;
				case "tex-math":
					t = e.p1 + " ";
					break;
				case "frac-ce":
					t = "\\frac{" + pe._goInner(e.p1) + "}{" + pe._goInner(e.p2) + "}";
					break;
				case "overset":
					t = "\\overset{" + pe._goInner(e.p1) + "}{" + pe._goInner(e.p2) + "}";
					break;
				case "underset":
					t = "\\underset{" + pe._goInner(e.p1) + "}{" + pe._goInner(e.p2) + "}";
					break;
				case "underbrace":
					t = "\\underbrace{" + pe._goInner(e.p1) + "}_{" + pe._goInner(e.p2) + "}";
					break;
				case "color":
					t = "{\\color{" + e.color1 + "}{" + pe._goInner(e.color2) + "}}";
					break;
				case "color0":
					t = "\\color{" + e.color + "}";
					break;
				case "arrow":
					var s = { rd: pe._goInner(e.rd), rq: pe._goInner(e.rq) },
						l = "\\x" + pe._getArrow(e.r);
					s.rq && (l += "[{" + s.rq + "}]"), s.rd ? (l += "{" + s.rd + "}") : (l += "{}"), (t = l);
					break;
				case "operator":
					t = pe._getOperator(e.kind_);
					break;
				case "1st-level escape":
					t = e.p1 + " ";
					break;
				case "space":
					t = " ";
					break;
				case "entitySkip":
					t = "~";
					break;
				case "pu-space-1":
					t = "~";
					break;
				case "pu-space-2":
					t = "\\mkern3mu ";
					break;
				case "1000 separator":
					t = "\\mkern2mu ";
					break;
				case "commaDecimal":
					t = "{,}";
					break;
				case "comma enumeration L":
					t = "{" + e.p1 + "}\\mkern6mu ";
					break;
				case "comma enumeration M":
					t = "{" + e.p1 + "}\\mkern3mu ";
					break;
				case "comma enumeration S":
					t = "{" + e.p1 + "}\\mkern1mu ";
					break;
				case "hyphen":
					t = "\\text{-}";
					break;
				case "addition compound":
					t = "\\,{\\cdot}\\,";
					break;
				case "electron dot":
					t = "\\mkern1mu \\bullet\\mkern1mu ";
					break;
				case "KV x":
					t = "{\\times}";
					break;
				case "prime":
					t = "\\prime ";
					break;
				case "cdot":
					t = "\\cdot ";
					break;
				case "tight cdot":
					t = "\\mkern1mu{\\cdot}\\mkern1mu ";
					break;
				case "times":
					t = "\\times ";
					break;
				case "circa":
					t = "{\\sim}";
					break;
				case "^":
					t = "uparrow";
					break;
				case "v":
					t = "downarrow";
					break;
				case "ellipsis":
					t = "\\ldots ";
					break;
				case "/":
					t = "/";
					break;
				case " / ":
					t = "\\,/\\,";
					break;
				default:
					throw ["MhchemBugT", "mhchem bug T. Please report."];
			}
			return t;
		},
		_getArrow: function (e) {
			switch (e) {
				case "->":
					return "rightarrow";
				case "→":
					return "rightarrow";
				case "⟶":
					return "rightarrow";
				case "<-":
					return "leftarrow";
				case "<->":
					return "leftrightarrow";
				case "<-->":
					return "rightleftarrows";
				case "<=>":
					return "rightleftharpoons";
				case "⇌":
					return "rightleftharpoons";
				case "<=>>":
					return "rightequilibrium";
				case "<<=>":
					return "leftequilibrium";
				default:
					throw ["MhchemBugT", "mhchem bug T. Please report."];
			}
		},
		_getBond: function (e) {
			switch (e) {
				case "-":
					return "{-}";
				case "1":
					return "{-}";
				case "=":
					return "{=}";
				case "2":
					return "{=}";
				case "#":
					return "{\\equiv}";
				case "3":
					return "{\\equiv}";
				case "~":
					return "{\\tripledash}";
				case "~-":
					return "{\\mathrlap{\\raisebox{-.1em}{$-$}}\\raisebox{.1em}{$\\tripledash$}}";
				case "~=":
					return "{\\mathrlap{\\raisebox{-.2em}{$-$}}\\mathrlap{\\raisebox{.2em}{$\\tripledash$}}-}";
				case "~--":
					return "{\\mathrlap{\\raisebox{-.2em}{$-$}}\\mathrlap{\\raisebox{.2em}{$\\tripledash$}}-}";
				case "-~-":
					return "{\\mathrlap{\\raisebox{-.2em}{$-$}}\\mathrlap{\\raisebox{.2em}{$-$}}\\tripledash}";
				case "...":
					return "{{\\cdot}{\\cdot}{\\cdot}}";
				case "....":
					return "{{\\cdot}{\\cdot}{\\cdot}{\\cdot}}";
				case "->":
					return "{\\rightarrow}";
				case "<-":
					return "{\\leftarrow}";
				case "<":
					return "{<}";
				case ">":
					return "{>}";
				default:
					throw ["MhchemBugT", "mhchem bug T. Please report."];
			}
		},
		_getOperator: function (e) {
			switch (e) {
				case "+":
					return " {}+{} ";
				case "-":
					return " {}-{} ";
				case "=":
					return " {}={} ";
				case "<":
					return " {}<{} ";
				case ">":
					return " {}>{} ";
				case "<<":
					return " {}\\ll{} ";
				case ">>":
					return " {}\\gg{} ";
				case "\\pm":
					return " {}\\pm{} ";
				case "\\approx":
					return " {}\\approx{} ";
				case "$\\approx$":
					return " {}\\approx{} ";
				case "v":
					return " \\downarrow{} ";
				case "(v)":
					return " \\downarrow{} ";
				case "^":
					return " \\uparrow{} ";
				case "(^)":
					return " \\uparrow{} ";
				default:
					throw ["MhchemBugT", "mhchem bug T. Please report."];
			}
		},
	};
	function rn() {
		return {
			async: !1,
			breaks: !1,
			extensions: null,
			gfm: !0,
			hooks: null,
			pedantic: !1,
			renderer: null,
			silent: !1,
			tokenizer: null,
			walkTokens: null,
		};
	}
	let Ft = rn();
	function ei(r) {
		Ft = r;
	}
	const ti = /[&<>"']/,
		rl = new RegExp(ti.source, "g"),
		ri = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,
		nl = new RegExp(ri.source, "g"),
		al = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" },
		ni = (r) => al[r];
	function Ye(r, e) {
		if (e) {
			if (ti.test(r)) return r.replace(rl, ni);
		} else if (ri.test(r)) return r.replace(nl, ni);
		return r;
	}
	const il = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi;
	function sl(r) {
		return r.replace(
			il,
			(e, t) => (
				(t = t.toLowerCase()),
				t === "colon"
					? ":"
					: t.charAt(0) === "#"
						? t.charAt(1) === "x"
							? String.fromCharCode(parseInt(t.substring(2), 16))
							: String.fromCharCode(+t.substring(1))
						: ""
			)
		);
	}
	const ol = /(^|[^\[])\^/g;
	function he(r, e) {
		let t = typeof r == "string" ? r : r.source;
		e = e || "";
		const n = {
			replace: (a, i) => {
				let s = typeof i == "string" ? i : i.source;
				return (s = s.replace(ol, "$1")), (t = t.replace(a, s)), n;
			},
			getRegex: () => new RegExp(t, e),
		};
		return n;
	}
	function ai(r) {
		try {
			r = encodeURI(r).replace(/%25/g, "%");
		} catch {
			return null;
		}
		return r;
	}
	const ur = { exec: () => null };
	function ii(r, e) {
		const t = r.replace(/\|/g, (i, s, l) => {
				let u = !1,
					d = s;
				for (; --d >= 0 && l[d] === "\\"; ) u = !u;
				return u ? "|" : " |";
			}),
			n = t.split(/ \|/);
		let a = 0;
		if ((n[0].trim() || n.shift(), n.length > 0 && !n[n.length - 1].trim() && n.pop(), e))
			if (n.length > e) n.splice(e);
			else for (; n.length < e; ) n.push("");
		for (; a < n.length; a++) n[a] = n[a].trim().replace(/\\\|/g, "|");
		return n;
	}
	function Vr(r, e, t) {
		const n = r.length;
		if (n === 0) return "";
		let a = 0;
		for (; a < n && r.charAt(n - a - 1) === e; ) a++;
		return r.slice(0, n - a);
	}
	function ll(r, e) {
		if (r.indexOf(e[1]) === -1) return -1;
		let t = 0;
		for (let n = 0; n < r.length; n++)
			if (r[n] === "\\") n++;
			else if (r[n] === e[0]) t++;
			else if (r[n] === e[1] && (t--, t < 0)) return n;
		return -1;
	}
	function si(r, e, t, n) {
		const a = e.href,
			i = e.title ? Ye(e.title) : null,
			s = r[1].replace(/\\([\[\]])/g, "$1");
		if (r[0].charAt(0) !== "!") {
			n.state.inLink = !0;
			const l = { type: "link", raw: t, href: a, title: i, text: s, tokens: n.inlineTokens(s) };
			return (n.state.inLink = !1), l;
		}
		return { type: "image", raw: t, href: a, title: i, text: Ye(s) };
	}
	function cl(r, e) {
		const t = r.match(/^(\s+)(?:```)/);
		if (t === null) return e;
		const n = t[1];
		return e
			.split(
				`
`
			)
			.map((a) => {
				const i = a.match(/^\s+/);
				if (i === null) return a;
				const [s] = i;
				return s.length >= n.length ? a.slice(n.length) : a;
			}).join(`
`);
	}
	class Wr {
		constructor(e) {
			ye(this, "options");
			ye(this, "rules");
			ye(this, "lexer");
			this.options = e || Ft;
		}
		space(e) {
			const t = this.rules.block.newline.exec(e);
			if (t && t[0].length > 0) return { type: "space", raw: t[0] };
		}
		code(e) {
			const t = this.rules.block.code.exec(e);
			if (t) {
				const n = t[0].replace(/^ {1,4}/gm, "");
				return {
					type: "code",
					raw: t[0],
					codeBlockStyle: "indented",
					text: this.options.pedantic
						? n
						: Vr(
								n,
								`
`
							),
				};
			}
		}
		fences(e) {
			const t = this.rules.block.fences.exec(e);
			if (t) {
				const n = t[0],
					a = cl(n, t[3] || "");
				return {
					type: "code",
					raw: n,
					lang: t[2] ? t[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : t[2],
					text: a,
				};
			}
		}
		heading(e) {
			const t = this.rules.block.heading.exec(e);
			if (t) {
				let n = t[2].trim();
				if (/#$/.test(n)) {
					const a = Vr(n, "#");
					(this.options.pedantic || !a || / $/.test(a)) && (n = a.trim());
				}
				return {
					type: "heading",
					raw: t[0],
					depth: t[1].length,
					text: n,
					tokens: this.lexer.inline(n),
				};
			}
		}
		hr(e) {
			const t = this.rules.block.hr.exec(e);
			if (t) return { type: "hr", raw: t[0] };
		}
		blockquote(e) {
			const t = this.rules.block.blockquote.exec(e);
			if (t) {
				let n = t[0].replace(
					/\n {0,3}((?:=+|-+) *)(?=\n|$)/g,
					`
    $1`
				);
				n = Vr(
					n.replace(/^ *>[ \t]?/gm, ""),
					`
`
				);
				const a = this.lexer.state.top;
				this.lexer.state.top = !0;
				const i = this.lexer.blockTokens(n);
				return (this.lexer.state.top = a), { type: "blockquote", raw: t[0], tokens: i, text: n };
			}
		}
		list(e) {
			let t = this.rules.block.list.exec(e);
			if (t) {
				let n = t[1].trim();
				const a = n.length > 1,
					i = {
						type: "list",
						raw: "",
						ordered: a,
						start: a ? +n.slice(0, -1) : "",
						loose: !1,
						items: [],
					};
				(n = a ? `\\d{1,9}\\${n.slice(-1)}` : `\\${n}`),
					this.options.pedantic && (n = a ? n : "[*+-]");
				const s = new RegExp(`^( {0,3}${n})((?:[	 ][^\\n]*)?(?:\\n|$))`);
				let l = "",
					u = "",
					d = !1;
				for (; e; ) {
					let p = !1;
					if (!(t = s.exec(e)) || this.rules.block.hr.test(e)) break;
					(l = t[0]), (e = e.substring(l.length));
					let f = t[2]
							.split(
								`
`,
								1
							)[0]
							.replace(/^\t+/, (O) => " ".repeat(3 * O.length)),
						v = e.split(
							`
`,
							1
						)[0],
						x = 0;
					this.options.pedantic
						? ((x = 2), (u = f.trimStart()))
						: ((x = t[2].search(/[^ ]/)),
							(x = x > 4 ? 1 : x),
							(u = f.slice(x)),
							(x += t[1].length));
					let _ = !1;
					if (
						(!f &&
							/^ *$/.test(v) &&
							((l +=
								v +
								`
`),
							(e = e.substring(v.length + 1)),
							(p = !0)),
						!p)
					) {
						const O = new RegExp(
								`^ {0,${Math.min(3, x - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`
							),
							I = new RegExp(
								`^ {0,${Math.min(3, x - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`
							),
							$ = new RegExp(`^ {0,${Math.min(3, x - 1)}}(?:\`\`\`|~~~)`),
							P = new RegExp(`^ {0,${Math.min(3, x - 1)}}#`);
						for (; e; ) {
							const q = e.split(
								`
`,
								1
							)[0];
							if (
								((v = q),
								this.options.pedantic && (v = v.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")),
								$.test(v) || P.test(v) || O.test(v) || I.test(e))
							)
								break;
							if (v.search(/[^ ]/) >= x || !v.trim())
								u +=
									`
` + v.slice(x);
							else {
								if (_ || f.search(/[^ ]/) >= 4 || $.test(f) || P.test(f) || I.test(f)) break;
								u +=
									`
` + v;
							}
							!_ && !v.trim() && (_ = !0),
								(l +=
									q +
									`
`),
								(e = e.substring(q.length + 1)),
								(f = v.slice(x));
						}
					}
					i.loose || (d ? (i.loose = !0) : /\n *\n *$/.test(l) && (d = !0));
					let S = null,
						M;
					this.options.gfm &&
						((S = /^\[[ xX]\] /.exec(u)),
						S && ((M = S[0] !== "[ ] "), (u = u.replace(/^\[[ xX]\] +/, "")))),
						i.items.push({
							type: "list_item",
							raw: l,
							task: !!S,
							checked: M,
							loose: !1,
							text: u,
							tokens: [],
						}),
						(i.raw += l);
				}
				(i.items[i.items.length - 1].raw = l.trimEnd()),
					(i.items[i.items.length - 1].text = u.trimEnd()),
					(i.raw = i.raw.trimEnd());
				for (let p = 0; p < i.items.length; p++)
					if (
						((this.lexer.state.top = !1),
						(i.items[p].tokens = this.lexer.blockTokens(i.items[p].text, [])),
						!i.loose)
					) {
						const f = i.items[p].tokens.filter((x) => x.type === "space"),
							v = f.length > 0 && f.some((x) => /\n.*\n/.test(x.raw));
						i.loose = v;
					}
				if (i.loose) for (let p = 0; p < i.items.length; p++) i.items[p].loose = !0;
				return i;
			}
		}
		html(e) {
			const t = this.rules.block.html.exec(e);
			if (t)
				return {
					type: "html",
					block: !0,
					raw: t[0],
					pre: t[1] === "pre" || t[1] === "script" || t[1] === "style",
					text: t[0],
				};
		}
		def(e) {
			const t = this.rules.block.def.exec(e);
			if (t) {
				const n = t[1].toLowerCase().replace(/\s+/g, " "),
					a = t[2]
						? t[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline.anyPunctuation, "$1")
						: "",
					i = t[3]
						? t[3].substring(1, t[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1")
						: t[3];
				return { type: "def", tag: n, raw: t[0], href: a, title: i };
			}
		}
		table(e) {
			const t = this.rules.block.table.exec(e);
			if (!t || !/[:|]/.test(t[2])) return;
			const n = ii(t[1]),
				a = t[2].replace(/^\||\| *$/g, "").split("|"),
				i =
					t[3] && t[3].trim()
						? t[3].replace(/\n[ \t]*$/, "").split(`
`)
						: [],
				s = { type: "table", raw: t[0], header: [], align: [], rows: [] };
			if (n.length === a.length) {
				for (const l of a)
					/^ *-+: *$/.test(l)
						? s.align.push("right")
						: /^ *:-+: *$/.test(l)
							? s.align.push("center")
							: /^ *:-+ *$/.test(l)
								? s.align.push("left")
								: s.align.push(null);
				for (const l of n) s.header.push({ text: l, tokens: this.lexer.inline(l) });
				for (const l of i)
					s.rows.push(
						ii(l, s.header.length).map((u) => ({ text: u, tokens: this.lexer.inline(u) }))
					);
				return s;
			}
		}
		lheading(e) {
			const t = this.rules.block.lheading.exec(e);
			if (t)
				return {
					type: "heading",
					raw: t[0],
					depth: t[2].charAt(0) === "=" ? 1 : 2,
					text: t[1],
					tokens: this.lexer.inline(t[1]),
				};
		}
		paragraph(e) {
			const t = this.rules.block.paragraph.exec(e);
			if (t) {
				const n =
					t[1].charAt(t[1].length - 1) ===
					`
`
						? t[1].slice(0, -1)
						: t[1];
				return { type: "paragraph", raw: t[0], text: n, tokens: this.lexer.inline(n) };
			}
		}
		text(e) {
			const t = this.rules.block.text.exec(e);
			if (t) return { type: "text", raw: t[0], text: t[0], tokens: this.lexer.inline(t[0]) };
		}
		escape(e) {
			const t = this.rules.inline.escape.exec(e);
			if (t) return { type: "escape", raw: t[0], text: Ye(t[1]) };
		}
		tag(e) {
			const t = this.rules.inline.tag.exec(e);
			if (t)
				return (
					!this.lexer.state.inLink && /^<a /i.test(t[0])
						? (this.lexer.state.inLink = !0)
						: this.lexer.state.inLink && /^<\/a>/i.test(t[0]) && (this.lexer.state.inLink = !1),
					!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(t[0])
						? (this.lexer.state.inRawBlock = !0)
						: this.lexer.state.inRawBlock &&
							/^<\/(pre|code|kbd|script)(\s|>)/i.test(t[0]) &&
							(this.lexer.state.inRawBlock = !1),
					{
						type: "html",
						raw: t[0],
						inLink: this.lexer.state.inLink,
						inRawBlock: this.lexer.state.inRawBlock,
						block: !1,
						text: t[0],
					}
				);
		}
		link(e) {
			const t = this.rules.inline.link.exec(e);
			if (t) {
				const n = t[2].trim();
				if (!this.options.pedantic && /^</.test(n)) {
					if (!/>$/.test(n)) return;
					const s = Vr(n.slice(0, -1), "\\");
					if ((n.length - s.length) % 2 === 0) return;
				} else {
					const s = ll(t[2], "()");
					if (s > -1) {
						const u = (t[0].indexOf("!") === 0 ? 5 : 4) + t[1].length + s;
						(t[2] = t[2].substring(0, s)), (t[0] = t[0].substring(0, u).trim()), (t[3] = "");
					}
				}
				let a = t[2],
					i = "";
				if (this.options.pedantic) {
					const s = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(a);
					s && ((a = s[1]), (i = s[3]));
				} else i = t[3] ? t[3].slice(1, -1) : "";
				return (
					(a = a.trim()),
					/^</.test(a) &&
						(this.options.pedantic && !/>$/.test(n) ? (a = a.slice(1)) : (a = a.slice(1, -1))),
					si(
						t,
						{
							href: a && a.replace(this.rules.inline.anyPunctuation, "$1"),
							title: i && i.replace(this.rules.inline.anyPunctuation, "$1"),
						},
						t[0],
						this.lexer
					)
				);
			}
		}
		reflink(e, t) {
			let n;
			if ((n = this.rules.inline.reflink.exec(e)) || (n = this.rules.inline.nolink.exec(e))) {
				const a = (n[2] || n[1]).replace(/\s+/g, " "),
					i = t[a.toLowerCase()];
				if (!i) {
					const s = n[0].charAt(0);
					return { type: "text", raw: s, text: s };
				}
				return si(n, i, n[0], this.lexer);
			}
		}
		emStrong(e, t, n = "") {
			let a = this.rules.inline.emStrongLDelim.exec(e);
			if (!a || (a[3] && n.match(/[\p{L}\p{N}]/u))) return;
			if (!(a[1] || a[2] || "") || !n || this.rules.inline.punctuation.exec(n)) {
				const s = [...a[0]].length - 1;
				let l,
					u,
					d = s,
					p = 0;
				const f =
					a[0][0] === "*"
						? this.rules.inline.emStrongRDelimAst
						: this.rules.inline.emStrongRDelimUnd;
				for (f.lastIndex = 0, t = t.slice(-1 * e.length + s); (a = f.exec(t)) != null; ) {
					if (((l = a[1] || a[2] || a[3] || a[4] || a[5] || a[6]), !l)) continue;
					if (((u = [...l].length), a[3] || a[4])) {
						d += u;
						continue;
					} else if ((a[5] || a[6]) && s % 3 && !((s + u) % 3)) {
						p += u;
						continue;
					}
					if (((d -= u), d > 0)) continue;
					u = Math.min(u, u + d + p);
					const v = [...a[0]][0].length,
						x = e.slice(0, s + a.index + v + u);
					if (Math.min(s, u) % 2) {
						const S = x.slice(1, -1);
						return { type: "em", raw: x, text: S, tokens: this.lexer.inlineTokens(S) };
					}
					const _ = x.slice(2, -2);
					return { type: "strong", raw: x, text: _, tokens: this.lexer.inlineTokens(_) };
				}
			}
		}
		codespan(e) {
			const t = this.rules.inline.code.exec(e);
			if (t) {
				let n = t[2].replace(/\n/g, " ");
				const a = /[^ ]/.test(n),
					i = /^ /.test(n) && / $/.test(n);
				return (
					a && i && (n = n.substring(1, n.length - 1)),
					(n = Ye(n, !0)),
					{ type: "codespan", raw: t[0], text: n }
				);
			}
		}
		br(e) {
			const t = this.rules.inline.br.exec(e);
			if (t) return { type: "br", raw: t[0] };
		}
		del(e) {
			const t = this.rules.inline.del.exec(e);
			if (t) return { type: "del", raw: t[0], text: t[2], tokens: this.lexer.inlineTokens(t[2]) };
		}
		autolink(e) {
			const t = this.rules.inline.autolink.exec(e);
			if (t) {
				let n, a;
				return (
					t[2] === "@" ? ((n = Ye(t[1])), (a = "mailto:" + n)) : ((n = Ye(t[1])), (a = n)),
					{ type: "link", raw: t[0], text: n, href: a, tokens: [{ type: "text", raw: n, text: n }] }
				);
			}
		}
		url(e) {
			var n;
			let t;
			if ((t = this.rules.inline.url.exec(e))) {
				let a, i;
				if (t[2] === "@") (a = Ye(t[0])), (i = "mailto:" + a);
				else {
					let s;
					do
						(s = t[0]),
							(t[0] =
								((n = this.rules.inline._backpedal.exec(t[0])) == null ? void 0 : n[0]) ?? "");
					while (s !== t[0]);
					(a = Ye(t[0])), t[1] === "www." ? (i = "http://" + t[0]) : (i = t[0]);
				}
				return {
					type: "link",
					raw: t[0],
					text: a,
					href: i,
					tokens: [{ type: "text", raw: a, text: a }],
				};
			}
		}
		inlineText(e) {
			const t = this.rules.inline.text.exec(e);
			if (t) {
				let n;
				return (
					this.lexer.state.inRawBlock ? (n = t[0]) : (n = Ye(t[0])),
					{ type: "text", raw: t[0], text: n }
				);
			}
		}
	}
	const ul = /^(?: *(?:\n|$))+/,
		hl = /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
		dl =
			/^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
		hr = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
		ml = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
		oi = /(?:[*+-]|\d{1,9}[.)])/,
		li = he(
			/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html))+?)\n {0,3}(=+|-+) *(?:\n+|$)/
		)
			.replace(/bull/g, oi)
			.replace(/blockCode/g, / {4}/)
			.replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/)
			.replace(/blockquote/g, / {0,3}>/)
			.replace(/heading/g, / {0,3}#{1,6}/)
			.replace(/html/g, / {0,3}<[^\n>]+>\n/)
			.getRegex(),
		nn = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
		pl = /^[^\n]+/,
		an = /(?!\s*\])(?:\\.|[^\[\]\\])+/,
		fl = he(
			/^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/
		)
			.replace("label", an)
			.replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/)
			.getRegex(),
		gl = he(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/)
			.replace(/bull/g, oi)
			.getRegex(),
		Zr =
			"address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul",
		sn = /<!--(?:-?>|[\s\S]*?(?:-->|$))/,
		bl = he(
			"^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
			"i"
		)
			.replace("comment", sn)
			.replace("tag", Zr)
			.replace(
				"attribute",
				/ +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/
			)
			.getRegex(),
		ci = he(nn)
			.replace("hr", hr)
			.replace("heading", " {0,3}#{1,6}(?:\\s|$)")
			.replace("|lheading", "")
			.replace("|table", "")
			.replace("blockquote", " {0,3}>")
			.replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n")
			.replace("list", " {0,3}(?:[*+-]|1[.)]) ")
			.replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)")
			.replace("tag", Zr)
			.getRegex(),
		on = {
			blockquote: he(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/)
				.replace("paragraph", ci)
				.getRegex(),
			code: hl,
			def: fl,
			fences: dl,
			heading: ml,
			hr,
			html: bl,
			lheading: li,
			list: gl,
			newline: ul,
			paragraph: ci,
			table: ur,
			text: pl,
		},
		ui = he(
			"^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
		)
			.replace("hr", hr)
			.replace("heading", " {0,3}#{1,6}(?:\\s|$)")
			.replace("blockquote", " {0,3}>")
			.replace("code", " {4}[^\\n]")
			.replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n")
			.replace("list", " {0,3}(?:[*+-]|1[.)]) ")
			.replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)")
			.replace("tag", Zr)
			.getRegex(),
		vl = {
			...on,
			table: ui,
			paragraph: he(nn)
				.replace("hr", hr)
				.replace("heading", " {0,3}#{1,6}(?:\\s|$)")
				.replace("|lheading", "")
				.replace("table", ui)
				.replace("blockquote", " {0,3}>")
				.replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n")
				.replace("list", " {0,3}(?:[*+-]|1[.)]) ")
				.replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)")
				.replace("tag", Zr)
				.getRegex(),
		},
		yl = {
			...on,
			html: he(
				`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`
			)
				.replace("comment", sn)
				.replace(
					/tag/g,
					"(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b"
				)
				.getRegex(),
			def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
			heading: /^(#{1,6})(.*)(?:\n+|$)/,
			fences: ur,
			lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
			paragraph: he(nn)
				.replace("hr", hr)
				.replace(
					"heading",
					` *#{1,6} *[^
]`
				)
				.replace("lheading", li)
				.replace("|table", "")
				.replace("blockquote", " {0,3}>")
				.replace("|fences", "")
				.replace("|list", "")
				.replace("|html", "")
				.replace("|tag", "")
				.getRegex(),
		},
		hi = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
		xl = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
		di = /^( {2,}|\\)\n(?!\s*$)/,
		wl = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
		dr = "\\p{P}\\p{S}",
		kl = he(/^((?![*_])[\spunctuation])/, "u")
			.replace(/punctuation/g, dr)
			.getRegex(),
		_l = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g,
		Sl = he(/^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/, "u")
			.replace(/punct/g, dr)
			.getRegex(),
		El = he(
			"^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)[punct](\\*+)(?=[\\s]|$)|[^punct\\s](\\*+)(?!\\*)(?=[punct\\s]|$)|(?!\\*)[punct\\s](\\*+)(?=[^punct\\s])|[\\s](\\*+)(?!\\*)(?=[punct])|(?!\\*)[punct](\\*+)(?!\\*)(?=[punct])|[^punct\\s](\\*+)(?=[^punct\\s])",
			"gu"
		)
			.replace(/punct/g, dr)
			.getRegex(),
		Tl = he(
			"^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\s]|$)|[^punct\\s](_+)(?!_)(?=[punct\\s]|$)|(?!_)[punct\\s](_+)(?=[^punct\\s])|[\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])",
			"gu"
		)
			.replace(/punct/g, dr)
			.getRegex(),
		Ml = he(/\\([punct])/, "gu")
			.replace(/punct/g, dr)
			.getRegex(),
		Al = he(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/)
			.replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)
			.replace(
				"email",
				/[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/
			)
			.getRegex(),
		Nl = he(sn).replace("(?:-->|$)", "-->").getRegex(),
		Ol = he(
			"^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>"
		)
			.replace("comment", Nl)
			.replace(
				"attribute",
				/\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/
			)
			.getRegex(),
		Xr = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/,
		zl = he(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/)
			.replace("label", Xr)
			.replace("href", /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/)
			.replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/)
			.getRegex(),
		mi = he(/^!?\[(label)\]\[(ref)\]/)
			.replace("label", Xr)
			.replace("ref", an)
			.getRegex(),
		pi = he(/^!?\[(ref)\](?:\[\])?/)
			.replace("ref", an)
			.getRegex(),
		Cl = he("reflink|nolink(?!\\()", "g").replace("reflink", mi).replace("nolink", pi).getRegex(),
		ln = {
			_backpedal: ur,
			anyPunctuation: Ml,
			autolink: Al,
			blockSkip: _l,
			br: di,
			code: xl,
			del: ur,
			emStrongLDelim: Sl,
			emStrongRDelimAst: El,
			emStrongRDelimUnd: Tl,
			escape: hi,
			link: zl,
			nolink: pi,
			punctuation: kl,
			reflink: mi,
			reflinkSearch: Cl,
			tag: Ol,
			text: wl,
			url: ur,
		},
		Rl = {
			...ln,
			link: he(/^!?\[(label)\]\((.*?)\)/)
				.replace("label", Xr)
				.getRegex(),
			reflink: he(/^!?\[(label)\]\s*\[([^\]]*)\]/)
				.replace("label", Xr)
				.getRegex(),
		},
		cn = {
			...ln,
			escape: he(hi).replace("])", "~|])").getRegex(),
			url: he(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i")
				.replace(
					"email",
					/[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/
				)
				.getRegex(),
			_backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
			del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
			text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/,
		},
		Il = {
			...cn,
			br: he(di).replace("{2,}", "*").getRegex(),
			text: he(cn.text)
				.replace("\\b_", "\\b_| {2,}\\n")
				.replace(/\{2,\}/g, "*")
				.getRegex(),
		},
		Yr = { normal: on, gfm: vl, pedantic: yl },
		mr = { normal: ln, gfm: cn, breaks: Il, pedantic: Rl };
	class it {
		constructor(e) {
			ye(this, "tokens");
			ye(this, "options");
			ye(this, "state");
			ye(this, "tokenizer");
			ye(this, "inlineQueue");
			(this.tokens = []),
				(this.tokens.links = Object.create(null)),
				(this.options = e || Ft),
				(this.options.tokenizer = this.options.tokenizer || new Wr()),
				(this.tokenizer = this.options.tokenizer),
				(this.tokenizer.options = this.options),
				(this.tokenizer.lexer = this),
				(this.inlineQueue = []),
				(this.state = { inLink: !1, inRawBlock: !1, top: !0 });
			const t = { block: Yr.normal, inline: mr.normal };
			this.options.pedantic
				? ((t.block = Yr.pedantic), (t.inline = mr.pedantic))
				: this.options.gfm &&
					((t.block = Yr.gfm), this.options.breaks ? (t.inline = mr.breaks) : (t.inline = mr.gfm)),
				(this.tokenizer.rules = t);
		}
		static get rules() {
			return { block: Yr, inline: mr };
		}
		static lex(e, t) {
			return new it(t).lex(e);
		}
		static lexInline(e, t) {
			return new it(t).inlineTokens(e);
		}
		lex(e) {
			(e = e.replace(
				/\r\n|\r/g,
				`
`
			)),
				this.blockTokens(e, this.tokens);
			for (let t = 0; t < this.inlineQueue.length; t++) {
				const n = this.inlineQueue[t];
				this.inlineTokens(n.src, n.tokens);
			}
			return (this.inlineQueue = []), this.tokens;
		}
		blockTokens(e, t = []) {
			this.options.pedantic
				? (e = e.replace(/\t/g, "    ").replace(/^ +$/gm, ""))
				: (e = e.replace(/^( *)(\t+)/gm, (l, u, d) => u + "    ".repeat(d.length)));
			let n, a, i, s;
			for (; e; )
				if (
					!(
						this.options.extensions &&
						this.options.extensions.block &&
						this.options.extensions.block.some((l) =>
							(n = l.call({ lexer: this }, e, t))
								? ((e = e.substring(n.raw.length)), t.push(n), !0)
								: !1
						)
					)
				) {
					if ((n = this.tokenizer.space(e))) {
						(e = e.substring(n.raw.length)),
							n.raw.length === 1 && t.length > 0
								? (t[t.length - 1].raw += `
`)
								: t.push(n);
						continue;
					}
					if ((n = this.tokenizer.code(e))) {
						(e = e.substring(n.raw.length)),
							(a = t[t.length - 1]),
							a && (a.type === "paragraph" || a.type === "text")
								? ((a.raw +=
										`
` + n.raw),
									(a.text +=
										`
` + n.text),
									(this.inlineQueue[this.inlineQueue.length - 1].src = a.text))
								: t.push(n);
						continue;
					}
					if ((n = this.tokenizer.fences(e))) {
						(e = e.substring(n.raw.length)), t.push(n);
						continue;
					}
					if ((n = this.tokenizer.heading(e))) {
						(e = e.substring(n.raw.length)), t.push(n);
						continue;
					}
					if ((n = this.tokenizer.hr(e))) {
						(e = e.substring(n.raw.length)), t.push(n);
						continue;
					}
					if ((n = this.tokenizer.blockquote(e))) {
						(e = e.substring(n.raw.length)), t.push(n);
						continue;
					}
					if ((n = this.tokenizer.list(e))) {
						(e = e.substring(n.raw.length)), t.push(n);
						continue;
					}
					if ((n = this.tokenizer.html(e))) {
						(e = e.substring(n.raw.length)), t.push(n);
						continue;
					}
					if ((n = this.tokenizer.def(e))) {
						(e = e.substring(n.raw.length)),
							(a = t[t.length - 1]),
							a && (a.type === "paragraph" || a.type === "text")
								? ((a.raw +=
										`
` + n.raw),
									(a.text +=
										`
` + n.raw),
									(this.inlineQueue[this.inlineQueue.length - 1].src = a.text))
								: this.tokens.links[n.tag] ||
									(this.tokens.links[n.tag] = { href: n.href, title: n.title });
						continue;
					}
					if ((n = this.tokenizer.table(e))) {
						(e = e.substring(n.raw.length)), t.push(n);
						continue;
					}
					if ((n = this.tokenizer.lheading(e))) {
						(e = e.substring(n.raw.length)), t.push(n);
						continue;
					}
					if (((i = e), this.options.extensions && this.options.extensions.startBlock)) {
						let l = 1 / 0;
						const u = e.slice(1);
						let d;
						this.options.extensions.startBlock.forEach((p) => {
							(d = p.call({ lexer: this }, u)),
								typeof d == "number" && d >= 0 && (l = Math.min(l, d));
						}),
							l < 1 / 0 && l >= 0 && (i = e.substring(0, l + 1));
					}
					if (this.state.top && (n = this.tokenizer.paragraph(i))) {
						(a = t[t.length - 1]),
							s && a.type === "paragraph"
								? ((a.raw +=
										`
` + n.raw),
									(a.text +=
										`
` + n.text),
									this.inlineQueue.pop(),
									(this.inlineQueue[this.inlineQueue.length - 1].src = a.text))
								: t.push(n),
							(s = i.length !== e.length),
							(e = e.substring(n.raw.length));
						continue;
					}
					if ((n = this.tokenizer.text(e))) {
						(e = e.substring(n.raw.length)),
							(a = t[t.length - 1]),
							a && a.type === "text"
								? ((a.raw +=
										`
` + n.raw),
									(a.text +=
										`
` + n.text),
									this.inlineQueue.pop(),
									(this.inlineQueue[this.inlineQueue.length - 1].src = a.text))
								: t.push(n);
						continue;
					}
					if (e) {
						const l = "Infinite loop on byte: " + e.charCodeAt(0);
						if (this.options.silent) {
							console.error(l);
							break;
						} else throw new Error(l);
					}
				}
			return (this.state.top = !0), t;
		}
		inline(e, t = []) {
			return this.inlineQueue.push({ src: e, tokens: t }), t;
		}
		inlineTokens(e, t = []) {
			let n,
				a,
				i,
				s = e,
				l,
				u,
				d;
			if (this.tokens.links) {
				const p = Object.keys(this.tokens.links);
				if (p.length > 0)
					for (; (l = this.tokenizer.rules.inline.reflinkSearch.exec(s)) != null; )
						p.includes(l[0].slice(l[0].lastIndexOf("[") + 1, -1)) &&
							(s =
								s.slice(0, l.index) +
								"[" +
								"a".repeat(l[0].length - 2) +
								"]" +
								s.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
			}
			for (; (l = this.tokenizer.rules.inline.blockSkip.exec(s)) != null; )
				s =
					s.slice(0, l.index) +
					"[" +
					"a".repeat(l[0].length - 2) +
					"]" +
					s.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
			for (; (l = this.tokenizer.rules.inline.anyPunctuation.exec(s)) != null; )
				s =
					s.slice(0, l.index) +
					"++" +
					s.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
			for (; e; )
				if (
					(u || (d = ""),
					(u = !1),
					!(
						this.options.extensions &&
						this.options.extensions.inline &&
						this.options.extensions.inline.some((p) =>
							(n = p.call({ lexer: this }, e, t))
								? ((e = e.substring(n.raw.length)), t.push(n), !0)
								: !1
						)
					))
				) {
					if ((n = this.tokenizer.escape(e))) {
						(e = e.substring(n.raw.length)), t.push(n);
						continue;
					}
					if ((n = this.tokenizer.tag(e))) {
						(e = e.substring(n.raw.length)),
							(a = t[t.length - 1]),
							a && n.type === "text" && a.type === "text"
								? ((a.raw += n.raw), (a.text += n.text))
								: t.push(n);
						continue;
					}
					if ((n = this.tokenizer.link(e))) {
						(e = e.substring(n.raw.length)), t.push(n);
						continue;
					}
					if ((n = this.tokenizer.reflink(e, this.tokens.links))) {
						(e = e.substring(n.raw.length)),
							(a = t[t.length - 1]),
							a && n.type === "text" && a.type === "text"
								? ((a.raw += n.raw), (a.text += n.text))
								: t.push(n);
						continue;
					}
					if ((n = this.tokenizer.emStrong(e, s, d))) {
						(e = e.substring(n.raw.length)), t.push(n);
						continue;
					}
					if ((n = this.tokenizer.codespan(e))) {
						(e = e.substring(n.raw.length)), t.push(n);
						continue;
					}
					if ((n = this.tokenizer.br(e))) {
						(e = e.substring(n.raw.length)), t.push(n);
						continue;
					}
					if ((n = this.tokenizer.del(e))) {
						(e = e.substring(n.raw.length)), t.push(n);
						continue;
					}
					if ((n = this.tokenizer.autolink(e))) {
						(e = e.substring(n.raw.length)), t.push(n);
						continue;
					}
					if (!this.state.inLink && (n = this.tokenizer.url(e))) {
						(e = e.substring(n.raw.length)), t.push(n);
						continue;
					}
					if (((i = e), this.options.extensions && this.options.extensions.startInline)) {
						let p = 1 / 0;
						const f = e.slice(1);
						let v;
						this.options.extensions.startInline.forEach((x) => {
							(v = x.call({ lexer: this }, f)),
								typeof v == "number" && v >= 0 && (p = Math.min(p, v));
						}),
							p < 1 / 0 && p >= 0 && (i = e.substring(0, p + 1));
					}
					if ((n = this.tokenizer.inlineText(i))) {
						(e = e.substring(n.raw.length)),
							n.raw.slice(-1) !== "_" && (d = n.raw.slice(-1)),
							(u = !0),
							(a = t[t.length - 1]),
							a && a.type === "text" ? ((a.raw += n.raw), (a.text += n.text)) : t.push(n);
						continue;
					}
					if (e) {
						const p = "Infinite loop on byte: " + e.charCodeAt(0);
						if (this.options.silent) {
							console.error(p);
							break;
						} else throw new Error(p);
					}
				}
			return t;
		}
	}
	class Qr {
		constructor(e) {
			ye(this, "options");
			this.options = e || Ft;
		}
		code(e, t, n) {
			var i;
			const a = (i = (t || "").match(/^\S*/)) == null ? void 0 : i[0];
			return (
				(e =
					e.replace(/\n$/, "") +
					`
`),
				a
					? '<pre><code class="language-' +
						Ye(a) +
						'">' +
						(n ? e : Ye(e, !0)) +
						`</code></pre>
`
					: "<pre><code>" +
						(n ? e : Ye(e, !0)) +
						`</code></pre>
`
			);
		}
		blockquote(e) {
			return `<blockquote>
${e}</blockquote>
`;
		}
		html(e, t) {
			return e;
		}
		heading(e, t, n) {
			return `<h${t}>${e}</h${t}>
`;
		}
		hr() {
			return `<hr>
`;
		}
		list(e, t, n) {
			const a = t ? "ol" : "ul",
				i = t && n !== 1 ? ' start="' + n + '"' : "";
			return (
				"<" +
				a +
				i +
				`>
` +
				e +
				"</" +
				a +
				`>
`
			);
		}
		listitem(e, t, n) {
			return `<li>${e}</li>
`;
		}
		checkbox(e) {
			return "<input " + (e ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
		}
		paragraph(e) {
			return `<p>${e}</p>
`;
		}
		table(e, t) {
			return (
				t && (t = `<tbody>${t}</tbody>`),
				`<table>
<thead>
` +
					e +
					`</thead>
` +
					t +
					`</table>
`
			);
		}
		tablerow(e) {
			return `<tr>
${e}</tr>
`;
		}
		tablecell(e, t) {
			const n = t.header ? "th" : "td";
			return (
				(t.align ? `<${n} align="${t.align}">` : `<${n}>`) +
				e +
				`</${n}>
`
			);
		}
		strong(e) {
			return `<strong>${e}</strong>`;
		}
		em(e) {
			return `<em>${e}</em>`;
		}
		codespan(e) {
			return `<code>${e}</code>`;
		}
		br() {
			return "<br>";
		}
		del(e) {
			return `<del>${e}</del>`;
		}
		link(e, t, n) {
			const a = ai(e);
			if (a === null) return n;
			e = a;
			let i = '<a href="' + e + '"';
			return t && (i += ' title="' + t + '"'), (i += ">" + n + "</a>"), i;
		}
		image(e, t, n) {
			const a = ai(e);
			if (a === null) return n;
			e = a;
			let i = `<img src="${e}" alt="${n}"`;
			return t && (i += ` title="${t}"`), (i += ">"), i;
		}
		text(e) {
			return e;
		}
	}
	class un {
		strong(e) {
			return e;
		}
		em(e) {
			return e;
		}
		codespan(e) {
			return e;
		}
		del(e) {
			return e;
		}
		html(e) {
			return e;
		}
		text(e) {
			return e;
		}
		link(e, t, n) {
			return "" + n;
		}
		image(e, t, n) {
			return "" + n;
		}
		br() {
			return "";
		}
	}
	class mt {
		constructor(e) {
			ye(this, "options");
			ye(this, "renderer");
			ye(this, "textRenderer");
			(this.options = e || Ft),
				(this.options.renderer = this.options.renderer || new Qr()),
				(this.renderer = this.options.renderer),
				(this.renderer.options = this.options),
				(this.textRenderer = new un());
		}
		static parse(e, t) {
			return new mt(t).parse(e);
		}
		static parseInline(e, t) {
			return new mt(t).parseInline(e);
		}
		parse(e, t = !0) {
			let n = "";
			for (let a = 0; a < e.length; a++) {
				const i = e[a];
				if (
					this.options.extensions &&
					this.options.extensions.renderers &&
					this.options.extensions.renderers[i.type]
				) {
					const s = i,
						l = this.options.extensions.renderers[s.type].call({ parser: this }, s);
					if (
						l !== !1 ||
						![
							"space",
							"hr",
							"heading",
							"code",
							"table",
							"blockquote",
							"list",
							"html",
							"paragraph",
							"text",
						].includes(s.type)
					) {
						n += l || "";
						continue;
					}
				}
				switch (i.type) {
					case "space":
						continue;
					case "hr": {
						n += this.renderer.hr();
						continue;
					}
					case "heading": {
						const s = i;
						n += this.renderer.heading(
							this.parseInline(s.tokens),
							s.depth,
							sl(this.parseInline(s.tokens, this.textRenderer))
						);
						continue;
					}
					case "code": {
						const s = i;
						n += this.renderer.code(s.text, s.lang, !!s.escaped);
						continue;
					}
					case "table": {
						const s = i;
						let l = "",
							u = "";
						for (let p = 0; p < s.header.length; p++)
							u += this.renderer.tablecell(this.parseInline(s.header[p].tokens), {
								header: !0,
								align: s.align[p],
							});
						l += this.renderer.tablerow(u);
						let d = "";
						for (let p = 0; p < s.rows.length; p++) {
							const f = s.rows[p];
							u = "";
							for (let v = 0; v < f.length; v++)
								u += this.renderer.tablecell(this.parseInline(f[v].tokens), {
									header: !1,
									align: s.align[v],
								});
							d += this.renderer.tablerow(u);
						}
						n += this.renderer.table(l, d);
						continue;
					}
					case "blockquote": {
						const s = i,
							l = this.parse(s.tokens);
						n += this.renderer.blockquote(l);
						continue;
					}
					case "list": {
						const s = i,
							l = s.ordered,
							u = s.start,
							d = s.loose;
						let p = "";
						for (let f = 0; f < s.items.length; f++) {
							const v = s.items[f],
								x = v.checked,
								_ = v.task;
							let S = "";
							if (v.task) {
								const M = this.renderer.checkbox(!!x);
								d
									? v.tokens.length > 0 && v.tokens[0].type === "paragraph"
										? ((v.tokens[0].text = M + " " + v.tokens[0].text),
											v.tokens[0].tokens &&
												v.tokens[0].tokens.length > 0 &&
												v.tokens[0].tokens[0].type === "text" &&
												(v.tokens[0].tokens[0].text = M + " " + v.tokens[0].tokens[0].text))
										: v.tokens.unshift({ type: "text", text: M + " " })
									: (S += M + " ");
							}
							(S += this.parse(v.tokens, d)), (p += this.renderer.listitem(S, _, !!x));
						}
						n += this.renderer.list(p, l, u);
						continue;
					}
					case "html": {
						const s = i;
						n += this.renderer.html(s.text, s.block);
						continue;
					}
					case "paragraph": {
						const s = i;
						n += this.renderer.paragraph(this.parseInline(s.tokens));
						continue;
					}
					case "text": {
						let s = i,
							l = s.tokens ? this.parseInline(s.tokens) : s.text;
						for (; a + 1 < e.length && e[a + 1].type === "text"; )
							(s = e[++a]),
								(l +=
									`
` + (s.tokens ? this.parseInline(s.tokens) : s.text));
						n += t ? this.renderer.paragraph(l) : l;
						continue;
					}
					default: {
						const s = 'Token with "' + i.type + '" type was not found.';
						if (this.options.silent) return console.error(s), "";
						throw new Error(s);
					}
				}
			}
			return n;
		}
		parseInline(e, t) {
			t = t || this.renderer;
			let n = "";
			for (let a = 0; a < e.length; a++) {
				const i = e[a];
				if (
					this.options.extensions &&
					this.options.extensions.renderers &&
					this.options.extensions.renderers[i.type]
				) {
					const s = this.options.extensions.renderers[i.type].call({ parser: this }, i);
					if (
						s !== !1 ||
						![
							"escape",
							"html",
							"link",
							"image",
							"strong",
							"em",
							"codespan",
							"br",
							"del",
							"text",
						].includes(i.type)
					) {
						n += s || "";
						continue;
					}
				}
				switch (i.type) {
					case "escape": {
						const s = i;
						n += t.text(s.text);
						break;
					}
					case "html": {
						const s = i;
						n += t.html(s.text);
						break;
					}
					case "link": {
						const s = i;
						n += t.link(s.href, s.title, this.parseInline(s.tokens, t));
						break;
					}
					case "image": {
						const s = i;
						n += t.image(s.href, s.title, s.text);
						break;
					}
					case "strong": {
						const s = i;
						n += t.strong(this.parseInline(s.tokens, t));
						break;
					}
					case "em": {
						const s = i;
						n += t.em(this.parseInline(s.tokens, t));
						break;
					}
					case "codespan": {
						const s = i;
						n += t.codespan(s.text);
						break;
					}
					case "br": {
						n += t.br();
						break;
					}
					case "del": {
						const s = i;
						n += t.del(this.parseInline(s.tokens, t));
						break;
					}
					case "text": {
						const s = i;
						n += t.text(s.text);
						break;
					}
					default: {
						const s = 'Token with "' + i.type + '" type was not found.';
						if (this.options.silent) return console.error(s), "";
						throw new Error(s);
					}
				}
			}
			return n;
		}
	}
	class pr {
		constructor(e) {
			ye(this, "options");
			this.options = e || Ft;
		}
		preprocess(e) {
			return e;
		}
		postprocess(e) {
			return e;
		}
		processAllTokens(e) {
			return e;
		}
	}
	ye(pr, "passThroughHooks", new Set(["preprocess", "postprocess", "processAllTokens"]));
	class fi {
		constructor(...e) {
			ji(this, Ut);
			ye(this, "defaults", rn());
			ye(this, "options", this.setOptions);
			ye(this, "parse", h0(this, Ut, _n).call(this, it.lex, mt.parse));
			ye(this, "parseInline", h0(this, Ut, _n).call(this, it.lexInline, mt.parseInline));
			ye(this, "Parser", mt);
			ye(this, "Renderer", Qr);
			ye(this, "TextRenderer", un);
			ye(this, "Lexer", it);
			ye(this, "Tokenizer", Wr);
			ye(this, "Hooks", pr);
			this.use(...e);
		}
		walkTokens(e, t) {
			var a, i;
			let n = [];
			for (const s of e)
				switch (((n = n.concat(t.call(this, s))), s.type)) {
					case "table": {
						const l = s;
						for (const u of l.header) n = n.concat(this.walkTokens(u.tokens, t));
						for (const u of l.rows) for (const d of u) n = n.concat(this.walkTokens(d.tokens, t));
						break;
					}
					case "list": {
						const l = s;
						n = n.concat(this.walkTokens(l.items, t));
						break;
					}
					default: {
						const l = s;
						(i = (a = this.defaults.extensions) == null ? void 0 : a.childTokens) != null &&
						i[l.type]
							? this.defaults.extensions.childTokens[l.type].forEach((u) => {
									const d = l[u].flat(1 / 0);
									n = n.concat(this.walkTokens(d, t));
								})
							: l.tokens && (n = n.concat(this.walkTokens(l.tokens, t)));
					}
				}
			return n;
		}
		use(...e) {
			const t = this.defaults.extensions || { renderers: {}, childTokens: {} };
			return (
				e.forEach((n) => {
					const a = { ...n };
					if (
						((a.async = this.defaults.async || a.async || !1),
						n.extensions &&
							(n.extensions.forEach((i) => {
								if (!i.name) throw new Error("extension name required");
								if ("renderer" in i) {
									const s = t.renderers[i.name];
									s
										? (t.renderers[i.name] = function (...l) {
												let u = i.renderer.apply(this, l);
												return u === !1 && (u = s.apply(this, l)), u;
											})
										: (t.renderers[i.name] = i.renderer);
								}
								if ("tokenizer" in i) {
									if (!i.level || (i.level !== "block" && i.level !== "inline"))
										throw new Error("extension level must be 'block' or 'inline'");
									const s = t[i.level];
									s ? s.unshift(i.tokenizer) : (t[i.level] = [i.tokenizer]),
										i.start &&
											(i.level === "block"
												? t.startBlock
													? t.startBlock.push(i.start)
													: (t.startBlock = [i.start])
												: i.level === "inline" &&
													(t.startInline
														? t.startInline.push(i.start)
														: (t.startInline = [i.start])));
								}
								"childTokens" in i && i.childTokens && (t.childTokens[i.name] = i.childTokens);
							}),
							(a.extensions = t)),
						n.renderer)
					) {
						const i = this.defaults.renderer || new Qr(this.defaults);
						for (const s in n.renderer) {
							if (!(s in i)) throw new Error(`renderer '${s}' does not exist`);
							if (s === "options") continue;
							const l = s,
								u = n.renderer[l],
								d = i[l];
							i[l] = (...p) => {
								let f = u.apply(i, p);
								return f === !1 && (f = d.apply(i, p)), f || "";
							};
						}
						a.renderer = i;
					}
					if (n.tokenizer) {
						const i = this.defaults.tokenizer || new Wr(this.defaults);
						for (const s in n.tokenizer) {
							if (!(s in i)) throw new Error(`tokenizer '${s}' does not exist`);
							if (["options", "rules", "lexer"].includes(s)) continue;
							const l = s,
								u = n.tokenizer[l],
								d = i[l];
							i[l] = (...p) => {
								let f = u.apply(i, p);
								return f === !1 && (f = d.apply(i, p)), f;
							};
						}
						a.tokenizer = i;
					}
					if (n.hooks) {
						const i = this.defaults.hooks || new pr();
						for (const s in n.hooks) {
							if (!(s in i)) throw new Error(`hook '${s}' does not exist`);
							if (s === "options") continue;
							const l = s,
								u = n.hooks[l],
								d = i[l];
							pr.passThroughHooks.has(s)
								? (i[l] = (p) => {
										if (this.defaults.async)
											return Promise.resolve(u.call(i, p)).then((v) => d.call(i, v));
										const f = u.call(i, p);
										return d.call(i, f);
									})
								: (i[l] = (...p) => {
										let f = u.apply(i, p);
										return f === !1 && (f = d.apply(i, p)), f;
									});
						}
						a.hooks = i;
					}
					if (n.walkTokens) {
						const i = this.defaults.walkTokens,
							s = n.walkTokens;
						a.walkTokens = function (l) {
							let u = [];
							return u.push(s.call(this, l)), i && (u = u.concat(i.call(this, l))), u;
						};
					}
					this.defaults = { ...this.defaults, ...a };
				}),
				this
			);
		}
		setOptions(e) {
			return (this.defaults = { ...this.defaults, ...e }), this;
		}
		lexer(e, t) {
			return it.lex(e, t ?? this.defaults);
		}
		parser(e, t) {
			return mt.parse(e, t ?? this.defaults);
		}
	}
	(Ut = new WeakSet()),
		(_n = function (e, t) {
			return (n, a) => {
				const i = { ...a },
					s = { ...this.defaults, ...i };
				this.defaults.async === !0 &&
					i.async === !1 &&
					(s.silent ||
						console.warn(
							"marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored."
						),
					(s.async = !0));
				const l = h0(this, Ut, es).call(this, !!s.silent, !!s.async);
				if (typeof n > "u" || n === null)
					return l(new Error("marked(): input parameter is undefined or null"));
				if (typeof n != "string")
					return l(
						new Error(
							"marked(): input parameter is of type " +
								Object.prototype.toString.call(n) +
								", string expected"
						)
					);
				if ((s.hooks && (s.hooks.options = s), s.async))
					return Promise.resolve(s.hooks ? s.hooks.preprocess(n) : n)
						.then((u) => e(u, s))
						.then((u) => (s.hooks ? s.hooks.processAllTokens(u) : u))
						.then((u) =>
							s.walkTokens ? Promise.all(this.walkTokens(u, s.walkTokens)).then(() => u) : u
						)
						.then((u) => t(u, s))
						.then((u) => (s.hooks ? s.hooks.postprocess(u) : u))
						.catch(l);
				try {
					s.hooks && (n = s.hooks.preprocess(n));
					let u = e(n, s);
					s.hooks && (u = s.hooks.processAllTokens(u)),
						s.walkTokens && this.walkTokens(u, s.walkTokens);
					let d = t(u, s);
					return s.hooks && (d = s.hooks.postprocess(d)), d;
				} catch (u) {
					return l(u);
				}
			};
		}),
		(es = function (e, t) {
			return (n) => {
				if (
					((n.message += `
Please report this to https://github.com/markedjs/marked.`),
					e)
				) {
					const a = "<p>An error occurred:</p><pre>" + Ye(n.message + "", !0) + "</pre>";
					return t ? Promise.resolve(a) : a;
				}
				if (t) return Promise.reject(n);
				throw n;
			};
		});
	const Ht = new fi();
	function de(r, e) {
		return Ht.parse(r, e);
	}
	(de.options = de.setOptions =
		function (r) {
			return Ht.setOptions(r), (de.defaults = Ht.defaults), ei(de.defaults), de;
		}),
		(de.getDefaults = rn),
		(de.defaults = Ft),
		(de.use = function (...r) {
			return Ht.use(...r), (de.defaults = Ht.defaults), ei(de.defaults), de;
		}),
		(de.walkTokens = function (r, e) {
			return Ht.walkTokens(r, e);
		}),
		(de.parseInline = Ht.parseInline),
		(de.Parser = mt),
		(de.parser = mt.parse),
		(de.Renderer = Qr),
		(de.TextRenderer = un),
		(de.Lexer = it),
		(de.lexer = it.lex),
		(de.Tokenizer = Wr),
		(de.Hooks = pr),
		(de.parse = de),
		de.options,
		de.setOptions,
		de.use,
		de.walkTokens,
		de.parseInline,
		mt.parse,
		it.lex;
	function Dl(r) {
		return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
	}
	var hn, gi;
	function Bl() {
		if (gi) return hn;
		gi = 1;
		function r(y) {
			return (
				y instanceof Map
					? (y.clear =
							y.delete =
							y.set =
								function () {
									throw new Error("map is read-only");
								})
					: y instanceof Set &&
						(y.add =
							y.clear =
							y.delete =
								function () {
									throw new Error("set is read-only");
								}),
				Object.freeze(y),
				Object.getOwnPropertyNames(y).forEach((E) => {
					const D = y[E],
						j = typeof D;
					(j === "object" || j === "function") && !Object.isFrozen(D) && r(D);
				}),
				y
			);
		}
		class e {
			constructor(E) {
				E.data === void 0 && (E.data = {}), (this.data = E.data), (this.isMatchIgnored = !1);
			}
			ignoreMatch() {
				this.isMatchIgnored = !0;
			}
		}
		function t(y) {
			return y
				.replace(/&/g, "&amp;")
				.replace(/</g, "&lt;")
				.replace(/>/g, "&gt;")
				.replace(/"/g, "&quot;")
				.replace(/'/g, "&#x27;");
		}
		function n(y, ...E) {
			const D = Object.create(null);
			for (const j in y) D[j] = y[j];
			return (
				E.forEach(function (j) {
					for (const Ne in j) D[Ne] = j[Ne];
				}),
				D
			);
		}
		const a = "</span>",
			i = (y) => !!y.scope,
			s = (y, { prefix: E }) => {
				if (y.startsWith("language:")) return y.replace("language:", "language-");
				if (y.includes(".")) {
					const D = y.split(".");
					return [`${E}${D.shift()}`, ...D.map((j, Ne) => `${j}${"_".repeat(Ne + 1)}`)].join(" ");
				}
				return `${E}${y}`;
			};
		class l {
			constructor(E, D) {
				(this.buffer = ""), (this.classPrefix = D.classPrefix), E.walk(this);
			}
			addText(E) {
				this.buffer += t(E);
			}
			openNode(E) {
				if (!i(E)) return;
				const D = s(E.scope, { prefix: this.classPrefix });
				this.span(D);
			}
			closeNode(E) {
				i(E) && (this.buffer += a);
			}
			value() {
				return this.buffer;
			}
			span(E) {
				this.buffer += `<span class="${E}">`;
			}
		}
		const u = (y = {}) => {
			const E = { children: [] };
			return Object.assign(E, y), E;
		};
		class d {
			constructor() {
				(this.rootNode = u()), (this.stack = [this.rootNode]);
			}
			get top() {
				return this.stack[this.stack.length - 1];
			}
			get root() {
				return this.rootNode;
			}
			add(E) {
				this.top.children.push(E);
			}
			openNode(E) {
				const D = u({ scope: E });
				this.add(D), this.stack.push(D);
			}
			closeNode() {
				if (this.stack.length > 1) return this.stack.pop();
			}
			closeAllNodes() {
				for (; this.closeNode(); );
			}
			toJSON() {
				return JSON.stringify(this.rootNode, null, 4);
			}
			walk(E) {
				return this.constructor._walk(E, this.rootNode);
			}
			static _walk(E, D) {
				return (
					typeof D == "string"
						? E.addText(D)
						: D.children &&
							(E.openNode(D), D.children.forEach((j) => this._walk(E, j)), E.closeNode(D)),
					E
				);
			}
			static _collapse(E) {
				typeof E != "string" &&
					E.children &&
					(E.children.every((D) => typeof D == "string")
						? (E.children = [E.children.join("")])
						: E.children.forEach((D) => {
								d._collapse(D);
							}));
			}
		}
		class p extends d {
			constructor(E) {
				super(), (this.options = E);
			}
			addText(E) {
				E !== "" && this.add(E);
			}
			startScope(E) {
				this.openNode(E);
			}
			endScope() {
				this.closeNode();
			}
			__addSublanguage(E, D) {
				const j = E.root;
				D && (j.scope = `language:${D}`), this.add(j);
			}
			toHTML() {
				return new l(this, this.options).value();
			}
			finalize() {
				return this.closeAllNodes(), !0;
			}
		}
		function f(y) {
			return y ? (typeof y == "string" ? y : y.source) : null;
		}
		function v(y) {
			return S("(?=", y, ")");
		}
		function x(y) {
			return S("(?:", y, ")*");
		}
		function _(y) {
			return S("(?:", y, ")?");
		}
		function S(...y) {
			return y.map((D) => f(D)).join("");
		}
		function M(y) {
			const E = y[y.length - 1];
			return typeof E == "object" && E.constructor === Object ? (y.splice(y.length - 1, 1), E) : {};
		}
		function O(...y) {
			return "(" + (M(y).capture ? "" : "?:") + y.map((j) => f(j)).join("|") + ")";
		}
		function I(y) {
			return new RegExp(y.toString() + "|").exec("").length - 1;
		}
		function $(y, E) {
			const D = y && y.exec(E);
			return D && D.index === 0;
		}
		const P = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
		function q(y, { joinWith: E }) {
			let D = 0;
			return y
				.map((j) => {
					D += 1;
					const Ne = D;
					let Oe = f(j),
						G = "";
					for (; Oe.length > 0; ) {
						const H = P.exec(Oe);
						if (!H) {
							G += Oe;
							break;
						}
						(G += Oe.substring(0, H.index)),
							(Oe = Oe.substring(H.index + H[0].length)),
							H[0][0] === "\\" && H[1]
								? (G += "\\" + String(Number(H[1]) + Ne))
								: ((G += H[0]), H[0] === "(" && D++);
					}
					return G;
				})
				.map((j) => `(${j})`)
				.join(E);
		}
		const U = /\b\B/,
			Q = "[a-zA-Z]\\w*",
			ne = "[a-zA-Z_]\\w*",
			te = "\\b\\d+(\\.\\d+)?",
			Pe = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)",
			Ee = "\\b(0b[01]+)",
			ve =
				"!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~",
			Qe = (y = {}) => {
				const E = /^#![ ]*\//;
				return (
					y.binary && (y.begin = S(E, /.*\b/, y.binary, /\b.*/)),
					n(
						{
							scope: "meta",
							begin: E,
							end: /$/,
							relevance: 0,
							"on:begin": (D, j) => {
								D.index !== 0 && j.ignoreMatch();
							},
						},
						y
					)
				);
			},
			we = { begin: "\\\\[\\s\\S]", relevance: 0 },
			$e = { scope: "string", begin: "'", end: "'", illegal: "\\n", contains: [we] },
			Fe = { scope: "string", begin: '"', end: '"', illegal: "\\n", contains: [we] },
			nt = {
				begin:
					/\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/,
			},
			ie = function (y, E, D = {}) {
				const j = n({ scope: "comment", begin: y, end: E, contains: [] }, D);
				j.contains.push({
					scope: "doctag",
					begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
					end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
					excludeBegin: !0,
					relevance: 0,
				});
				const Ne = O(
					"I",
					"a",
					"is",
					"so",
					"us",
					"to",
					"at",
					"if",
					"in",
					"it",
					"on",
					/[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
					/[A-Za-z]+[-][a-z]+/,
					/[A-Za-z][a-z]{2,}/
				);
				return j.contains.push({ begin: S(/[ ]+/, "(", Ne, /[.]?[:]?([.][ ]|[ ])/, "){3}") }), j;
			},
			De = ie("//", "$"),
			Te = ie("/\\*", "\\*/"),
			Ce = ie("#", "$"),
			Me = { scope: "number", begin: te, relevance: 0 },
			Je = { scope: "number", begin: Pe, relevance: 0 },
			vr = { scope: "number", begin: Ee, relevance: 0 },
			Rt = {
				scope: "regexp",
				begin: /\/(?=[^/\n]*\/)/,
				end: /\/[gimuy]*/,
				contains: [we, { begin: /\[/, end: /\]/, relevance: 0, contains: [we] }],
			},
			r0 = { scope: "title", begin: Q, relevance: 0 },
			It = { scope: "title", begin: ne, relevance: 0 },
			Dt = { begin: "\\.\\s*" + ne, relevance: 0 };
		var St = Object.freeze({
			__proto__: null,
			APOS_STRING_MODE: $e,
			BACKSLASH_ESCAPE: we,
			BINARY_NUMBER_MODE: vr,
			BINARY_NUMBER_RE: Ee,
			COMMENT: ie,
			C_BLOCK_COMMENT_MODE: Te,
			C_LINE_COMMENT_MODE: De,
			C_NUMBER_MODE: Je,
			C_NUMBER_RE: Pe,
			END_SAME_AS_BEGIN: function (y) {
				return Object.assign(y, {
					"on:begin": (E, D) => {
						D.data._beginMatch = E[1];
					},
					"on:end": (E, D) => {
						D.data._beginMatch !== E[1] && D.ignoreMatch();
					},
				});
			},
			HASH_COMMENT_MODE: Ce,
			IDENT_RE: Q,
			MATCH_NOTHING_RE: U,
			METHOD_GUARD: Dt,
			NUMBER_MODE: Me,
			NUMBER_RE: te,
			PHRASAL_WORDS_MODE: nt,
			QUOTE_STRING_MODE: Fe,
			REGEXP_MODE: Rt,
			RE_STARTERS_RE: ve,
			SHEBANG: Qe,
			TITLE_MODE: r0,
			UNDERSCORE_IDENT_RE: ne,
			UNDERSCORE_TITLE_MODE: It,
		});
		function mn(y, E) {
			y.input[y.index - 1] === "." && E.ignoreMatch();
		}
		function pn(y, E) {
			y.className !== void 0 && ((y.scope = y.className), delete y.className);
		}
		function fn(y, E) {
			E &&
				y.beginKeywords &&
				((y.begin = "\\b(" + y.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)"),
				(y.__beforeBegin = mn),
				(y.keywords = y.keywords || y.beginKeywords),
				delete y.beginKeywords,
				y.relevance === void 0 && (y.relevance = 0));
		}
		function xr(y, E) {
			Array.isArray(y.illegal) && (y.illegal = O(...y.illegal));
		}
		function n0(y, E) {
			if (y.match) {
				if (y.begin || y.end) throw new Error("begin & end are not supported with match");
				(y.begin = y.match), delete y.match;
			}
		}
		function a0(y, E) {
			y.relevance === void 0 && (y.relevance = 1);
		}
		const wr = (y, E) => {
				if (!y.beforeMatch) return;
				if (y.starts) throw new Error("beforeMatch cannot be used with starts");
				const D = Object.assign({}, y);
				Object.keys(y).forEach((j) => {
					delete y[j];
				}),
					(y.keywords = D.keywords),
					(y.begin = S(D.beforeMatch, v(D.begin))),
					(y.starts = { relevance: 0, contains: [Object.assign(D, { endsParent: !0 })] }),
					(y.relevance = 0),
					delete D.beforeMatch;
			},
			Jt = ["of", "and", "for", "in", "not", "or", "if", "then", "parent", "list", "value"],
			jt = "keyword";
		function Bi(y, E, D = jt) {
			const j = Object.create(null);
			return (
				typeof y == "string"
					? Ne(D, y.split(" "))
					: Array.isArray(y)
						? Ne(D, y)
						: Object.keys(y).forEach(function (Oe) {
								Object.assign(j, Bi(y[Oe], E, Oe));
							}),
				j
			);
			function Ne(Oe, G) {
				E && (G = G.map((H) => H.toLowerCase())),
					G.forEach(function (H) {
						const J = H.split("|");
						j[J[0]] = [Oe, n1(J[0], J[1])];
					});
			}
		}
		function n1(y, E) {
			return E ? Number(E) : a1(y) ? 0 : 1;
		}
		function a1(y) {
			return Jt.includes(y.toLowerCase());
		}
		const Li = {},
			Gt = (y) => {
				console.error(y);
			},
			$i = (y, ...E) => {
				console.log(`WARN: ${y}`, ...E);
			},
			er = (y, E) => {
				Li[`${y}/${E}`] || (console.log(`Deprecated as of ${y}. ${E}`), (Li[`${y}/${E}`] = !0));
			},
			i0 = new Error();
		function qi(y, E, { key: D }) {
			let j = 0;
			const Ne = y[D],
				Oe = {},
				G = {};
			for (let H = 1; H <= E.length; H++) (G[H + j] = Ne[H]), (Oe[H + j] = !0), (j += I(E[H - 1]));
			(y[D] = G), (y[D]._emit = Oe), (y[D]._multi = !0);
		}
		function i1(y) {
			if (Array.isArray(y.begin)) {
				if (y.skip || y.excludeBegin || y.returnBegin)
					throw (Gt("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), i0);
				if (typeof y.beginScope != "object" || y.beginScope === null)
					throw (Gt("beginScope must be object"), i0);
				qi(y, y.begin, { key: "beginScope" }), (y.begin = q(y.begin, { joinWith: "" }));
			}
		}
		function s1(y) {
			if (Array.isArray(y.end)) {
				if (y.skip || y.excludeEnd || y.returnEnd)
					throw (Gt("skip, excludeEnd, returnEnd not compatible with endScope: {}"), i0);
				if (typeof y.endScope != "object" || y.endScope === null)
					throw (Gt("endScope must be object"), i0);
				qi(y, y.end, { key: "endScope" }), (y.end = q(y.end, { joinWith: "" }));
			}
		}
		function o1(y) {
			y.scope &&
				typeof y.scope == "object" &&
				y.scope !== null &&
				((y.beginScope = y.scope), delete y.scope);
		}
		function l1(y) {
			o1(y),
				typeof y.beginScope == "string" && (y.beginScope = { _wrap: y.beginScope }),
				typeof y.endScope == "string" && (y.endScope = { _wrap: y.endScope }),
				i1(y),
				s1(y);
		}
		function c1(y) {
			function E(G, H) {
				return new RegExp(
					f(G),
					"m" + (y.case_insensitive ? "i" : "") + (y.unicodeRegex ? "u" : "") + (H ? "g" : "")
				);
			}
			class D {
				constructor() {
					(this.matchIndexes = {}), (this.regexes = []), (this.matchAt = 1), (this.position = 0);
				}
				addRule(H, J) {
					(J.position = this.position++),
						(this.matchIndexes[this.matchAt] = J),
						this.regexes.push([J, H]),
						(this.matchAt += I(H) + 1);
				}
				compile() {
					this.regexes.length === 0 && (this.exec = () => null);
					const H = this.regexes.map((J) => J[1]);
					(this.matcherRe = E(q(H, { joinWith: "|" }), !0)), (this.lastIndex = 0);
				}
				exec(H) {
					this.matcherRe.lastIndex = this.lastIndex;
					const J = this.matcherRe.exec(H);
					if (!J) return null;
					const Le = J.findIndex((kr, bn) => bn > 0 && kr !== void 0),
						Re = this.matchIndexes[Le];
					return J.splice(0, Le), Object.assign(J, Re);
				}
			}
			class j {
				constructor() {
					(this.rules = []),
						(this.multiRegexes = []),
						(this.count = 0),
						(this.lastIndex = 0),
						(this.regexIndex = 0);
				}
				getMatcher(H) {
					if (this.multiRegexes[H]) return this.multiRegexes[H];
					const J = new D();
					return (
						this.rules.slice(H).forEach(([Le, Re]) => J.addRule(Le, Re)),
						J.compile(),
						(this.multiRegexes[H] = J),
						J
					);
				}
				resumingScanAtSamePosition() {
					return this.regexIndex !== 0;
				}
				considerAll() {
					this.regexIndex = 0;
				}
				addRule(H, J) {
					this.rules.push([H, J]), J.type === "begin" && this.count++;
				}
				exec(H) {
					const J = this.getMatcher(this.regexIndex);
					J.lastIndex = this.lastIndex;
					let Le = J.exec(H);
					if (this.resumingScanAtSamePosition() && !(Le && Le.index === this.lastIndex)) {
						const Re = this.getMatcher(0);
						(Re.lastIndex = this.lastIndex + 1), (Le = Re.exec(H));
					}
					return (
						Le &&
							((this.regexIndex += Le.position + 1),
							this.regexIndex === this.count && this.considerAll()),
						Le
					);
				}
			}
			function Ne(G) {
				const H = new j();
				return (
					G.contains.forEach((J) => H.addRule(J.begin, { rule: J, type: "begin" })),
					G.terminatorEnd && H.addRule(G.terminatorEnd, { type: "end" }),
					G.illegal && H.addRule(G.illegal, { type: "illegal" }),
					H
				);
			}
			function Oe(G, H) {
				const J = G;
				if (G.isCompiled) return J;
				[pn, n0, l1, wr].forEach((Re) => Re(G, H)),
					y.compilerExtensions.forEach((Re) => Re(G, H)),
					(G.__beforeBegin = null),
					[fn, xr, a0].forEach((Re) => Re(G, H)),
					(G.isCompiled = !0);
				let Le = null;
				return (
					typeof G.keywords == "object" &&
						G.keywords.$pattern &&
						((G.keywords = Object.assign({}, G.keywords)),
						(Le = G.keywords.$pattern),
						delete G.keywords.$pattern),
					(Le = Le || /\w+/),
					G.keywords && (G.keywords = Bi(G.keywords, y.case_insensitive)),
					(J.keywordPatternRe = E(Le, !0)),
					H &&
						(G.begin || (G.begin = /\B|\b/),
						(J.beginRe = E(J.begin)),
						!G.end && !G.endsWithParent && (G.end = /\B|\b/),
						G.end && (J.endRe = E(J.end)),
						(J.terminatorEnd = f(J.end) || ""),
						G.endsWithParent &&
							H.terminatorEnd &&
							(J.terminatorEnd += (G.end ? "|" : "") + H.terminatorEnd)),
					G.illegal && (J.illegalRe = E(G.illegal)),
					G.contains || (G.contains = []),
					(G.contains = [].concat(
						...G.contains.map(function (Re) {
							return u1(Re === "self" ? G : Re);
						})
					)),
					G.contains.forEach(function (Re) {
						Oe(Re, J);
					}),
					G.starts && Oe(G.starts, H),
					(J.matcher = Ne(J)),
					J
				);
			}
			if (
				(y.compilerExtensions || (y.compilerExtensions = []),
				y.contains && y.contains.includes("self"))
			)
				throw new Error(
					"ERR: contains `self` is not supported at the top-level of a language.  See documentation."
				);
			return (y.classNameAliases = n(y.classNameAliases || {})), Oe(y);
		}
		function Pi(y) {
			return y ? y.endsWithParent || Pi(y.starts) : !1;
		}
		function u1(y) {
			return (
				y.variants &&
					!y.cachedVariants &&
					(y.cachedVariants = y.variants.map(function (E) {
						return n(y, { variants: null }, E);
					})),
				y.cachedVariants
					? y.cachedVariants
					: Pi(y)
						? n(y, { starts: y.starts ? n(y.starts) : null })
						: Object.isFrozen(y)
							? n(y)
							: y
			);
		}
		var h1 = "11.11.1";
		class d1 extends Error {
			constructor(E, D) {
				super(E), (this.name = "HTMLInjectionError"), (this.html = D);
			}
		}
		const gn = t,
			Fi = n,
			Hi = Symbol("nomatch"),
			m1 = 7,
			Ui = function (y) {
				const E = Object.create(null),
					D = Object.create(null),
					j = [];
				let Ne = !0;
				const Oe =
						"Could not find the language '{}', did you forget to load/include a language module?",
					G = { disableAutodetect: !0, name: "Plain text", contains: [] };
				let H = {
					ignoreUnescapedHTML: !1,
					throwUnescapedHTML: !1,
					noHighlightRe: /^(no-?highlight)$/i,
					languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
					classPrefix: "hljs-",
					cssSelector: "pre code",
					languages: null,
					__emitter: p,
				};
				function J(C) {
					return H.noHighlightRe.test(C);
				}
				function Le(C) {
					let W = C.className + " ";
					W += C.parentNode ? C.parentNode.className : "";
					const se = H.languageDetectRe.exec(W);
					if (se) {
						const ge = Bt(se[1]);
						return (
							ge ||
								($i(Oe.replace("{}", se[1])),
								$i("Falling back to no-highlight mode for this block.", C)),
							ge ? se[1] : "no-highlight"
						);
					}
					return W.split(/\s+/).find((ge) => J(ge) || Bt(ge));
				}
				function Re(C, W, se) {
					let ge = "",
						Be = "";
					typeof W == "object"
						? ((ge = C), (se = W.ignoreIllegals), (Be = W.language))
						: (er("10.7.0", "highlight(lang, code, ...args) has been deprecated."),
							er(
								"10.7.0",
								`Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`
							),
							(Be = C),
							(ge = W)),
						se === void 0 && (se = !0);
					const st = { code: ge, language: Be };
					o0("before:highlight", st);
					const Lt = st.result ? st.result : kr(st.language, st.code, se);
					return (Lt.code = st.code), o0("after:highlight", Lt), Lt;
				}
				function kr(C, W, se, ge) {
					const Be = Object.create(null);
					function st(L, K) {
						return L.keywords[K];
					}
					function Lt() {
						if (!ee.keywords) {
							qe.addText(be);
							return;
						}
						let L = 0;
						ee.keywordPatternRe.lastIndex = 0;
						let K = ee.keywordPatternRe.exec(be),
							ae = "";
						for (; K; ) {
							ae += be.substring(L, K.index);
							const ue = ft.case_insensitive ? K[0].toLowerCase() : K[0],
								He = st(ee, ue);
							if (He) {
								const [Et, O1] = He;
								if (
									(qe.addText(ae),
									(ae = ""),
									(Be[ue] = (Be[ue] || 0) + 1),
									Be[ue] <= m1 && (u0 += O1),
									Et.startsWith("_"))
								)
									ae += K[0];
								else {
									const z1 = ft.classNameAliases[Et] || Et;
									pt(K[0], z1);
								}
							} else ae += K[0];
							(L = ee.keywordPatternRe.lastIndex), (K = ee.keywordPatternRe.exec(be));
						}
						(ae += be.substring(L)), qe.addText(ae);
					}
					function l0() {
						if (be === "") return;
						let L = null;
						if (typeof ee.subLanguage == "string") {
							if (!E[ee.subLanguage]) {
								qe.addText(be);
								return;
							}
							(L = kr(ee.subLanguage, be, !0, Qi[ee.subLanguage])), (Qi[ee.subLanguage] = L._top);
						} else L = vn(be, ee.subLanguage.length ? ee.subLanguage : null);
						ee.relevance > 0 && (u0 += L.relevance), qe.__addSublanguage(L._emitter, L.language);
					}
					function je() {
						ee.subLanguage != null ? l0() : Lt(), (be = "");
					}
					function pt(L, K) {
						L !== "" && (qe.startScope(K), qe.addText(L), qe.endScope());
					}
					function Wi(L, K) {
						let ae = 1;
						const ue = K.length - 1;
						for (; ae <= ue; ) {
							if (!L._emit[ae]) {
								ae++;
								continue;
							}
							const He = ft.classNameAliases[L[ae]] || L[ae],
								Et = K[ae];
							He ? pt(Et, He) : ((be = Et), Lt(), (be = "")), ae++;
						}
					}
					function Zi(L, K) {
						return (
							L.scope &&
								typeof L.scope == "string" &&
								qe.openNode(ft.classNameAliases[L.scope] || L.scope),
							L.beginScope &&
								(L.beginScope._wrap
									? (pt(be, ft.classNameAliases[L.beginScope._wrap] || L.beginScope._wrap),
										(be = ""))
									: L.beginScope._multi && (Wi(L.beginScope, K), (be = ""))),
							(ee = Object.create(L, { parent: { value: ee } })),
							ee
						);
					}
					function Xi(L, K, ae) {
						let ue = $(L.endRe, ae);
						if (ue) {
							if (L["on:end"]) {
								const He = new e(L);
								L["on:end"](K, He), He.isMatchIgnored && (ue = !1);
							}
							if (ue) {
								for (; L.endsParent && L.parent; ) L = L.parent;
								return L;
							}
						}
						if (L.endsWithParent) return Xi(L.parent, K, ae);
					}
					function E1(L) {
						return ee.matcher.regexIndex === 0 ? ((be += L[0]), 1) : ((kn = !0), 0);
					}
					function T1(L) {
						const K = L[0],
							ae = L.rule,
							ue = new e(ae),
							He = [ae.__beforeBegin, ae["on:begin"]];
						for (const Et of He) if (Et && (Et(L, ue), ue.isMatchIgnored)) return E1(K);
						return (
							ae.skip
								? (be += K)
								: (ae.excludeBegin && (be += K),
									je(),
									!ae.returnBegin && !ae.excludeBegin && (be = K)),
							Zi(ae, L),
							ae.returnBegin ? 0 : K.length
						);
					}
					function M1(L) {
						const K = L[0],
							ae = W.substring(L.index),
							ue = Xi(ee, L, ae);
						if (!ue) return Hi;
						const He = ee;
						ee.endScope && ee.endScope._wrap
							? (je(), pt(K, ee.endScope._wrap))
							: ee.endScope && ee.endScope._multi
								? (je(), Wi(ee.endScope, L))
								: He.skip
									? (be += K)
									: (He.returnEnd || He.excludeEnd || (be += K), je(), He.excludeEnd && (be = K));
						do
							ee.scope && qe.closeNode(),
								!ee.skip && !ee.subLanguage && (u0 += ee.relevance),
								(ee = ee.parent);
						while (ee !== ue.parent);
						return ue.starts && Zi(ue.starts, L), He.returnEnd ? 0 : K.length;
					}
					function A1() {
						const L = [];
						for (let K = ee; K !== ft; K = K.parent) K.scope && L.unshift(K.scope);
						L.forEach((K) => qe.openNode(K));
					}
					let c0 = {};
					function Yi(L, K) {
						const ae = K && K[0];
						if (((be += L), ae == null)) return je(), 0;
						if (c0.type === "begin" && K.type === "end" && c0.index === K.index && ae === "") {
							if (((be += W.slice(K.index, K.index + 1)), !Ne)) {
								const ue = new Error(`0 width match regex (${C})`);
								throw ((ue.languageName = C), (ue.badRule = c0.rule), ue);
							}
							return 1;
						}
						if (((c0 = K), K.type === "begin")) return T1(K);
						if (K.type === "illegal" && !se) {
							const ue = new Error(
								'Illegal lexeme "' + ae + '" for mode "' + (ee.scope || "<unnamed>") + '"'
							);
							throw ((ue.mode = ee), ue);
						} else if (K.type === "end") {
							const ue = M1(K);
							if (ue !== Hi) return ue;
						}
						if (K.type === "illegal" && ae === "")
							return (
								(be += `
`),
								1
							);
						if (wn > 1e5 && wn > K.index * 3)
							throw new Error("potential infinite loop, way more iterations than matches");
						return (be += ae), ae.length;
					}
					const ft = Bt(C);
					if (!ft) throw (Gt(Oe.replace("{}", C)), new Error('Unknown language: "' + C + '"'));
					const N1 = c1(ft);
					let xn = "",
						ee = ge || N1;
					const Qi = {},
						qe = new H.__emitter(H);
					A1();
					let be = "",
						u0 = 0,
						Kt = 0,
						wn = 0,
						kn = !1;
					try {
						if (ft.__emitTokens) ft.__emitTokens(W, qe);
						else {
							for (ee.matcher.considerAll(); ; ) {
								wn++, kn ? (kn = !1) : ee.matcher.considerAll(), (ee.matcher.lastIndex = Kt);
								const L = ee.matcher.exec(W);
								if (!L) break;
								const K = W.substring(Kt, L.index),
									ae = Yi(K, L);
								Kt = L.index + ae;
							}
							Yi(W.substring(Kt));
						}
						return (
							qe.finalize(),
							(xn = qe.toHTML()),
							{ language: C, value: xn, relevance: u0, illegal: !1, _emitter: qe, _top: ee }
						);
					} catch (L) {
						if (L.message && L.message.includes("Illegal"))
							return {
								language: C,
								value: gn(W),
								illegal: !0,
								relevance: 0,
								_illegalBy: {
									message: L.message,
									index: Kt,
									context: W.slice(Kt - 100, Kt + 100),
									mode: L.mode,
									resultSoFar: xn,
								},
								_emitter: qe,
							};
						if (Ne)
							return {
								language: C,
								value: gn(W),
								illegal: !1,
								relevance: 0,
								errorRaised: L,
								_emitter: qe,
								_top: ee,
							};
						throw L;
					}
				}
				function bn(C) {
					const W = {
						value: gn(C),
						illegal: !1,
						relevance: 0,
						_top: G,
						_emitter: new H.__emitter(H),
					};
					return W._emitter.addText(C), W;
				}
				function vn(C, W) {
					W = W || H.languages || Object.keys(E);
					const se = bn(C),
						ge = W.filter(Bt)
							.filter(Vi)
							.map((je) => kr(je, C, !1));
					ge.unshift(se);
					const Be = ge.sort((je, pt) => {
							if (je.relevance !== pt.relevance) return pt.relevance - je.relevance;
							if (je.language && pt.language) {
								if (Bt(je.language).supersetOf === pt.language) return 1;
								if (Bt(pt.language).supersetOf === je.language) return -1;
							}
							return 0;
						}),
						[st, Lt] = Be,
						l0 = st;
					return (l0.secondBest = Lt), l0;
				}
				function p1(C, W, se) {
					const ge = (W && D[W]) || se;
					C.classList.add("hljs"), C.classList.add(`language-${ge}`);
				}
				function yn(C) {
					let W = null;
					const se = Le(C);
					if (J(se)) return;
					if ((o0("before:highlightElement", { el: C, language: se }), C.dataset.highlighted)) {
						console.log(
							"Element previously highlighted. To highlight again, first unset `dataset.highlighted`.",
							C
						);
						return;
					}
					if (
						C.children.length > 0 &&
						(H.ignoreUnescapedHTML ||
							(console.warn(
								"One of your code blocks includes unescaped HTML. This is a potentially serious security risk."
							),
							console.warn("https://github.com/highlightjs/highlight.js/wiki/security"),
							console.warn("The element with unescaped HTML:"),
							console.warn(C)),
						H.throwUnescapedHTML)
					)
						throw new d1("One of your code blocks includes unescaped HTML.", C.innerHTML);
					W = C;
					const ge = W.textContent,
						Be = se ? Re(ge, { language: se, ignoreIllegals: !0 }) : vn(ge);
					(C.innerHTML = Be.value),
						(C.dataset.highlighted = "yes"),
						p1(C, se, Be.language),
						(C.result = { language: Be.language, re: Be.relevance, relevance: Be.relevance }),
						Be.secondBest &&
							(C.secondBest = {
								language: Be.secondBest.language,
								relevance: Be.secondBest.relevance,
							}),
						o0("after:highlightElement", { el: C, result: Be, text: ge });
				}
				function f1(C) {
					H = Fi(H, C);
				}
				const g1 = () => {
					s0(), er("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
				};
				function b1() {
					s0(), er("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
				}
				let Gi = !1;
				function s0() {
					function C() {
						s0();
					}
					if (document.readyState === "loading") {
						Gi || window.addEventListener("DOMContentLoaded", C, !1), (Gi = !0);
						return;
					}
					document.querySelectorAll(H.cssSelector).forEach(yn);
				}
				function v1(C, W) {
					let se = null;
					try {
						se = W(y);
					} catch (ge) {
						if ((Gt("Language definition for '{}' could not be registered.".replace("{}", C)), Ne))
							Gt(ge);
						else throw ge;
						se = G;
					}
					se.name || (se.name = C),
						(E[C] = se),
						(se.rawDefinition = W.bind(null, y)),
						se.aliases && Ki(se.aliases, { languageName: C });
				}
				function y1(C) {
					delete E[C];
					for (const W of Object.keys(D)) D[W] === C && delete D[W];
				}
				function x1() {
					return Object.keys(E);
				}
				function Bt(C) {
					return (C = (C || "").toLowerCase()), E[C] || E[D[C]];
				}
				function Ki(C, { languageName: W }) {
					typeof C == "string" && (C = [C]),
						C.forEach((se) => {
							D[se.toLowerCase()] = W;
						});
				}
				function Vi(C) {
					const W = Bt(C);
					return W && !W.disableAutodetect;
				}
				function w1(C) {
					C["before:highlightBlock"] &&
						!C["before:highlightElement"] &&
						(C["before:highlightElement"] = (W) => {
							C["before:highlightBlock"](Object.assign({ block: W.el }, W));
						}),
						C["after:highlightBlock"] &&
							!C["after:highlightElement"] &&
							(C["after:highlightElement"] = (W) => {
								C["after:highlightBlock"](Object.assign({ block: W.el }, W));
							});
				}
				function k1(C) {
					w1(C), j.push(C);
				}
				function _1(C) {
					const W = j.indexOf(C);
					W !== -1 && j.splice(W, 1);
				}
				function o0(C, W) {
					const se = C;
					j.forEach(function (ge) {
						ge[se] && ge[se](W);
					});
				}
				function S1(C) {
					return (
						er("10.7.0", "highlightBlock will be removed entirely in v12.0"),
						er("10.7.0", "Please use highlightElement now."),
						yn(C)
					);
				}
				Object.assign(y, {
					highlight: Re,
					highlightAuto: vn,
					highlightAll: s0,
					highlightElement: yn,
					highlightBlock: S1,
					configure: f1,
					initHighlighting: g1,
					initHighlightingOnLoad: b1,
					registerLanguage: v1,
					unregisterLanguage: y1,
					listLanguages: x1,
					getLanguage: Bt,
					registerAliases: Ki,
					autoDetection: Vi,
					inherit: Fi,
					addPlugin: k1,
					removePlugin: _1,
				}),
					(y.debugMode = function () {
						Ne = !1;
					}),
					(y.safeMode = function () {
						Ne = !0;
					}),
					(y.versionString = h1),
					(y.regex = { concat: S, lookahead: v, either: O, optional: _, anyNumberOfTimes: x });
				for (const C in St) typeof St[C] == "object" && r(St[C]);
				return Object.assign(y, St), y;
			},
			tr = Ui({});
		return (tr.newInstance = () => Ui({})), (hn = tr), (tr.HighlightJS = tr), (tr.default = tr), hn;
	}
	var Ll = Bl(),
		Jr = Dl(Ll);
	const bi = "[A-Za-z$_][0-9A-Za-z$_]*",
		$l = [
			"as",
			"in",
			"of",
			"if",
			"for",
			"while",
			"finally",
			"var",
			"new",
			"function",
			"do",
			"return",
			"void",
			"else",
			"break",
			"catch",
			"instanceof",
			"with",
			"throw",
			"case",
			"default",
			"try",
			"switch",
			"continue",
			"typeof",
			"delete",
			"let",
			"yield",
			"const",
			"class",
			"debugger",
			"async",
			"await",
			"static",
			"import",
			"from",
			"export",
			"extends",
			"using",
		],
		ql = ["true", "false", "null", "undefined", "NaN", "Infinity"],
		vi = [
			"Object",
			"Function",
			"Boolean",
			"Symbol",
			"Math",
			"Date",
			"Number",
			"BigInt",
			"String",
			"RegExp",
			"Array",
			"Float32Array",
			"Float64Array",
			"Int8Array",
			"Uint8Array",
			"Uint8ClampedArray",
			"Int16Array",
			"Int32Array",
			"Uint16Array",
			"Uint32Array",
			"BigInt64Array",
			"BigUint64Array",
			"Set",
			"Map",
			"WeakSet",
			"WeakMap",
			"ArrayBuffer",
			"SharedArrayBuffer",
			"Atomics",
			"DataView",
			"JSON",
			"Promise",
			"Generator",
			"GeneratorFunction",
			"AsyncFunction",
			"Reflect",
			"Proxy",
			"Intl",
			"WebAssembly",
		],
		yi = [
			"Error",
			"EvalError",
			"InternalError",
			"RangeError",
			"ReferenceError",
			"SyntaxError",
			"TypeError",
			"URIError",
		],
		xi = [
			"setInterval",
			"setTimeout",
			"clearInterval",
			"clearTimeout",
			"require",
			"exports",
			"eval",
			"isFinite",
			"isNaN",
			"parseFloat",
			"parseInt",
			"decodeURI",
			"decodeURIComponent",
			"encodeURI",
			"encodeURIComponent",
			"escape",
			"unescape",
		],
		Pl = [
			"arguments",
			"this",
			"super",
			"console",
			"window",
			"document",
			"localStorage",
			"sessionStorage",
			"module",
			"global",
		],
		Fl = [].concat(xi, vi, yi);
	function Hl(r) {
		const e = r.regex,
			t = (ie, { after: De }) => {
				const Te = "</" + ie[0].slice(1);
				return ie.input.indexOf(Te, De) !== -1;
			},
			n = bi,
			a = { begin: "<>", end: "</>" },
			i = /<[A-Za-z0-9\\._:-]+\s*\/>/,
			s = {
				begin: /<[A-Za-z0-9\\._:-]+/,
				end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
				isTrulyOpeningTag: (ie, De) => {
					const Te = ie[0].length + ie.index,
						Ce = ie.input[Te];
					if (Ce === "<" || Ce === ",") {
						De.ignoreMatch();
						return;
					}
					Ce === ">" && (t(ie, { after: Te }) || De.ignoreMatch());
					let Me;
					const Je = ie.input.substring(Te);
					if ((Me = Je.match(/^\s*=/))) {
						De.ignoreMatch();
						return;
					}
					if ((Me = Je.match(/^\s+extends\s+/)) && Me.index === 0) {
						De.ignoreMatch();
						return;
					}
				},
			},
			l = { $pattern: bi, keyword: $l, literal: ql, built_in: Fl, "variable.language": Pl },
			u = "[0-9](_?[0-9])*",
			d = `\\.(${u})`,
			p = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*",
			f = {
				className: "number",
				variants: [
					{ begin: `(\\b(${p})((${d})|\\.)?|(${d}))[eE][+-]?(${u})\\b` },
					{ begin: `\\b(${p})\\b((${d})\\b|\\.)?|(${d})\\b` },
					{ begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
					{ begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
					{ begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
					{ begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
					{ begin: "\\b0[0-7]+n?\\b" },
				],
				relevance: 0,
			},
			v = { className: "subst", begin: "\\$\\{", end: "\\}", keywords: l, contains: [] },
			x = {
				begin: ".?html`",
				end: "",
				starts: { end: "`", returnEnd: !1, contains: [r.BACKSLASH_ESCAPE, v], subLanguage: "xml" },
			},
			_ = {
				begin: ".?css`",
				end: "",
				starts: { end: "`", returnEnd: !1, contains: [r.BACKSLASH_ESCAPE, v], subLanguage: "css" },
			},
			S = {
				begin: ".?gql`",
				end: "",
				starts: {
					end: "`",
					returnEnd: !1,
					contains: [r.BACKSLASH_ESCAPE, v],
					subLanguage: "graphql",
				},
			},
			M = { className: "string", begin: "`", end: "`", contains: [r.BACKSLASH_ESCAPE, v] },
			I = {
				className: "comment",
				variants: [
					r.COMMENT(/\/\*\*(?!\/)/, "\\*/", {
						relevance: 0,
						contains: [
							{
								begin: "(?=@[A-Za-z]+)",
								relevance: 0,
								contains: [
									{ className: "doctag", begin: "@[A-Za-z]+" },
									{
										className: "type",
										begin: "\\{",
										end: "\\}",
										excludeEnd: !0,
										excludeBegin: !0,
										relevance: 0,
									},
									{
										className: "variable",
										begin: n + "(?=\\s*(-)|$)",
										endsParent: !0,
										relevance: 0,
									},
									{ begin: /(?=[^\n])\s/, relevance: 0 },
								],
							},
						],
					}),
					r.C_BLOCK_COMMENT_MODE,
					r.C_LINE_COMMENT_MODE,
				],
			},
			$ = [r.APOS_STRING_MODE, r.QUOTE_STRING_MODE, x, _, S, M, { match: /\$\d+/ }, f];
		v.contains = $.concat({ begin: /\{/, end: /\}/, keywords: l, contains: ["self"].concat($) });
		const P = [].concat(I, v.contains),
			q = P.concat([{ begin: /(\s*)\(/, end: /\)/, keywords: l, contains: ["self"].concat(P) }]),
			U = {
				className: "params",
				begin: /(\s*)\(/,
				end: /\)/,
				excludeBegin: !0,
				excludeEnd: !0,
				keywords: l,
				contains: q,
			},
			Q = {
				variants: [
					{
						match: [
							/class/,
							/\s+/,
							n,
							/\s+/,
							/extends/,
							/\s+/,
							e.concat(n, "(", e.concat(/\./, n), ")*"),
						],
						scope: { 1: "keyword", 3: "title.class", 5: "keyword", 7: "title.class.inherited" },
					},
					{ match: [/class/, /\s+/, n], scope: { 1: "keyword", 3: "title.class" } },
				],
			},
			ne = {
				relevance: 0,
				match: e.either(
					/\bJSON/,
					/\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
					/\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
					/\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
				),
				className: "title.class",
				keywords: { _: [...vi, ...yi] },
			},
			te = {
				label: "use_strict",
				className: "meta",
				relevance: 10,
				begin: /^\s*['"]use (strict|asm)['"]/,
			},
			Pe = {
				variants: [
					{ match: [/function/, /\s+/, n, /(?=\s*\()/] },
					{ match: [/function/, /\s*(?=\()/] },
				],
				className: { 1: "keyword", 3: "title.function" },
				label: "func.def",
				contains: [U],
				illegal: /%/,
			},
			Ee = { relevance: 0, match: /\b[A-Z][A-Z_0-9]+\b/, className: "variable.constant" };
		function ve(ie) {
			return e.concat("(?!", ie.join("|"), ")");
		}
		const Qe = {
				match: e.concat(
					/\b/,
					ve([...xi, "super", "import"].map((ie) => `${ie}\\s*\\(`)),
					n,
					e.lookahead(/\s*\(/)
				),
				className: "title.function",
				relevance: 0,
			},
			we = {
				begin: e.concat(/\./, e.lookahead(e.concat(n, /(?![0-9A-Za-z$_(])/))),
				end: n,
				excludeBegin: !0,
				keywords: "prototype",
				className: "property",
				relevance: 0,
			},
			$e = {
				match: [/get|set/, /\s+/, n, /(?=\()/],
				className: { 1: "keyword", 3: "title.function" },
				contains: [{ begin: /\(\)/ }, U],
			},
			Fe =
				"(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" +
				r.UNDERSCORE_IDENT_RE +
				")\\s*=>",
			nt = {
				match: [/const|var|let/, /\s+/, n, /\s*/, /=\s*/, /(async\s*)?/, e.lookahead(Fe)],
				keywords: "async",
				className: { 1: "keyword", 3: "title.function" },
				contains: [U],
			};
		return {
			name: "JavaScript",
			aliases: ["js", "jsx", "mjs", "cjs"],
			keywords: l,
			exports: { PARAMS_CONTAINS: q, CLASS_REFERENCE: ne },
			illegal: /#(?![$_A-z])/,
			contains: [
				r.SHEBANG({ label: "shebang", binary: "node", relevance: 5 }),
				te,
				r.APOS_STRING_MODE,
				r.QUOTE_STRING_MODE,
				x,
				_,
				S,
				M,
				I,
				{ match: /\$\d+/ },
				f,
				ne,
				{ scope: "attr", match: n + e.lookahead(":"), relevance: 0 },
				nt,
				{
					begin: "(" + r.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
					keywords: "return throw case",
					relevance: 0,
					contains: [
						I,
						r.REGEXP_MODE,
						{
							className: "function",
							begin: Fe,
							returnBegin: !0,
							end: "\\s*=>",
							contains: [
								{
									className: "params",
									variants: [
										{ begin: r.UNDERSCORE_IDENT_RE, relevance: 0 },
										{ className: null, begin: /\(\s*\)/, skip: !0 },
										{
											begin: /(\s*)\(/,
											end: /\)/,
											excludeBegin: !0,
											excludeEnd: !0,
											keywords: l,
											contains: q,
										},
									],
								},
							],
						},
						{ begin: /,/, relevance: 0 },
						{ match: /\s+/, relevance: 0 },
						{
							variants: [
								{ begin: a.begin, end: a.end },
								{ match: i },
								{ begin: s.begin, "on:begin": s.isTrulyOpeningTag, end: s.end },
							],
							subLanguage: "xml",
							contains: [{ begin: s.begin, end: s.end, skip: !0, contains: ["self"] }],
						},
					],
				},
				Pe,
				{ beginKeywords: "while if switch catch for" },
				{
					begin:
						"\\b(?!function)" +
						r.UNDERSCORE_IDENT_RE +
						"\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
					returnBegin: !0,
					label: "func.def",
					contains: [U, r.inherit(r.TITLE_MODE, { begin: n, className: "title.function" })],
				},
				{ match: /\.\.\./, relevance: 0 },
				we,
				{ match: "\\$" + n, relevance: 0 },
				{ match: [/\bconstructor(?=\s*\()/], className: { 1: "title.function" }, contains: [U] },
				Qe,
				Ee,
				Q,
				$e,
				{ match: /\$[(.]/ },
			],
		};
	}
	const jr = "[A-Za-z$_][0-9A-Za-z$_]*",
		wi = [
			"as",
			"in",
			"of",
			"if",
			"for",
			"while",
			"finally",
			"var",
			"new",
			"function",
			"do",
			"return",
			"void",
			"else",
			"break",
			"catch",
			"instanceof",
			"with",
			"throw",
			"case",
			"default",
			"try",
			"switch",
			"continue",
			"typeof",
			"delete",
			"let",
			"yield",
			"const",
			"class",
			"debugger",
			"async",
			"await",
			"static",
			"import",
			"from",
			"export",
			"extends",
			"using",
		],
		ki = ["true", "false", "null", "undefined", "NaN", "Infinity"],
		_i = [
			"Object",
			"Function",
			"Boolean",
			"Symbol",
			"Math",
			"Date",
			"Number",
			"BigInt",
			"String",
			"RegExp",
			"Array",
			"Float32Array",
			"Float64Array",
			"Int8Array",
			"Uint8Array",
			"Uint8ClampedArray",
			"Int16Array",
			"Int32Array",
			"Uint16Array",
			"Uint32Array",
			"BigInt64Array",
			"BigUint64Array",
			"Set",
			"Map",
			"WeakSet",
			"WeakMap",
			"ArrayBuffer",
			"SharedArrayBuffer",
			"Atomics",
			"DataView",
			"JSON",
			"Promise",
			"Generator",
			"GeneratorFunction",
			"AsyncFunction",
			"Reflect",
			"Proxy",
			"Intl",
			"WebAssembly",
		],
		Si = [
			"Error",
			"EvalError",
			"InternalError",
			"RangeError",
			"ReferenceError",
			"SyntaxError",
			"TypeError",
			"URIError",
		],
		Ei = [
			"setInterval",
			"setTimeout",
			"clearInterval",
			"clearTimeout",
			"require",
			"exports",
			"eval",
			"isFinite",
			"isNaN",
			"parseFloat",
			"parseInt",
			"decodeURI",
			"decodeURIComponent",
			"encodeURI",
			"encodeURIComponent",
			"escape",
			"unescape",
		],
		Ti = [
			"arguments",
			"this",
			"super",
			"console",
			"window",
			"document",
			"localStorage",
			"sessionStorage",
			"module",
			"global",
		],
		Mi = [].concat(Ei, _i, Si);
	function Ul(r) {
		const e = r.regex,
			t = (ie, { after: De }) => {
				const Te = "</" + ie[0].slice(1);
				return ie.input.indexOf(Te, De) !== -1;
			},
			n = jr,
			a = { begin: "<>", end: "</>" },
			i = /<[A-Za-z0-9\\._:-]+\s*\/>/,
			s = {
				begin: /<[A-Za-z0-9\\._:-]+/,
				end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
				isTrulyOpeningTag: (ie, De) => {
					const Te = ie[0].length + ie.index,
						Ce = ie.input[Te];
					if (Ce === "<" || Ce === ",") {
						De.ignoreMatch();
						return;
					}
					Ce === ">" && (t(ie, { after: Te }) || De.ignoreMatch());
					let Me;
					const Je = ie.input.substring(Te);
					if ((Me = Je.match(/^\s*=/))) {
						De.ignoreMatch();
						return;
					}
					if ((Me = Je.match(/^\s+extends\s+/)) && Me.index === 0) {
						De.ignoreMatch();
						return;
					}
				},
			},
			l = { $pattern: jr, keyword: wi, literal: ki, built_in: Mi, "variable.language": Ti },
			u = "[0-9](_?[0-9])*",
			d = `\\.(${u})`,
			p = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*",
			f = {
				className: "number",
				variants: [
					{ begin: `(\\b(${p})((${d})|\\.)?|(${d}))[eE][+-]?(${u})\\b` },
					{ begin: `\\b(${p})\\b((${d})\\b|\\.)?|(${d})\\b` },
					{ begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
					{ begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
					{ begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
					{ begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
					{ begin: "\\b0[0-7]+n?\\b" },
				],
				relevance: 0,
			},
			v = { className: "subst", begin: "\\$\\{", end: "\\}", keywords: l, contains: [] },
			x = {
				begin: ".?html`",
				end: "",
				starts: { end: "`", returnEnd: !1, contains: [r.BACKSLASH_ESCAPE, v], subLanguage: "xml" },
			},
			_ = {
				begin: ".?css`",
				end: "",
				starts: { end: "`", returnEnd: !1, contains: [r.BACKSLASH_ESCAPE, v], subLanguage: "css" },
			},
			S = {
				begin: ".?gql`",
				end: "",
				starts: {
					end: "`",
					returnEnd: !1,
					contains: [r.BACKSLASH_ESCAPE, v],
					subLanguage: "graphql",
				},
			},
			M = { className: "string", begin: "`", end: "`", contains: [r.BACKSLASH_ESCAPE, v] },
			I = {
				className: "comment",
				variants: [
					r.COMMENT(/\/\*\*(?!\/)/, "\\*/", {
						relevance: 0,
						contains: [
							{
								begin: "(?=@[A-Za-z]+)",
								relevance: 0,
								contains: [
									{ className: "doctag", begin: "@[A-Za-z]+" },
									{
										className: "type",
										begin: "\\{",
										end: "\\}",
										excludeEnd: !0,
										excludeBegin: !0,
										relevance: 0,
									},
									{
										className: "variable",
										begin: n + "(?=\\s*(-)|$)",
										endsParent: !0,
										relevance: 0,
									},
									{ begin: /(?=[^\n])\s/, relevance: 0 },
								],
							},
						],
					}),
					r.C_BLOCK_COMMENT_MODE,
					r.C_LINE_COMMENT_MODE,
				],
			},
			$ = [r.APOS_STRING_MODE, r.QUOTE_STRING_MODE, x, _, S, M, { match: /\$\d+/ }, f];
		v.contains = $.concat({ begin: /\{/, end: /\}/, keywords: l, contains: ["self"].concat($) });
		const P = [].concat(I, v.contains),
			q = P.concat([{ begin: /(\s*)\(/, end: /\)/, keywords: l, contains: ["self"].concat(P) }]),
			U = {
				className: "params",
				begin: /(\s*)\(/,
				end: /\)/,
				excludeBegin: !0,
				excludeEnd: !0,
				keywords: l,
				contains: q,
			},
			Q = {
				variants: [
					{
						match: [
							/class/,
							/\s+/,
							n,
							/\s+/,
							/extends/,
							/\s+/,
							e.concat(n, "(", e.concat(/\./, n), ")*"),
						],
						scope: { 1: "keyword", 3: "title.class", 5: "keyword", 7: "title.class.inherited" },
					},
					{ match: [/class/, /\s+/, n], scope: { 1: "keyword", 3: "title.class" } },
				],
			},
			ne = {
				relevance: 0,
				match: e.either(
					/\bJSON/,
					/\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
					/\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
					/\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
				),
				className: "title.class",
				keywords: { _: [..._i, ...Si] },
			},
			te = {
				label: "use_strict",
				className: "meta",
				relevance: 10,
				begin: /^\s*['"]use (strict|asm)['"]/,
			},
			Pe = {
				variants: [
					{ match: [/function/, /\s+/, n, /(?=\s*\()/] },
					{ match: [/function/, /\s*(?=\()/] },
				],
				className: { 1: "keyword", 3: "title.function" },
				label: "func.def",
				contains: [U],
				illegal: /%/,
			},
			Ee = { relevance: 0, match: /\b[A-Z][A-Z_0-9]+\b/, className: "variable.constant" };
		function ve(ie) {
			return e.concat("(?!", ie.join("|"), ")");
		}
		const Qe = {
				match: e.concat(
					/\b/,
					ve([...Ei, "super", "import"].map((ie) => `${ie}\\s*\\(`)),
					n,
					e.lookahead(/\s*\(/)
				),
				className: "title.function",
				relevance: 0,
			},
			we = {
				begin: e.concat(/\./, e.lookahead(e.concat(n, /(?![0-9A-Za-z$_(])/))),
				end: n,
				excludeBegin: !0,
				keywords: "prototype",
				className: "property",
				relevance: 0,
			},
			$e = {
				match: [/get|set/, /\s+/, n, /(?=\()/],
				className: { 1: "keyword", 3: "title.function" },
				contains: [{ begin: /\(\)/ }, U],
			},
			Fe =
				"(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" +
				r.UNDERSCORE_IDENT_RE +
				")\\s*=>",
			nt = {
				match: [/const|var|let/, /\s+/, n, /\s*/, /=\s*/, /(async\s*)?/, e.lookahead(Fe)],
				keywords: "async",
				className: { 1: "keyword", 3: "title.function" },
				contains: [U],
			};
		return {
			name: "JavaScript",
			aliases: ["js", "jsx", "mjs", "cjs"],
			keywords: l,
			exports: { PARAMS_CONTAINS: q, CLASS_REFERENCE: ne },
			illegal: /#(?![$_A-z])/,
			contains: [
				r.SHEBANG({ label: "shebang", binary: "node", relevance: 5 }),
				te,
				r.APOS_STRING_MODE,
				r.QUOTE_STRING_MODE,
				x,
				_,
				S,
				M,
				I,
				{ match: /\$\d+/ },
				f,
				ne,
				{ scope: "attr", match: n + e.lookahead(":"), relevance: 0 },
				nt,
				{
					begin: "(" + r.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
					keywords: "return throw case",
					relevance: 0,
					contains: [
						I,
						r.REGEXP_MODE,
						{
							className: "function",
							begin: Fe,
							returnBegin: !0,
							end: "\\s*=>",
							contains: [
								{
									className: "params",
									variants: [
										{ begin: r.UNDERSCORE_IDENT_RE, relevance: 0 },
										{ className: null, begin: /\(\s*\)/, skip: !0 },
										{
											begin: /(\s*)\(/,
											end: /\)/,
											excludeBegin: !0,
											excludeEnd: !0,
											keywords: l,
											contains: q,
										},
									],
								},
							],
						},
						{ begin: /,/, relevance: 0 },
						{ match: /\s+/, relevance: 0 },
						{
							variants: [
								{ begin: a.begin, end: a.end },
								{ match: i },
								{ begin: s.begin, "on:begin": s.isTrulyOpeningTag, end: s.end },
							],
							subLanguage: "xml",
							contains: [{ begin: s.begin, end: s.end, skip: !0, contains: ["self"] }],
						},
					],
				},
				Pe,
				{ beginKeywords: "while if switch catch for" },
				{
					begin:
						"\\b(?!function)" +
						r.UNDERSCORE_IDENT_RE +
						"\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
					returnBegin: !0,
					label: "func.def",
					contains: [U, r.inherit(r.TITLE_MODE, { begin: n, className: "title.function" })],
				},
				{ match: /\.\.\./, relevance: 0 },
				we,
				{ match: "\\$" + n, relevance: 0 },
				{ match: [/\bconstructor(?=\s*\()/], className: { 1: "title.function" }, contains: [U] },
				Qe,
				Ee,
				Q,
				$e,
				{ match: /\$[(.]/ },
			],
		};
	}
	function Gl(r) {
		const e = r.regex,
			t = Ul(r),
			n = jr,
			a = [
				"any",
				"void",
				"number",
				"boolean",
				"string",
				"object",
				"never",
				"symbol",
				"bigint",
				"unknown",
			],
			i = {
				begin: [/namespace/, /\s+/, r.IDENT_RE],
				beginScope: { 1: "keyword", 3: "title.class" },
			},
			s = {
				beginKeywords: "interface",
				end: /\{/,
				excludeEnd: !0,
				keywords: { keyword: "interface extends", built_in: a },
				contains: [t.exports.CLASS_REFERENCE],
			},
			l = { className: "meta", relevance: 10, begin: /^\s*['"]use strict['"]/ },
			u = [
				"type",
				"interface",
				"public",
				"private",
				"protected",
				"implements",
				"declare",
				"abstract",
				"readonly",
				"enum",
				"override",
				"satisfies",
			],
			d = {
				$pattern: jr,
				keyword: wi.concat(u),
				literal: ki,
				built_in: Mi.concat(a),
				"variable.language": Ti,
			},
			p = { className: "meta", begin: "@" + n },
			f = (S, M, O) => {
				const I = S.contains.findIndex(($) => $.label === M);
				if (I === -1) throw new Error("can not find mode to replace");
				S.contains.splice(I, 1, O);
			};
		Object.assign(t.keywords, d), t.exports.PARAMS_CONTAINS.push(p);
		const v = t.contains.find((S) => S.scope === "attr"),
			x = Object.assign({}, v, { match: e.concat(n, e.lookahead(/\s*\?:/)) });
		t.exports.PARAMS_CONTAINS.push([t.exports.CLASS_REFERENCE, v, x]),
			(t.contains = t.contains.concat([p, i, s, x])),
			f(t, "shebang", r.SHEBANG()),
			f(t, "use_strict", l);
		const _ = t.contains.find((S) => S.label === "func.def");
		return (
			(_.relevance = 0),
			Object.assign(t, { name: "TypeScript", aliases: ["ts", "tsx", "mts", "cts"] }),
			t
		);
	}
	function Kl(r) {
		const e = { className: "attr", begin: /"(\\.|[^\\"\r\n])*"(?=\s*:)/, relevance: 1.01 },
			t = { match: /[{}[\],:]/, className: "punctuation", relevance: 0 },
			n = ["true", "false", "null"],
			a = { scope: "literal", beginKeywords: n.join(" ") };
		return {
			name: "JSON",
			aliases: ["jsonc"],
			keywords: { literal: n },
			contains: [
				e,
				t,
				r.QUOTE_STRING_MODE,
				a,
				r.C_NUMBER_MODE,
				r.C_LINE_COMMENT_MODE,
				r.C_BLOCK_COMMENT_MODE,
			],
			illegal: "\\S",
		};
	}
	function Vl(r) {
		const e = r.regex,
			t = {},
			n = { begin: /\$\{/, end: /\}/, contains: ["self", { begin: /:-/, contains: [t] }] };
		Object.assign(t, {
			className: "variable",
			variants: [{ begin: e.concat(/\$[\w\d#@][\w\d_]*/, "(?![\\w\\d])(?![$])") }, n],
		});
		const a = { className: "subst", begin: /\$\(/, end: /\)/, contains: [r.BACKSLASH_ESCAPE] },
			i = r.inherit(r.COMMENT(), { match: [/(^|\s)/, /#.*$/], scope: { 2: "comment" } }),
			s = {
				begin: /<<-?\s*(?=\w+)/,
				starts: {
					contains: [r.END_SAME_AS_BEGIN({ begin: /(\w+)/, end: /(\w+)/, className: "string" })],
				},
			},
			l = { className: "string", begin: /"/, end: /"/, contains: [r.BACKSLASH_ESCAPE, t, a] };
		a.contains.push(l);
		const u = { match: /\\"/ },
			d = { className: "string", begin: /'/, end: /'/ },
			p = { match: /\\'/ },
			f = {
				begin: /\$?\(\(/,
				end: /\)\)/,
				contains: [{ begin: /\d+#[0-9a-f]+/, className: "number" }, r.NUMBER_MODE, t],
			},
			v = ["fish", "bash", "zsh", "sh", "csh", "ksh", "tcsh", "dash", "scsh"],
			x = r.SHEBANG({ binary: `(${v.join("|")})`, relevance: 10 }),
			_ = {
				className: "function",
				begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
				returnBegin: !0,
				contains: [r.inherit(r.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
				relevance: 0,
			},
			S = [
				"if",
				"then",
				"else",
				"elif",
				"fi",
				"time",
				"for",
				"while",
				"until",
				"in",
				"do",
				"done",
				"case",
				"esac",
				"coproc",
				"function",
				"select",
			],
			M = ["true", "false"],
			O = { match: /(\/[a-z._-]+)+/ },
			I = [
				"break",
				"cd",
				"continue",
				"eval",
				"exec",
				"exit",
				"export",
				"getopts",
				"hash",
				"pwd",
				"readonly",
				"return",
				"shift",
				"test",
				"times",
				"trap",
				"umask",
				"unset",
			],
			$ = [
				"alias",
				"bind",
				"builtin",
				"caller",
				"command",
				"declare",
				"echo",
				"enable",
				"help",
				"let",
				"local",
				"logout",
				"mapfile",
				"printf",
				"read",
				"readarray",
				"source",
				"sudo",
				"type",
				"typeset",
				"ulimit",
				"unalias",
			],
			P = [
				"autoload",
				"bg",
				"bindkey",
				"bye",
				"cap",
				"chdir",
				"clone",
				"comparguments",
				"compcall",
				"compctl",
				"compdescribe",
				"compfiles",
				"compgroups",
				"compquote",
				"comptags",
				"comptry",
				"compvalues",
				"dirs",
				"disable",
				"disown",
				"echotc",
				"echoti",
				"emulate",
				"fc",
				"fg",
				"float",
				"functions",
				"getcap",
				"getln",
				"history",
				"integer",
				"jobs",
				"kill",
				"limit",
				"log",
				"noglob",
				"popd",
				"print",
				"pushd",
				"pushln",
				"rehash",
				"sched",
				"setcap",
				"setopt",
				"stat",
				"suspend",
				"ttyctl",
				"unfunction",
				"unhash",
				"unlimit",
				"unsetopt",
				"vared",
				"wait",
				"whence",
				"where",
				"which",
				"zcompile",
				"zformat",
				"zftp",
				"zle",
				"zmodload",
				"zparseopts",
				"zprof",
				"zpty",
				"zregexparse",
				"zsocket",
				"zstyle",
				"ztcp",
			],
			q = [
				"chcon",
				"chgrp",
				"chown",
				"chmod",
				"cp",
				"dd",
				"df",
				"dir",
				"dircolors",
				"ln",
				"ls",
				"mkdir",
				"mkfifo",
				"mknod",
				"mktemp",
				"mv",
				"realpath",
				"rm",
				"rmdir",
				"shred",
				"sync",
				"touch",
				"truncate",
				"vdir",
				"b2sum",
				"base32",
				"base64",
				"cat",
				"cksum",
				"comm",
				"csplit",
				"cut",
				"expand",
				"fmt",
				"fold",
				"head",
				"join",
				"md5sum",
				"nl",
				"numfmt",
				"od",
				"paste",
				"ptx",
				"pr",
				"sha1sum",
				"sha224sum",
				"sha256sum",
				"sha384sum",
				"sha512sum",
				"shuf",
				"sort",
				"split",
				"sum",
				"tac",
				"tail",
				"tr",
				"tsort",
				"unexpand",
				"uniq",
				"wc",
				"arch",
				"basename",
				"chroot",
				"date",
				"dirname",
				"du",
				"echo",
				"env",
				"expr",
				"factor",
				"groups",
				"hostid",
				"id",
				"link",
				"logname",
				"nice",
				"nohup",
				"nproc",
				"pathchk",
				"pinky",
				"printenv",
				"printf",
				"pwd",
				"readlink",
				"runcon",
				"seq",
				"sleep",
				"stat",
				"stdbuf",
				"stty",
				"tee",
				"test",
				"timeout",
				"tty",
				"uname",
				"unlink",
				"uptime",
				"users",
				"who",
				"whoami",
				"yes",
			];
		return {
			name: "Bash",
			aliases: ["sh", "zsh"],
			keywords: {
				$pattern: /\b[a-z][a-z0-9._-]+\b/,
				keyword: S,
				literal: M,
				built_in: [...I, ...$, "set", "shopt", ...P, ...q],
			},
			contains: [x, r.SHEBANG(), _, f, i, s, O, l, u, d, p, t],
		};
	}
	function Wl(r) {
		return {
			name: "Shell Session",
			aliases: ["console", "shellsession"],
			contains: [
				{
					className: "meta.prompt",
					begin: /^\s{0,3}[/~\w\d[\]()@-]*[>%$#][ ]?/,
					starts: { end: /[^\\](?=\s*$)/, subLanguage: "bash" },
				},
			],
		};
	}
	function Zl(r) {
		const e = r.regex,
			t = new RegExp("[\\p{XID_Start}_]\\p{XID_Continue}*", "u"),
			n = [
				"and",
				"as",
				"assert",
				"async",
				"await",
				"break",
				"case",
				"class",
				"continue",
				"def",
				"del",
				"elif",
				"else",
				"except",
				"finally",
				"for",
				"from",
				"global",
				"if",
				"import",
				"in",
				"is",
				"lambda",
				"match",
				"nonlocal|10",
				"not",
				"or",
				"pass",
				"raise",
				"return",
				"try",
				"while",
				"with",
				"yield",
			],
			l = {
				$pattern: /[A-Za-z]\w+|__\w+__/,
				keyword: n,
				built_in: [
					"__import__",
					"abs",
					"all",
					"any",
					"ascii",
					"bin",
					"bool",
					"breakpoint",
					"bytearray",
					"bytes",
					"callable",
					"chr",
					"classmethod",
					"compile",
					"complex",
					"delattr",
					"dict",
					"dir",
					"divmod",
					"enumerate",
					"eval",
					"exec",
					"filter",
					"float",
					"format",
					"frozenset",
					"getattr",
					"globals",
					"hasattr",
					"hash",
					"help",
					"hex",
					"id",
					"input",
					"int",
					"isinstance",
					"issubclass",
					"iter",
					"len",
					"list",
					"locals",
					"map",
					"max",
					"memoryview",
					"min",
					"next",
					"object",
					"oct",
					"open",
					"ord",
					"pow",
					"print",
					"property",
					"range",
					"repr",
					"reversed",
					"round",
					"set",
					"setattr",
					"slice",
					"sorted",
					"staticmethod",
					"str",
					"sum",
					"super",
					"tuple",
					"type",
					"vars",
					"zip",
				],
				literal: ["__debug__", "Ellipsis", "False", "None", "NotImplemented", "True"],
				type: [
					"Any",
					"Callable",
					"Coroutine",
					"Dict",
					"List",
					"Literal",
					"Generic",
					"Optional",
					"Sequence",
					"Set",
					"Tuple",
					"Type",
					"Union",
				],
			},
			u = { className: "meta", begin: /^(>>>|\.\.\.) / },
			d = { className: "subst", begin: /\{/, end: /\}/, keywords: l, illegal: /#/ },
			p = { begin: /\{\{/, relevance: 0 },
			f = {
				className: "string",
				contains: [r.BACKSLASH_ESCAPE],
				variants: [
					{
						begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
						end: /'''/,
						contains: [r.BACKSLASH_ESCAPE, u],
						relevance: 10,
					},
					{
						begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
						end: /"""/,
						contains: [r.BACKSLASH_ESCAPE, u],
						relevance: 10,
					},
					{
						begin: /([fF][rR]|[rR][fF]|[fF])'''/,
						end: /'''/,
						contains: [r.BACKSLASH_ESCAPE, u, p, d],
					},
					{
						begin: /([fF][rR]|[rR][fF]|[fF])"""/,
						end: /"""/,
						contains: [r.BACKSLASH_ESCAPE, u, p, d],
					},
					{ begin: /([uU]|[rR])'/, end: /'/, relevance: 10 },
					{ begin: /([uU]|[rR])"/, end: /"/, relevance: 10 },
					{ begin: /([bB]|[bB][rR]|[rR][bB])'/, end: /'/ },
					{ begin: /([bB]|[bB][rR]|[rR][bB])"/, end: /"/ },
					{ begin: /([fF][rR]|[rR][fF]|[fF])'/, end: /'/, contains: [r.BACKSLASH_ESCAPE, p, d] },
					{ begin: /([fF][rR]|[rR][fF]|[fF])"/, end: /"/, contains: [r.BACKSLASH_ESCAPE, p, d] },
					r.APOS_STRING_MODE,
					r.QUOTE_STRING_MODE,
				],
			},
			v = "[0-9](_?[0-9])*",
			x = `(\\b(${v}))?\\.(${v})|\\b(${v})\\.`,
			_ = `\\b|${n.join("|")}`,
			S = {
				className: "number",
				relevance: 0,
				variants: [
					{ begin: `(\\b(${v})|(${x}))[eE][+-]?(${v})[jJ]?(?=${_})` },
					{ begin: `(${x})[jJ]?` },
					{ begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${_})` },
					{ begin: `\\b0[bB](_?[01])+[lL]?(?=${_})` },
					{ begin: `\\b0[oO](_?[0-7])+[lL]?(?=${_})` },
					{ begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${_})` },
					{ begin: `\\b(${v})[jJ](?=${_})` },
				],
			},
			M = {
				className: "comment",
				begin: e.lookahead(/# type:/),
				end: /$/,
				keywords: l,
				contains: [{ begin: /# type:/ }, { begin: /#/, end: /\b\B/, endsWithParent: !0 }],
			},
			O = {
				className: "params",
				variants: [
					{ className: "", begin: /\(\s*\)/, skip: !0 },
					{
						begin: /\(/,
						end: /\)/,
						excludeBegin: !0,
						excludeEnd: !0,
						keywords: l,
						contains: ["self", u, S, f, r.HASH_COMMENT_MODE],
					},
				],
			};
		return (
			(d.contains = [f, S, u]),
			{
				name: "Python",
				aliases: ["py", "gyp", "ipython"],
				unicodeRegex: !0,
				keywords: l,
				illegal: /(<\/|\?)|=>/,
				contains: [
					u,
					S,
					{ scope: "variable.language", match: /\bself\b/ },
					{ beginKeywords: "if", relevance: 0 },
					{ match: /\bor\b/, scope: "keyword" },
					f,
					M,
					r.HASH_COMMENT_MODE,
					{
						match: [/\bdef/, /\s+/, t],
						scope: { 1: "keyword", 3: "title.function" },
						contains: [O],
					},
					{
						variants: [
							{ match: [/\bclass/, /\s+/, t, /\s*/, /\(\s*/, t, /\s*\)/] },
							{ match: [/\bclass/, /\s+/, t] },
						],
						scope: { 1: "keyword", 3: "title.class", 6: "title.class.inherited" },
					},
					{ className: "meta", begin: /^[\t ]*@/, end: /(?=#)|$/, contains: [S, O, f] },
				],
			}
		);
	}
	function Xl(r) {
		const i = {
			keyword: [
				"break",
				"case",
				"chan",
				"const",
				"continue",
				"default",
				"defer",
				"else",
				"fallthrough",
				"for",
				"func",
				"go",
				"goto",
				"if",
				"import",
				"interface",
				"map",
				"package",
				"range",
				"return",
				"select",
				"struct",
				"switch",
				"type",
				"var",
			],
			type: [
				"bool",
				"byte",
				"complex64",
				"complex128",
				"error",
				"float32",
				"float64",
				"int8",
				"int16",
				"int32",
				"int64",
				"string",
				"uint8",
				"uint16",
				"uint32",
				"uint64",
				"int",
				"uint",
				"uintptr",
				"rune",
			],
			literal: ["true", "false", "iota", "nil"],
			built_in: [
				"append",
				"cap",
				"close",
				"complex",
				"copy",
				"imag",
				"len",
				"make",
				"new",
				"panic",
				"print",
				"println",
				"real",
				"recover",
				"delete",
			],
		};
		return {
			name: "Go",
			aliases: ["golang"],
			keywords: i,
			illegal: "</",
			contains: [
				r.C_LINE_COMMENT_MODE,
				r.C_BLOCK_COMMENT_MODE,
				{
					className: "string",
					variants: [r.QUOTE_STRING_MODE, r.APOS_STRING_MODE, { begin: "`", end: "`" }],
				},
				{
					className: "number",
					variants: [
						{ match: /-?\b0[xX]\.[a-fA-F0-9](_?[a-fA-F0-9])*[pP][+-]?\d(_?\d)*i?/, relevance: 0 },
						{
							match:
								/-?\b0[xX](_?[a-fA-F0-9])+((\.([a-fA-F0-9](_?[a-fA-F0-9])*)?)?[pP][+-]?\d(_?\d)*)?i?/,
							relevance: 0,
						},
						{ match: /-?\b0[oO](_?[0-7])*i?/, relevance: 0 },
						{ match: /-?\.\d(_?\d)*([eE][+-]?\d(_?\d)*)?i?/, relevance: 0 },
						{ match: /-?\b\d(_?\d)*(\.(\d(_?\d)*)?)?([eE][+-]?\d(_?\d)*)?i?/, relevance: 0 },
					],
				},
				{ begin: /:=/ },
				{
					className: "function",
					beginKeywords: "func",
					end: "\\s*(\\{|$)",
					excludeEnd: !0,
					contains: [
						r.TITLE_MODE,
						{
							className: "params",
							begin: /\(/,
							end: /\)/,
							endsParent: !0,
							keywords: i,
							illegal: /["']/,
						},
					],
				},
			],
		};
	}
	function Yl(r) {
		const e = r.regex,
			t = /(r#)?/,
			n = e.concat(t, r.UNDERSCORE_IDENT_RE),
			a = e.concat(t, r.IDENT_RE),
			i = {
				className: "title.function.invoke",
				relevance: 0,
				begin: e.concat(/\b/, /(?!let|for|while|if|else|match\b)/, a, e.lookahead(/\s*\(/)),
			},
			s = "([ui](8|16|32|64|128|size)|f(32|64))?",
			l = [
				"abstract",
				"as",
				"async",
				"await",
				"become",
				"box",
				"break",
				"const",
				"continue",
				"crate",
				"do",
				"dyn",
				"else",
				"enum",
				"extern",
				"false",
				"final",
				"fn",
				"for",
				"if",
				"impl",
				"in",
				"let",
				"loop",
				"macro",
				"match",
				"mod",
				"move",
				"mut",
				"override",
				"priv",
				"pub",
				"ref",
				"return",
				"self",
				"Self",
				"static",
				"struct",
				"super",
				"trait",
				"true",
				"try",
				"type",
				"typeof",
				"union",
				"unsafe",
				"unsized",
				"use",
				"virtual",
				"where",
				"while",
				"yield",
			],
			u = ["true", "false", "Some", "None", "Ok", "Err"],
			d = [
				"drop ",
				"Copy",
				"Send",
				"Sized",
				"Sync",
				"Drop",
				"Fn",
				"FnMut",
				"FnOnce",
				"ToOwned",
				"Clone",
				"Debug",
				"PartialEq",
				"PartialOrd",
				"Eq",
				"Ord",
				"AsRef",
				"AsMut",
				"Into",
				"From",
				"Default",
				"Iterator",
				"Extend",
				"IntoIterator",
				"DoubleEndedIterator",
				"ExactSizeIterator",
				"SliceConcatExt",
				"ToString",
				"assert!",
				"assert_eq!",
				"bitflags!",
				"bytes!",
				"cfg!",
				"col!",
				"concat!",
				"concat_idents!",
				"debug_assert!",
				"debug_assert_eq!",
				"env!",
				"eprintln!",
				"panic!",
				"file!",
				"format!",
				"format_args!",
				"include_bytes!",
				"include_str!",
				"line!",
				"local_data_key!",
				"module_path!",
				"option_env!",
				"print!",
				"println!",
				"select!",
				"stringify!",
				"try!",
				"unimplemented!",
				"unreachable!",
				"vec!",
				"write!",
				"writeln!",
				"macro_rules!",
				"assert_ne!",
				"debug_assert_ne!",
			],
			p = [
				"i8",
				"i16",
				"i32",
				"i64",
				"i128",
				"isize",
				"u8",
				"u16",
				"u32",
				"u64",
				"u128",
				"usize",
				"f32",
				"f64",
				"str",
				"char",
				"bool",
				"Box",
				"Option",
				"Result",
				"String",
				"Vec",
			];
		return {
			name: "Rust",
			aliases: ["rs"],
			keywords: { $pattern: r.IDENT_RE + "!?", type: p, keyword: l, literal: u, built_in: d },
			illegal: "</",
			contains: [
				r.C_LINE_COMMENT_MODE,
				r.COMMENT("/\\*", "\\*/", { contains: ["self"] }),
				r.inherit(r.QUOTE_STRING_MODE, { begin: /b?"/, illegal: null }),
				{ className: "symbol", begin: /'[a-zA-Z_][a-zA-Z0-9_]*(?!')/ },
				{
					scope: "string",
					variants: [
						{ begin: /b?r(#*)"(.|\n)*?"\1(?!#)/ },
						{
							begin: /b?'/,
							end: /'/,
							contains: [{ scope: "char.escape", match: /\\('|\w|x\w{2}|u\w{4}|U\w{8})/ }],
						},
					],
				},
				{
					className: "number",
					variants: [
						{ begin: "\\b0b([01_]+)" + s },
						{ begin: "\\b0o([0-7_]+)" + s },
						{ begin: "\\b0x([A-Fa-f0-9_]+)" + s },
						{ begin: "\\b(\\d[\\d_]*(\\.[0-9_]+)?([eE][+-]?[0-9_]+)?)" + s },
					],
					relevance: 0,
				},
				{ begin: [/fn/, /\s+/, n], className: { 1: "keyword", 3: "title.function" } },
				{
					className: "meta",
					begin: "#!?\\[",
					end: "\\]",
					contains: [{ className: "string", begin: /"/, end: /"/, contains: [r.BACKSLASH_ESCAPE] }],
				},
				{
					begin: [/let/, /\s+/, /(?:mut\s+)?/, n],
					className: { 1: "keyword", 3: "keyword", 4: "variable" },
				},
				{
					begin: [/for/, /\s+/, n, /\s+/, /in/],
					className: { 1: "keyword", 3: "variable", 5: "keyword" },
				},
				{ begin: [/type/, /\s+/, n], className: { 1: "keyword", 3: "title.class" } },
				{
					begin: [/(?:trait|enum|struct|union|impl|for)/, /\s+/, n],
					className: { 1: "keyword", 3: "title.class" },
				},
				{ begin: r.IDENT_RE + "::", keywords: { keyword: "Self", built_in: d, type: p } },
				{ className: "punctuation", begin: "->" },
				i,
			],
		};
	}
	var Qt = "[0-9](_*[0-9])*",
		e0 = `\\.(${Qt})`,
		t0 = "[0-9a-fA-F](_*[0-9a-fA-F])*",
		Ai = {
			className: "number",
			variants: [
				{ begin: `(\\b(${Qt})((${e0})|\\.)?|(${e0}))[eE][+-]?(${Qt})[fFdD]?\\b` },
				{ begin: `\\b(${Qt})((${e0})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
				{ begin: `(${e0})[fFdD]?\\b` },
				{ begin: `\\b(${Qt})[fFdD]\\b` },
				{ begin: `\\b0[xX]((${t0})\\.?|(${t0})?\\.(${t0}))[pP][+-]?(${Qt})[fFdD]?\\b` },
				{ begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
				{ begin: `\\b0[xX](${t0})[lL]?\\b` },
				{ begin: "\\b0(_*[0-7])*[lL]?\\b" },
				{ begin: "\\b0[bB][01](_*[01])*[lL]?\\b" },
			],
			relevance: 0,
		};
	function Ni(r, e, t) {
		return t === -1 ? "" : r.replace(e, (n) => Ni(r, e, t - 1));
	}
	function Ql(r) {
		const e = r.regex,
			t = "[À-ʸa-zA-Z_$][À-ʸa-zA-Z_$0-9]*",
			n = t + Ni("(?:<" + t + "~~~(?:\\s*,\\s*" + t + "~~~)*>)?", /~~~/g, 2),
			u = {
				keyword: [
					"synchronized",
					"abstract",
					"private",
					"var",
					"static",
					"if",
					"const ",
					"for",
					"while",
					"strictfp",
					"finally",
					"protected",
					"import",
					"native",
					"final",
					"void",
					"enum",
					"else",
					"break",
					"transient",
					"catch",
					"instanceof",
					"volatile",
					"case",
					"assert",
					"package",
					"default",
					"public",
					"try",
					"switch",
					"continue",
					"throws",
					"protected",
					"public",
					"private",
					"module",
					"requires",
					"exports",
					"do",
					"sealed",
					"yield",
					"permits",
					"goto",
					"when",
				],
				literal: ["false", "true", "null"],
				type: ["char", "boolean", "long", "float", "int", "byte", "short", "double"],
				built_in: ["super", "this"],
			},
			d = {
				className: "meta",
				begin: "@" + t,
				contains: [{ begin: /\(/, end: /\)/, contains: ["self"] }],
			},
			p = {
				className: "params",
				begin: /\(/,
				end: /\)/,
				keywords: u,
				relevance: 0,
				contains: [r.C_BLOCK_COMMENT_MODE],
				endsParent: !0,
			};
		return {
			name: "Java",
			aliases: ["jsp"],
			keywords: u,
			illegal: /<\/|#/,
			contains: [
				r.COMMENT("/\\*\\*", "\\*/", {
					relevance: 0,
					contains: [
						{ begin: /\w+@/, relevance: 0 },
						{ className: "doctag", begin: "@[A-Za-z]+" },
					],
				}),
				{ begin: /import java\.[a-z]+\./, keywords: "import", relevance: 2 },
				r.C_LINE_COMMENT_MODE,
				r.C_BLOCK_COMMENT_MODE,
				{ begin: /"""/, end: /"""/, className: "string", contains: [r.BACKSLASH_ESCAPE] },
				r.APOS_STRING_MODE,
				r.QUOTE_STRING_MODE,
				{
					match: [/\b(?:class|interface|enum|extends|implements|new)/, /\s+/, t],
					className: { 1: "keyword", 3: "title.class" },
				},
				{ match: /non-sealed/, scope: "keyword" },
				{
					begin: [e.concat(/(?!else)/, t), /\s+/, t, /\s+/, /=(?!=)/],
					className: { 1: "type", 3: "variable", 5: "operator" },
				},
				{
					begin: [/record/, /\s+/, t],
					className: { 1: "keyword", 3: "title.class" },
					contains: [p, r.C_LINE_COMMENT_MODE, r.C_BLOCK_COMMENT_MODE],
				},
				{ beginKeywords: "new throw return else", relevance: 0 },
				{
					begin: ["(?:" + n + "\\s+)", r.UNDERSCORE_IDENT_RE, /\s*(?=\()/],
					className: { 2: "title.function" },
					keywords: u,
					contains: [
						{
							className: "params",
							begin: /\(/,
							end: /\)/,
							keywords: u,
							relevance: 0,
							contains: [d, r.APOS_STRING_MODE, r.QUOTE_STRING_MODE, Ai, r.C_BLOCK_COMMENT_MODE],
						},
						r.C_LINE_COMMENT_MODE,
						r.C_BLOCK_COMMENT_MODE,
					],
				},
				Ai,
				d,
			],
		};
	}
	function Jl(r) {
		const e = [
				"bool",
				"byte",
				"char",
				"decimal",
				"delegate",
				"double",
				"dynamic",
				"enum",
				"float",
				"int",
				"long",
				"nint",
				"nuint",
				"object",
				"sbyte",
				"short",
				"string",
				"ulong",
				"uint",
				"ushort",
			],
			t = [
				"public",
				"private",
				"protected",
				"static",
				"internal",
				"protected",
				"abstract",
				"async",
				"extern",
				"override",
				"unsafe",
				"virtual",
				"new",
				"sealed",
				"partial",
			],
			n = ["default", "false", "null", "true"],
			a = [
				"abstract",
				"as",
				"base",
				"break",
				"case",
				"catch",
				"class",
				"const",
				"continue",
				"do",
				"else",
				"event",
				"explicit",
				"extern",
				"finally",
				"fixed",
				"for",
				"foreach",
				"goto",
				"if",
				"implicit",
				"in",
				"interface",
				"internal",
				"is",
				"lock",
				"namespace",
				"new",
				"operator",
				"out",
				"override",
				"params",
				"private",
				"protected",
				"public",
				"readonly",
				"record",
				"ref",
				"return",
				"scoped",
				"sealed",
				"sizeof",
				"stackalloc",
				"static",
				"struct",
				"switch",
				"this",
				"throw",
				"try",
				"typeof",
				"unchecked",
				"unsafe",
				"using",
				"virtual",
				"void",
				"volatile",
				"while",
			],
			i = [
				"add",
				"alias",
				"and",
				"ascending",
				"args",
				"async",
				"await",
				"by",
				"descending",
				"dynamic",
				"equals",
				"file",
				"from",
				"get",
				"global",
				"group",
				"init",
				"into",
				"join",
				"let",
				"nameof",
				"not",
				"notnull",
				"on",
				"or",
				"orderby",
				"partial",
				"record",
				"remove",
				"required",
				"scoped",
				"select",
				"set",
				"unmanaged",
				"value|0",
				"var",
				"when",
				"where",
				"with",
				"yield",
			],
			s = { keyword: a.concat(i), built_in: e, literal: n },
			l = r.inherit(r.TITLE_MODE, { begin: "[a-zA-Z](\\.?\\w)*" }),
			u = {
				className: "number",
				variants: [
					{ begin: "\\b(0b[01']+)" },
					{ begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)" },
					{
						begin:
							"(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)",
					},
				],
				relevance: 0,
			},
			d = { className: "string", begin: /"""("*)(?!")(.|\n)*?"""\1/, relevance: 1 },
			p = { className: "string", begin: '@"', end: '"', contains: [{ begin: '""' }] },
			f = r.inherit(p, { illegal: /\n/ }),
			v = { className: "subst", begin: /\{/, end: /\}/, keywords: s },
			x = r.inherit(v, { illegal: /\n/ }),
			_ = {
				className: "string",
				begin: /\$"/,
				end: '"',
				illegal: /\n/,
				contains: [{ begin: /\{\{/ }, { begin: /\}\}/ }, r.BACKSLASH_ESCAPE, x],
			},
			S = {
				className: "string",
				begin: /\$@"/,
				end: '"',
				contains: [{ begin: /\{\{/ }, { begin: /\}\}/ }, { begin: '""' }, v],
			},
			M = r.inherit(S, {
				illegal: /\n/,
				contains: [{ begin: /\{\{/ }, { begin: /\}\}/ }, { begin: '""' }, x],
			});
		(v.contains = [S, _, p, r.APOS_STRING_MODE, r.QUOTE_STRING_MODE, u, r.C_BLOCK_COMMENT_MODE]),
			(x.contains = [
				M,
				_,
				f,
				r.APOS_STRING_MODE,
				r.QUOTE_STRING_MODE,
				u,
				r.inherit(r.C_BLOCK_COMMENT_MODE, { illegal: /\n/ }),
			]);
		const O = { variants: [d, S, _, p, r.APOS_STRING_MODE, r.QUOTE_STRING_MODE] },
			I = { begin: "<", end: ">", contains: [{ beginKeywords: "in out" }, l] },
			$ = r.IDENT_RE + "(<" + r.IDENT_RE + "(\\s*,\\s*" + r.IDENT_RE + ")*>)?(\\[\\])?",
			P = { begin: "@" + r.IDENT_RE, relevance: 0 };
		return {
			name: "C#",
			aliases: ["cs", "c#"],
			keywords: s,
			illegal: /::/,
			contains: [
				r.COMMENT("///", "$", {
					returnBegin: !0,
					contains: [
						{
							className: "doctag",
							variants: [
								{ begin: "///", relevance: 0 },
								{ begin: "<!--|-->" },
								{ begin: "</?", end: ">" },
							],
						},
					],
				}),
				r.C_LINE_COMMENT_MODE,
				r.C_BLOCK_COMMENT_MODE,
				{
					className: "meta",
					begin: "#",
					end: "$",
					keywords: {
						keyword:
							"if else elif endif define undef warning error line region endregion pragma checksum",
					},
				},
				O,
				u,
				{
					beginKeywords: "class interface",
					relevance: 0,
					end: /[{;=]/,
					illegal: /[^\s:,]/,
					contains: [
						{ beginKeywords: "where class" },
						l,
						I,
						r.C_LINE_COMMENT_MODE,
						r.C_BLOCK_COMMENT_MODE,
					],
				},
				{
					beginKeywords: "namespace",
					relevance: 0,
					end: /[{;=]/,
					illegal: /[^\s:]/,
					contains: [l, r.C_LINE_COMMENT_MODE, r.C_BLOCK_COMMENT_MODE],
				},
				{
					beginKeywords: "record",
					relevance: 0,
					end: /[{;=]/,
					illegal: /[^\s:]/,
					contains: [l, I, r.C_LINE_COMMENT_MODE, r.C_BLOCK_COMMENT_MODE],
				},
				{
					className: "meta",
					begin: "^\\s*\\[(?=[\\w])",
					excludeBegin: !0,
					end: "\\]",
					excludeEnd: !0,
					contains: [{ className: "string", begin: /"/, end: /"/ }],
				},
				{ beginKeywords: "new return throw await else", relevance: 0 },
				{
					className: "function",
					begin: "(" + $ + "\\s+)+" + r.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
					returnBegin: !0,
					end: /\s*[{;=]/,
					excludeEnd: !0,
					keywords: s,
					contains: [
						{ beginKeywords: t.join(" "), relevance: 0 },
						{
							begin: r.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
							returnBegin: !0,
							contains: [r.TITLE_MODE, I],
							relevance: 0,
						},
						{ match: /\(\)/ },
						{
							className: "params",
							begin: /\(/,
							end: /\)/,
							excludeBegin: !0,
							excludeEnd: !0,
							keywords: s,
							relevance: 0,
							contains: [O, u, r.C_BLOCK_COMMENT_MODE],
						},
						r.C_LINE_COMMENT_MODE,
						r.C_BLOCK_COMMENT_MODE,
					],
				},
				P,
			],
		};
	}
	function jl(r) {
		const e = r.regex,
			t = r.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }),
			n = "decltype\\(auto\\)",
			a = "[a-zA-Z_]\\w*::",
			s = "(?!struct)(" + n + "|" + e.optional(a) + "[a-zA-Z_]\\w*" + e.optional("<[^<>]+>") + ")",
			l = { className: "type", begin: "\\b[a-z\\d_]*_t\\b" },
			d = {
				className: "string",
				variants: [
					{ begin: '(u8?|U|L)?"', end: '"', illegal: "\\n", contains: [r.BACKSLASH_ESCAPE] },
					{
						begin: "(u8?|U|L)?'(" + "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)" + "|.)",
						end: "'",
						illegal: ".",
					},
					r.END_SAME_AS_BEGIN({
						begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
						end: /\)([^()\\ ]{0,16})"/,
					}),
				],
			},
			p = {
				className: "number",
				variants: [
					{
						begin:
							"[+-]?(?:(?:[0-9](?:'?[0-9])*\\.(?:[0-9](?:'?[0-9])*)?|\\.[0-9](?:'?[0-9])*)(?:[Ee][+-]?[0-9](?:'?[0-9])*)?|[0-9](?:'?[0-9])*[Ee][+-]?[0-9](?:'?[0-9])*|0[Xx](?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*(?:\\.(?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)?)?|\\.[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)[Pp][+-]?[0-9](?:'?[0-9])*)(?:[Ff](?:16|32|64|128)?|(BF|bf)16|[Ll]|)",
					},
					{
						begin:
							"[+-]?\\b(?:0[Bb][01](?:'?[01])*|0[Xx][0-9A-Fa-f](?:'?[0-9A-Fa-f])*|0(?:'?[0-7])*|[1-9](?:'?[0-9])*)(?:[Uu](?:LL?|ll?)|[Uu][Zz]?|(?:LL?|ll?)[Uu]?|[Zz][Uu]|)",
					},
				],
				relevance: 0,
			},
			f = {
				className: "meta",
				begin: /#\s*[a-z]+\b/,
				end: /$/,
				keywords: {
					keyword:
						"if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include",
				},
				contains: [
					{ begin: /\\\n/, relevance: 0 },
					r.inherit(d, { className: "string" }),
					{ className: "string", begin: /<.*?>/ },
					t,
					r.C_BLOCK_COMMENT_MODE,
				],
			},
			v = { className: "title", begin: e.optional(a) + r.IDENT_RE, relevance: 0 },
			x = e.optional(a) + r.IDENT_RE + "\\s*\\(",
			_ = [
				"alignas",
				"alignof",
				"and",
				"and_eq",
				"asm",
				"atomic_cancel",
				"atomic_commit",
				"atomic_noexcept",
				"auto",
				"bitand",
				"bitor",
				"break",
				"case",
				"catch",
				"class",
				"co_await",
				"co_return",
				"co_yield",
				"compl",
				"concept",
				"const_cast|10",
				"consteval",
				"constexpr",
				"constinit",
				"continue",
				"decltype",
				"default",
				"delete",
				"do",
				"dynamic_cast|10",
				"else",
				"enum",
				"explicit",
				"export",
				"extern",
				"false",
				"final",
				"for",
				"friend",
				"goto",
				"if",
				"import",
				"inline",
				"module",
				"mutable",
				"namespace",
				"new",
				"noexcept",
				"not",
				"not_eq",
				"nullptr",
				"operator",
				"or",
				"or_eq",
				"override",
				"private",
				"protected",
				"public",
				"reflexpr",
				"register",
				"reinterpret_cast|10",
				"requires",
				"return",
				"sizeof",
				"static_assert",
				"static_cast|10",
				"struct",
				"switch",
				"synchronized",
				"template",
				"this",
				"thread_local",
				"throw",
				"transaction_safe",
				"transaction_safe_dynamic",
				"true",
				"try",
				"typedef",
				"typeid",
				"typename",
				"union",
				"using",
				"virtual",
				"volatile",
				"while",
				"xor",
				"xor_eq",
			],
			S = [
				"bool",
				"char",
				"char16_t",
				"char32_t",
				"char8_t",
				"double",
				"float",
				"int",
				"long",
				"short",
				"void",
				"wchar_t",
				"unsigned",
				"signed",
				"const",
				"static",
			],
			M = [
				"any",
				"auto_ptr",
				"barrier",
				"binary_semaphore",
				"bitset",
				"complex",
				"condition_variable",
				"condition_variable_any",
				"counting_semaphore",
				"deque",
				"false_type",
				"flat_map",
				"flat_set",
				"future",
				"imaginary",
				"initializer_list",
				"istringstream",
				"jthread",
				"latch",
				"lock_guard",
				"multimap",
				"multiset",
				"mutex",
				"optional",
				"ostringstream",
				"packaged_task",
				"pair",
				"promise",
				"priority_queue",
				"queue",
				"recursive_mutex",
				"recursive_timed_mutex",
				"scoped_lock",
				"set",
				"shared_future",
				"shared_lock",
				"shared_mutex",
				"shared_timed_mutex",
				"shared_ptr",
				"stack",
				"string_view",
				"stringstream",
				"timed_mutex",
				"thread",
				"true_type",
				"tuple",
				"unique_lock",
				"unique_ptr",
				"unordered_map",
				"unordered_multimap",
				"unordered_multiset",
				"unordered_set",
				"variant",
				"vector",
				"weak_ptr",
				"wstring",
				"wstring_view",
			],
			O = [
				"abort",
				"abs",
				"acos",
				"apply",
				"as_const",
				"asin",
				"atan",
				"atan2",
				"calloc",
				"ceil",
				"cerr",
				"cin",
				"clog",
				"cos",
				"cosh",
				"cout",
				"declval",
				"endl",
				"exchange",
				"exit",
				"exp",
				"fabs",
				"floor",
				"fmod",
				"forward",
				"fprintf",
				"fputs",
				"free",
				"frexp",
				"fscanf",
				"future",
				"invoke",
				"isalnum",
				"isalpha",
				"iscntrl",
				"isdigit",
				"isgraph",
				"islower",
				"isprint",
				"ispunct",
				"isspace",
				"isupper",
				"isxdigit",
				"labs",
				"launder",
				"ldexp",
				"log",
				"log10",
				"make_pair",
				"make_shared",
				"make_shared_for_overwrite",
				"make_tuple",
				"make_unique",
				"malloc",
				"memchr",
				"memcmp",
				"memcpy",
				"memset",
				"modf",
				"move",
				"pow",
				"printf",
				"putchar",
				"puts",
				"realloc",
				"scanf",
				"sin",
				"sinh",
				"snprintf",
				"sprintf",
				"sqrt",
				"sscanf",
				"std",
				"stderr",
				"stdin",
				"stdout",
				"strcat",
				"strchr",
				"strcmp",
				"strcpy",
				"strcspn",
				"strlen",
				"strncat",
				"strncmp",
				"strncpy",
				"strpbrk",
				"strrchr",
				"strspn",
				"strstr",
				"swap",
				"tan",
				"tanh",
				"terminate",
				"to_underlying",
				"tolower",
				"toupper",
				"vfprintf",
				"visit",
				"vprintf",
				"vsprintf",
			],
			P = {
				type: S,
				keyword: _,
				literal: ["NULL", "false", "nullopt", "nullptr", "true"],
				built_in: ["_Pragma"],
				_type_hints: M,
			},
			q = {
				className: "function.dispatch",
				relevance: 0,
				keywords: { _hint: O },
				begin: e.concat(
					/\b/,
					/(?!decltype)/,
					/(?!if)/,
					/(?!for)/,
					/(?!switch)/,
					/(?!while)/,
					r.IDENT_RE,
					e.lookahead(/(<[^<>]+>|)\s*\(/)
				),
			},
			U = [q, f, l, t, r.C_BLOCK_COMMENT_MODE, p, d],
			Q = {
				variants: [
					{ begin: /=/, end: /;/ },
					{ begin: /\(/, end: /\)/ },
					{ beginKeywords: "new throw return else", end: /;/ },
				],
				keywords: P,
				contains: U.concat([
					{ begin: /\(/, end: /\)/, keywords: P, contains: U.concat(["self"]), relevance: 0 },
				]),
				relevance: 0,
			},
			ne = {
				className: "function",
				begin: "(" + s + "[\\*&\\s]+)+" + x,
				returnBegin: !0,
				end: /[{;=]/,
				excludeEnd: !0,
				keywords: P,
				illegal: /[^\w\s\*&:<>.]/,
				contains: [
					{ begin: n, keywords: P, relevance: 0 },
					{ begin: x, returnBegin: !0, contains: [v], relevance: 0 },
					{ begin: /::/, relevance: 0 },
					{ begin: /:/, endsWithParent: !0, contains: [d, p] },
					{ relevance: 0, match: /,/ },
					{
						className: "params",
						begin: /\(/,
						end: /\)/,
						keywords: P,
						relevance: 0,
						contains: [
							t,
							r.C_BLOCK_COMMENT_MODE,
							d,
							p,
							l,
							{
								begin: /\(/,
								end: /\)/,
								keywords: P,
								relevance: 0,
								contains: ["self", t, r.C_BLOCK_COMMENT_MODE, d, p, l],
							},
						],
					},
					l,
					t,
					r.C_BLOCK_COMMENT_MODE,
					f,
				],
			};
		return {
			name: "C++",
			aliases: ["cc", "c++", "h++", "hpp", "hh", "hxx", "cxx"],
			keywords: P,
			illegal: "</",
			classNameAliases: { "function.dispatch": "built_in" },
			contains: [].concat(Q, ne, q, U, [
				f,
				{
					begin:
						"\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function|flat_map|flat_set)\\s*<(?!<)",
					end: ">",
					keywords: P,
					contains: ["self", l],
				},
				{ begin: r.IDENT_RE + "::", keywords: P },
				{
					match: [/\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/, /\s+/, /\w+/],
					className: { 1: "keyword", 3: "title.class" },
				},
			]),
		};
	}
	function ec(r) {
		const e = r.regex,
			t = r.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }),
			n = "decltype\\(auto\\)",
			a = "[a-zA-Z_]\\w*::",
			s = "(" + n + "|" + e.optional(a) + "[a-zA-Z_]\\w*" + e.optional("<[^<>]+>") + ")",
			l = {
				className: "type",
				variants: [{ begin: "\\b[a-z\\d_]*_t\\b" }, { match: /\batomic_[a-z]{3,6}\b/ }],
			},
			d = {
				className: "string",
				variants: [
					{ begin: '(u8?|U|L)?"', end: '"', illegal: "\\n", contains: [r.BACKSLASH_ESCAPE] },
					{
						begin: "(u8?|U|L)?'(" + "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)" + "|.)",
						end: "'",
						illegal: ".",
					},
					r.END_SAME_AS_BEGIN({
						begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
						end: /\)([^()\\ ]{0,16})"/,
					}),
				],
			},
			p = {
				className: "number",
				variants: [
					{ match: /\b(0b[01']+)/ },
					{
						match:
							/(-?)\b([\d']+(\.[\d']*)?|\.[\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)/,
					},
					{
						match:
							/(-?)\b(0[xX][a-fA-F0-9]+(?:'[a-fA-F0-9]+)*(?:\.[a-fA-F0-9]*(?:'[a-fA-F0-9]*)*)?(?:[pP][-+]?[0-9]+)?(l|L)?(u|U)?)/,
					},
					{ match: /(-?)\b\d+(?:'\d+)*(?:\.\d*(?:'\d*)*)?(?:[eE][-+]?\d+)?/ },
				],
				relevance: 0,
			},
			f = {
				className: "meta",
				begin: /#\s*[a-z]+\b/,
				end: /$/,
				keywords: {
					keyword:
						"if else elif endif define undef warning error line pragma _Pragma ifdef ifndef elifdef elifndef include",
				},
				contains: [
					{ begin: /\\\n/, relevance: 0 },
					r.inherit(d, { className: "string" }),
					{ className: "string", begin: /<.*?>/ },
					t,
					r.C_BLOCK_COMMENT_MODE,
				],
			},
			v = { className: "title", begin: e.optional(a) + r.IDENT_RE, relevance: 0 },
			x = e.optional(a) + r.IDENT_RE + "\\s*\\(",
			M = {
				keyword: [
					"asm",
					"auto",
					"break",
					"case",
					"continue",
					"default",
					"do",
					"else",
					"enum",
					"extern",
					"for",
					"fortran",
					"goto",
					"if",
					"inline",
					"register",
					"restrict",
					"return",
					"sizeof",
					"typeof",
					"typeof_unqual",
					"struct",
					"switch",
					"typedef",
					"union",
					"volatile",
					"while",
					"_Alignas",
					"_Alignof",
					"_Atomic",
					"_Generic",
					"_Noreturn",
					"_Static_assert",
					"_Thread_local",
					"alignas",
					"alignof",
					"noreturn",
					"static_assert",
					"thread_local",
					"_Pragma",
				],
				type: [
					"float",
					"double",
					"signed",
					"unsigned",
					"int",
					"short",
					"long",
					"char",
					"void",
					"_Bool",
					"_BitInt",
					"_Complex",
					"_Imaginary",
					"_Decimal32",
					"_Decimal64",
					"_Decimal96",
					"_Decimal128",
					"_Decimal64x",
					"_Decimal128x",
					"_Float16",
					"_Float32",
					"_Float64",
					"_Float128",
					"_Float32x",
					"_Float64x",
					"_Float128x",
					"const",
					"static",
					"constexpr",
					"complex",
					"bool",
					"imaginary",
				],
				literal: "true false NULL",
				built_in:
					"std string wstring cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set pair bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap priority_queue make_pair array shared_ptr abort terminate abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf future isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr",
			},
			O = [f, l, t, r.C_BLOCK_COMMENT_MODE, p, d],
			I = {
				variants: [
					{ begin: /=/, end: /;/ },
					{ begin: /\(/, end: /\)/ },
					{ beginKeywords: "new throw return else", end: /;/ },
				],
				keywords: M,
				contains: O.concat([
					{ begin: /\(/, end: /\)/, keywords: M, contains: O.concat(["self"]), relevance: 0 },
				]),
				relevance: 0,
			},
			$ = {
				begin: "(" + s + "[\\*&\\s]+)+" + x,
				returnBegin: !0,
				end: /[{;=]/,
				excludeEnd: !0,
				keywords: M,
				illegal: /[^\w\s\*&:<>.]/,
				contains: [
					{ begin: n, keywords: M, relevance: 0 },
					{
						begin: x,
						returnBegin: !0,
						contains: [r.inherit(v, { className: "title.function" })],
						relevance: 0,
					},
					{ relevance: 0, match: /,/ },
					{
						className: "params",
						begin: /\(/,
						end: /\)/,
						keywords: M,
						relevance: 0,
						contains: [
							t,
							r.C_BLOCK_COMMENT_MODE,
							d,
							p,
							l,
							{
								begin: /\(/,
								end: /\)/,
								keywords: M,
								relevance: 0,
								contains: ["self", t, r.C_BLOCK_COMMENT_MODE, d, p, l],
							},
						],
					},
					l,
					t,
					r.C_BLOCK_COMMENT_MODE,
					f,
				],
			};
		return {
			name: "C",
			aliases: ["h"],
			keywords: M,
			disableAutodetect: !0,
			illegal: "</",
			contains: [].concat(I, $, O, [
				f,
				{ begin: r.IDENT_RE + "::", keywords: M },
				{
					className: "class",
					beginKeywords: "enum class struct union",
					end: /[{;:<>=]/,
					contains: [{ beginKeywords: "final class struct" }, r.TITLE_MODE],
				},
			]),
			exports: { preprocessor: f, strings: d, keywords: M },
		};
	}
	function Oi(r) {
		const e = r.regex,
			t = e.concat(/[\p{L}_]/u, e.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u),
			n = /[\p{L}0-9._:-]+/u,
			a = { className: "symbol", begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/ },
			i = {
				begin: /\s/,
				contains: [{ className: "keyword", begin: /#?[a-z_][a-z1-9_-]+/, illegal: /\n/ }],
			},
			s = r.inherit(i, { begin: /\(/, end: /\)/ }),
			l = r.inherit(r.APOS_STRING_MODE, { className: "string" }),
			u = r.inherit(r.QUOTE_STRING_MODE, { className: "string" }),
			d = {
				endsWithParent: !0,
				illegal: /</,
				relevance: 0,
				contains: [
					{ className: "attr", begin: n, relevance: 0 },
					{
						begin: /=\s*/,
						relevance: 0,
						contains: [
							{
								className: "string",
								endsParent: !0,
								variants: [
									{ begin: /"/, end: /"/, contains: [a] },
									{ begin: /'/, end: /'/, contains: [a] },
									{ begin: /[^\s"'=<>`]+/ },
								],
							},
						],
					},
				],
			};
		return {
			name: "HTML, XML",
			aliases: ["html", "xhtml", "rss", "atom", "xjb", "xsd", "xsl", "plist", "wsf", "svg"],
			case_insensitive: !0,
			unicodeRegex: !0,
			contains: [
				{
					className: "meta",
					begin: /<![a-z]/,
					end: />/,
					relevance: 10,
					contains: [
						i,
						u,
						l,
						s,
						{
							begin: /\[/,
							end: /\]/,
							contains: [{ className: "meta", begin: /<![a-z]/, end: />/, contains: [i, s, u, l] }],
						},
					],
				},
				r.COMMENT(/<!--/, /-->/, { relevance: 10 }),
				{ begin: /<!\[CDATA\[/, end: /\]\]>/, relevance: 10 },
				a,
				{
					className: "meta",
					end: /\?>/,
					variants: [
						{ begin: /<\?xml/, relevance: 10, contains: [u] },
						{ begin: /<\?[a-z][a-z0-9]+/ },
					],
				},
				{
					className: "tag",
					begin: /<style(?=\s|>)/,
					end: />/,
					keywords: { name: "style" },
					contains: [d],
					starts: { end: /<\/style>/, returnEnd: !0, subLanguage: ["css", "xml"] },
				},
				{
					className: "tag",
					begin: /<script(?=\s|>)/,
					end: />/,
					keywords: { name: "script" },
					contains: [d],
					starts: {
						end: /<\/script>/,
						returnEnd: !0,
						subLanguage: ["javascript", "handlebars", "xml"],
					},
				},
				{ className: "tag", begin: /<>|<\/>/ },
				{
					className: "tag",
					begin: e.concat(/</, e.lookahead(e.concat(t, e.either(/\/>/, />/, /\s/)))),
					end: /\/?>/,
					contains: [{ className: "name", begin: t, relevance: 0, starts: d }],
				},
				{
					className: "tag",
					begin: e.concat(/<\//, e.lookahead(e.concat(t, />/))),
					contains: [
						{ className: "name", begin: t, relevance: 0 },
						{ begin: />/, relevance: 0, endsParent: !0 },
					],
				},
			],
		};
	}
	const tc = (r) => ({
			IMPORTANT: { scope: "meta", begin: "!important" },
			BLOCK_COMMENT: r.C_BLOCK_COMMENT_MODE,
			HEXCOLOR: { scope: "number", begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/ },
			FUNCTION_DISPATCH: { className: "built_in", begin: /[\w-]+(?=\()/ },
			ATTRIBUTE_SELECTOR_MODE: {
				scope: "selector-attr",
				begin: /\[/,
				end: /\]/,
				illegal: "$",
				contains: [r.APOS_STRING_MODE, r.QUOTE_STRING_MODE],
			},
			CSS_NUMBER_MODE: {
				scope: "number",
				begin:
					r.NUMBER_RE +
					"(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
				relevance: 0,
			},
			CSS_VARIABLE: { className: "attr", begin: /--[A-Za-z_][A-Za-z0-9_-]*/ },
		}),
		rc = [
			"a",
			"abbr",
			"address",
			"article",
			"aside",
			"audio",
			"b",
			"blockquote",
			"body",
			"button",
			"canvas",
			"caption",
			"cite",
			"code",
			"dd",
			"del",
			"details",
			"dfn",
			"div",
			"dl",
			"dt",
			"em",
			"fieldset",
			"figcaption",
			"figure",
			"footer",
			"form",
			"h1",
			"h2",
			"h3",
			"h4",
			"h5",
			"h6",
			"header",
			"hgroup",
			"html",
			"i",
			"iframe",
			"img",
			"input",
			"ins",
			"kbd",
			"label",
			"legend",
			"li",
			"main",
			"mark",
			"menu",
			"nav",
			"object",
			"ol",
			"optgroup",
			"option",
			"p",
			"picture",
			"q",
			"quote",
			"samp",
			"section",
			"select",
			"source",
			"span",
			"strong",
			"summary",
			"sup",
			"table",
			"tbody",
			"td",
			"textarea",
			"tfoot",
			"th",
			"thead",
			"time",
			"tr",
			"ul",
			"var",
			"video",
		],
		nc = [
			"defs",
			"g",
			"marker",
			"mask",
			"pattern",
			"svg",
			"switch",
			"symbol",
			"feBlend",
			"feColorMatrix",
			"feComponentTransfer",
			"feComposite",
			"feConvolveMatrix",
			"feDiffuseLighting",
			"feDisplacementMap",
			"feFlood",
			"feGaussianBlur",
			"feImage",
			"feMerge",
			"feMorphology",
			"feOffset",
			"feSpecularLighting",
			"feTile",
			"feTurbulence",
			"linearGradient",
			"radialGradient",
			"stop",
			"circle",
			"ellipse",
			"image",
			"line",
			"path",
			"polygon",
			"polyline",
			"rect",
			"text",
			"use",
			"textPath",
			"tspan",
			"foreignObject",
			"clipPath",
		],
		ac = [...rc, ...nc],
		ic = [
			"any-hover",
			"any-pointer",
			"aspect-ratio",
			"color",
			"color-gamut",
			"color-index",
			"device-aspect-ratio",
			"device-height",
			"device-width",
			"display-mode",
			"forced-colors",
			"grid",
			"height",
			"hover",
			"inverted-colors",
			"monochrome",
			"orientation",
			"overflow-block",
			"overflow-inline",
			"pointer",
			"prefers-color-scheme",
			"prefers-contrast",
			"prefers-reduced-motion",
			"prefers-reduced-transparency",
			"resolution",
			"scan",
			"scripting",
			"update",
			"width",
			"min-width",
			"max-width",
			"min-height",
			"max-height",
		]
			.sort()
			.reverse(),
		sc = [
			"active",
			"any-link",
			"blank",
			"checked",
			"current",
			"default",
			"defined",
			"dir",
			"disabled",
			"drop",
			"empty",
			"enabled",
			"first",
			"first-child",
			"first-of-type",
			"fullscreen",
			"future",
			"focus",
			"focus-visible",
			"focus-within",
			"has",
			"host",
			"host-context",
			"hover",
			"indeterminate",
			"in-range",
			"invalid",
			"is",
			"lang",
			"last-child",
			"last-of-type",
			"left",
			"link",
			"local-link",
			"not",
			"nth-child",
			"nth-col",
			"nth-last-child",
			"nth-last-col",
			"nth-last-of-type",
			"nth-of-type",
			"only-child",
			"only-of-type",
			"optional",
			"out-of-range",
			"past",
			"placeholder-shown",
			"read-only",
			"read-write",
			"required",
			"right",
			"root",
			"scope",
			"target",
			"target-within",
			"user-invalid",
			"valid",
			"visited",
			"where",
		]
			.sort()
			.reverse(),
		oc = [
			"after",
			"backdrop",
			"before",
			"cue",
			"cue-region",
			"first-letter",
			"first-line",
			"grammar-error",
			"marker",
			"part",
			"placeholder",
			"selection",
			"slotted",
			"spelling-error",
		]
			.sort()
			.reverse(),
		lc = [
			"accent-color",
			"align-content",
			"align-items",
			"align-self",
			"alignment-baseline",
			"all",
			"anchor-name",
			"animation",
			"animation-composition",
			"animation-delay",
			"animation-direction",
			"animation-duration",
			"animation-fill-mode",
			"animation-iteration-count",
			"animation-name",
			"animation-play-state",
			"animation-range",
			"animation-range-end",
			"animation-range-start",
			"animation-timeline",
			"animation-timing-function",
			"appearance",
			"aspect-ratio",
			"backdrop-filter",
			"backface-visibility",
			"background",
			"background-attachment",
			"background-blend-mode",
			"background-clip",
			"background-color",
			"background-image",
			"background-origin",
			"background-position",
			"background-position-x",
			"background-position-y",
			"background-repeat",
			"background-size",
			"baseline-shift",
			"block-size",
			"border",
			"border-block",
			"border-block-color",
			"border-block-end",
			"border-block-end-color",
			"border-block-end-style",
			"border-block-end-width",
			"border-block-start",
			"border-block-start-color",
			"border-block-start-style",
			"border-block-start-width",
			"border-block-style",
			"border-block-width",
			"border-bottom",
			"border-bottom-color",
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-bottom-style",
			"border-bottom-width",
			"border-collapse",
			"border-color",
			"border-end-end-radius",
			"border-end-start-radius",
			"border-image",
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width",
			"border-inline",
			"border-inline-color",
			"border-inline-end",
			"border-inline-end-color",
			"border-inline-end-style",
			"border-inline-end-width",
			"border-inline-start",
			"border-inline-start-color",
			"border-inline-start-style",
			"border-inline-start-width",
			"border-inline-style",
			"border-inline-width",
			"border-left",
			"border-left-color",
			"border-left-style",
			"border-left-width",
			"border-radius",
			"border-right",
			"border-right-color",
			"border-right-style",
			"border-right-width",
			"border-spacing",
			"border-start-end-radius",
			"border-start-start-radius",
			"border-style",
			"border-top",
			"border-top-color",
			"border-top-left-radius",
			"border-top-right-radius",
			"border-top-style",
			"border-top-width",
			"border-width",
			"bottom",
			"box-align",
			"box-decoration-break",
			"box-direction",
			"box-flex",
			"box-flex-group",
			"box-lines",
			"box-ordinal-group",
			"box-orient",
			"box-pack",
			"box-shadow",
			"box-sizing",
			"break-after",
			"break-before",
			"break-inside",
			"caption-side",
			"caret-color",
			"clear",
			"clip",
			"clip-path",
			"clip-rule",
			"color",
			"color-interpolation",
			"color-interpolation-filters",
			"color-profile",
			"color-rendering",
			"color-scheme",
			"column-count",
			"column-fill",
			"column-gap",
			"column-rule",
			"column-rule-color",
			"column-rule-style",
			"column-rule-width",
			"column-span",
			"column-width",
			"columns",
			"contain",
			"contain-intrinsic-block-size",
			"contain-intrinsic-height",
			"contain-intrinsic-inline-size",
			"contain-intrinsic-size",
			"contain-intrinsic-width",
			"container",
			"container-name",
			"container-type",
			"content",
			"content-visibility",
			"counter-increment",
			"counter-reset",
			"counter-set",
			"cue",
			"cue-after",
			"cue-before",
			"cursor",
			"cx",
			"cy",
			"direction",
			"display",
			"dominant-baseline",
			"empty-cells",
			"enable-background",
			"field-sizing",
			"fill",
			"fill-opacity",
			"fill-rule",
			"filter",
			"flex",
			"flex-basis",
			"flex-direction",
			"flex-flow",
			"flex-grow",
			"flex-shrink",
			"flex-wrap",
			"float",
			"flood-color",
			"flood-opacity",
			"flow",
			"font",
			"font-display",
			"font-family",
			"font-feature-settings",
			"font-kerning",
			"font-language-override",
			"font-optical-sizing",
			"font-palette",
			"font-size",
			"font-size-adjust",
			"font-smooth",
			"font-smoothing",
			"font-stretch",
			"font-style",
			"font-synthesis",
			"font-synthesis-position",
			"font-synthesis-small-caps",
			"font-synthesis-style",
			"font-synthesis-weight",
			"font-variant",
			"font-variant-alternates",
			"font-variant-caps",
			"font-variant-east-asian",
			"font-variant-emoji",
			"font-variant-ligatures",
			"font-variant-numeric",
			"font-variant-position",
			"font-variation-settings",
			"font-weight",
			"forced-color-adjust",
			"gap",
			"glyph-orientation-horizontal",
			"glyph-orientation-vertical",
			"grid",
			"grid-area",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-auto-rows",
			"grid-column",
			"grid-column-end",
			"grid-column-start",
			"grid-gap",
			"grid-row",
			"grid-row-end",
			"grid-row-start",
			"grid-template",
			"grid-template-areas",
			"grid-template-columns",
			"grid-template-rows",
			"hanging-punctuation",
			"height",
			"hyphenate-character",
			"hyphenate-limit-chars",
			"hyphens",
			"icon",
			"image-orientation",
			"image-rendering",
			"image-resolution",
			"ime-mode",
			"initial-letter",
			"initial-letter-align",
			"inline-size",
			"inset",
			"inset-area",
			"inset-block",
			"inset-block-end",
			"inset-block-start",
			"inset-inline",
			"inset-inline-end",
			"inset-inline-start",
			"isolation",
			"justify-content",
			"justify-items",
			"justify-self",
			"kerning",
			"left",
			"letter-spacing",
			"lighting-color",
			"line-break",
			"line-height",
			"line-height-step",
			"list-style",
			"list-style-image",
			"list-style-position",
			"list-style-type",
			"margin",
			"margin-block",
			"margin-block-end",
			"margin-block-start",
			"margin-bottom",
			"margin-inline",
			"margin-inline-end",
			"margin-inline-start",
			"margin-left",
			"margin-right",
			"margin-top",
			"margin-trim",
			"marker",
			"marker-end",
			"marker-mid",
			"marker-start",
			"marks",
			"mask",
			"mask-border",
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width",
			"mask-clip",
			"mask-composite",
			"mask-image",
			"mask-mode",
			"mask-origin",
			"mask-position",
			"mask-repeat",
			"mask-size",
			"mask-type",
			"masonry-auto-flow",
			"math-depth",
			"math-shift",
			"math-style",
			"max-block-size",
			"max-height",
			"max-inline-size",
			"max-width",
			"min-block-size",
			"min-height",
			"min-inline-size",
			"min-width",
			"mix-blend-mode",
			"nav-down",
			"nav-index",
			"nav-left",
			"nav-right",
			"nav-up",
			"none",
			"normal",
			"object-fit",
			"object-position",
			"offset",
			"offset-anchor",
			"offset-distance",
			"offset-path",
			"offset-position",
			"offset-rotate",
			"opacity",
			"order",
			"orphans",
			"outline",
			"outline-color",
			"outline-offset",
			"outline-style",
			"outline-width",
			"overflow",
			"overflow-anchor",
			"overflow-block",
			"overflow-clip-margin",
			"overflow-inline",
			"overflow-wrap",
			"overflow-x",
			"overflow-y",
			"overlay",
			"overscroll-behavior",
			"overscroll-behavior-block",
			"overscroll-behavior-inline",
			"overscroll-behavior-x",
			"overscroll-behavior-y",
			"padding",
			"padding-block",
			"padding-block-end",
			"padding-block-start",
			"padding-bottom",
			"padding-inline",
			"padding-inline-end",
			"padding-inline-start",
			"padding-left",
			"padding-right",
			"padding-top",
			"page",
			"page-break-after",
			"page-break-before",
			"page-break-inside",
			"paint-order",
			"pause",
			"pause-after",
			"pause-before",
			"perspective",
			"perspective-origin",
			"place-content",
			"place-items",
			"place-self",
			"pointer-events",
			"position",
			"position-anchor",
			"position-visibility",
			"print-color-adjust",
			"quotes",
			"r",
			"resize",
			"rest",
			"rest-after",
			"rest-before",
			"right",
			"rotate",
			"row-gap",
			"ruby-align",
			"ruby-position",
			"scale",
			"scroll-behavior",
			"scroll-margin",
			"scroll-margin-block",
			"scroll-margin-block-end",
			"scroll-margin-block-start",
			"scroll-margin-bottom",
			"scroll-margin-inline",
			"scroll-margin-inline-end",
			"scroll-margin-inline-start",
			"scroll-margin-left",
			"scroll-margin-right",
			"scroll-margin-top",
			"scroll-padding",
			"scroll-padding-block",
			"scroll-padding-block-end",
			"scroll-padding-block-start",
			"scroll-padding-bottom",
			"scroll-padding-inline",
			"scroll-padding-inline-end",
			"scroll-padding-inline-start",
			"scroll-padding-left",
			"scroll-padding-right",
			"scroll-padding-top",
			"scroll-snap-align",
			"scroll-snap-stop",
			"scroll-snap-type",
			"scroll-timeline",
			"scroll-timeline-axis",
			"scroll-timeline-name",
			"scrollbar-color",
			"scrollbar-gutter",
			"scrollbar-width",
			"shape-image-threshold",
			"shape-margin",
			"shape-outside",
			"shape-rendering",
			"speak",
			"speak-as",
			"src",
			"stop-color",
			"stop-opacity",
			"stroke",
			"stroke-dasharray",
			"stroke-dashoffset",
			"stroke-linecap",
			"stroke-linejoin",
			"stroke-miterlimit",
			"stroke-opacity",
			"stroke-width",
			"tab-size",
			"table-layout",
			"text-align",
			"text-align-all",
			"text-align-last",
			"text-anchor",
			"text-combine-upright",
			"text-decoration",
			"text-decoration-color",
			"text-decoration-line",
			"text-decoration-skip",
			"text-decoration-skip-ink",
			"text-decoration-style",
			"text-decoration-thickness",
			"text-emphasis",
			"text-emphasis-color",
			"text-emphasis-position",
			"text-emphasis-style",
			"text-indent",
			"text-justify",
			"text-orientation",
			"text-overflow",
			"text-rendering",
			"text-shadow",
			"text-size-adjust",
			"text-transform",
			"text-underline-offset",
			"text-underline-position",
			"text-wrap",
			"text-wrap-mode",
			"text-wrap-style",
			"timeline-scope",
			"top",
			"touch-action",
			"transform",
			"transform-box",
			"transform-origin",
			"transform-style",
			"transition",
			"transition-behavior",
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function",
			"translate",
			"unicode-bidi",
			"user-modify",
			"user-select",
			"vector-effect",
			"vertical-align",
			"view-timeline",
			"view-timeline-axis",
			"view-timeline-inset",
			"view-timeline-name",
			"view-transition-name",
			"visibility",
			"voice-balance",
			"voice-duration",
			"voice-family",
			"voice-pitch",
			"voice-range",
			"voice-rate",
			"voice-stress",
			"voice-volume",
			"white-space",
			"white-space-collapse",
			"widows",
			"width",
			"will-change",
			"word-break",
			"word-spacing",
			"word-wrap",
			"writing-mode",
			"x",
			"y",
			"z-index",
			"zoom",
		]
			.sort()
			.reverse();
	function cc(r) {
		const e = r.regex,
			t = tc(r),
			n = { begin: /-(webkit|moz|ms|o)-(?=[a-z])/ },
			a = "and or not only",
			i = /@-?\w[\w]*(-\w+)*/,
			s = "[a-zA-Z-][a-zA-Z0-9_-]*",
			l = [r.APOS_STRING_MODE, r.QUOTE_STRING_MODE];
		return {
			name: "CSS",
			case_insensitive: !0,
			illegal: /[=|'\$]/,
			keywords: { keyframePosition: "from to" },
			classNameAliases: { keyframePosition: "selector-tag" },
			contains: [
				t.BLOCK_COMMENT,
				n,
				t.CSS_NUMBER_MODE,
				{ className: "selector-id", begin: /#[A-Za-z0-9_-]+/, relevance: 0 },
				{ className: "selector-class", begin: "\\." + s, relevance: 0 },
				t.ATTRIBUTE_SELECTOR_MODE,
				{
					className: "selector-pseudo",
					variants: [
						{ begin: ":(" + sc.join("|") + ")" },
						{ begin: ":(:)?(" + oc.join("|") + ")" },
					],
				},
				t.CSS_VARIABLE,
				{ className: "attribute", begin: "\\b(" + lc.join("|") + ")\\b" },
				{
					begin: /:/,
					end: /[;}{]/,
					contains: [
						t.BLOCK_COMMENT,
						t.HEXCOLOR,
						t.IMPORTANT,
						t.CSS_NUMBER_MODE,
						...l,
						{
							begin: /(url|data-uri)\(/,
							end: /\)/,
							relevance: 0,
							keywords: { built_in: "url data-uri" },
							contains: [
								...l,
								{ className: "string", begin: /[^)]/, endsWithParent: !0, excludeEnd: !0 },
							],
						},
						t.FUNCTION_DISPATCH,
					],
				},
				{
					begin: e.lookahead(/@/),
					end: "[{;]",
					relevance: 0,
					illegal: /:/,
					contains: [
						{ className: "keyword", begin: i },
						{
							begin: /\s/,
							endsWithParent: !0,
							excludeEnd: !0,
							relevance: 0,
							keywords: { $pattern: /[a-z-]+/, keyword: a, attribute: ic.join(" ") },
							contains: [
								{ begin: /[a-z-]+(?=:)/, className: "attribute" },
								...l,
								t.CSS_NUMBER_MODE,
							],
						},
					],
				},
				{ className: "selector-tag", begin: "\\b(" + ac.join("|") + ")\\b" },
			],
		};
	}
	const uc = (r) => ({
			IMPORTANT: { scope: "meta", begin: "!important" },
			BLOCK_COMMENT: r.C_BLOCK_COMMENT_MODE,
			HEXCOLOR: { scope: "number", begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/ },
			FUNCTION_DISPATCH: { className: "built_in", begin: /[\w-]+(?=\()/ },
			ATTRIBUTE_SELECTOR_MODE: {
				scope: "selector-attr",
				begin: /\[/,
				end: /\]/,
				illegal: "$",
				contains: [r.APOS_STRING_MODE, r.QUOTE_STRING_MODE],
			},
			CSS_NUMBER_MODE: {
				scope: "number",
				begin:
					r.NUMBER_RE +
					"(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
				relevance: 0,
			},
			CSS_VARIABLE: { className: "attr", begin: /--[A-Za-z_][A-Za-z0-9_-]*/ },
		}),
		hc = [
			"a",
			"abbr",
			"address",
			"article",
			"aside",
			"audio",
			"b",
			"blockquote",
			"body",
			"button",
			"canvas",
			"caption",
			"cite",
			"code",
			"dd",
			"del",
			"details",
			"dfn",
			"div",
			"dl",
			"dt",
			"em",
			"fieldset",
			"figcaption",
			"figure",
			"footer",
			"form",
			"h1",
			"h2",
			"h3",
			"h4",
			"h5",
			"h6",
			"header",
			"hgroup",
			"html",
			"i",
			"iframe",
			"img",
			"input",
			"ins",
			"kbd",
			"label",
			"legend",
			"li",
			"main",
			"mark",
			"menu",
			"nav",
			"object",
			"ol",
			"optgroup",
			"option",
			"p",
			"picture",
			"q",
			"quote",
			"samp",
			"section",
			"select",
			"source",
			"span",
			"strong",
			"summary",
			"sup",
			"table",
			"tbody",
			"td",
			"textarea",
			"tfoot",
			"th",
			"thead",
			"time",
			"tr",
			"ul",
			"var",
			"video",
		],
		dc = [
			"defs",
			"g",
			"marker",
			"mask",
			"pattern",
			"svg",
			"switch",
			"symbol",
			"feBlend",
			"feColorMatrix",
			"feComponentTransfer",
			"feComposite",
			"feConvolveMatrix",
			"feDiffuseLighting",
			"feDisplacementMap",
			"feFlood",
			"feGaussianBlur",
			"feImage",
			"feMerge",
			"feMorphology",
			"feOffset",
			"feSpecularLighting",
			"feTile",
			"feTurbulence",
			"linearGradient",
			"radialGradient",
			"stop",
			"circle",
			"ellipse",
			"image",
			"line",
			"path",
			"polygon",
			"polyline",
			"rect",
			"text",
			"use",
			"textPath",
			"tspan",
			"foreignObject",
			"clipPath",
		],
		mc = [...hc, ...dc],
		pc = [
			"any-hover",
			"any-pointer",
			"aspect-ratio",
			"color",
			"color-gamut",
			"color-index",
			"device-aspect-ratio",
			"device-height",
			"device-width",
			"display-mode",
			"forced-colors",
			"grid",
			"height",
			"hover",
			"inverted-colors",
			"monochrome",
			"orientation",
			"overflow-block",
			"overflow-inline",
			"pointer",
			"prefers-color-scheme",
			"prefers-contrast",
			"prefers-reduced-motion",
			"prefers-reduced-transparency",
			"resolution",
			"scan",
			"scripting",
			"update",
			"width",
			"min-width",
			"max-width",
			"min-height",
			"max-height",
		]
			.sort()
			.reverse(),
		fc = [
			"active",
			"any-link",
			"blank",
			"checked",
			"current",
			"default",
			"defined",
			"dir",
			"disabled",
			"drop",
			"empty",
			"enabled",
			"first",
			"first-child",
			"first-of-type",
			"fullscreen",
			"future",
			"focus",
			"focus-visible",
			"focus-within",
			"has",
			"host",
			"host-context",
			"hover",
			"indeterminate",
			"in-range",
			"invalid",
			"is",
			"lang",
			"last-child",
			"last-of-type",
			"left",
			"link",
			"local-link",
			"not",
			"nth-child",
			"nth-col",
			"nth-last-child",
			"nth-last-col",
			"nth-last-of-type",
			"nth-of-type",
			"only-child",
			"only-of-type",
			"optional",
			"out-of-range",
			"past",
			"placeholder-shown",
			"read-only",
			"read-write",
			"required",
			"right",
			"root",
			"scope",
			"target",
			"target-within",
			"user-invalid",
			"valid",
			"visited",
			"where",
		]
			.sort()
			.reverse(),
		gc = [
			"after",
			"backdrop",
			"before",
			"cue",
			"cue-region",
			"first-letter",
			"first-line",
			"grammar-error",
			"marker",
			"part",
			"placeholder",
			"selection",
			"slotted",
			"spelling-error",
		]
			.sort()
			.reverse(),
		bc = [
			"accent-color",
			"align-content",
			"align-items",
			"align-self",
			"alignment-baseline",
			"all",
			"anchor-name",
			"animation",
			"animation-composition",
			"animation-delay",
			"animation-direction",
			"animation-duration",
			"animation-fill-mode",
			"animation-iteration-count",
			"animation-name",
			"animation-play-state",
			"animation-range",
			"animation-range-end",
			"animation-range-start",
			"animation-timeline",
			"animation-timing-function",
			"appearance",
			"aspect-ratio",
			"backdrop-filter",
			"backface-visibility",
			"background",
			"background-attachment",
			"background-blend-mode",
			"background-clip",
			"background-color",
			"background-image",
			"background-origin",
			"background-position",
			"background-position-x",
			"background-position-y",
			"background-repeat",
			"background-size",
			"baseline-shift",
			"block-size",
			"border",
			"border-block",
			"border-block-color",
			"border-block-end",
			"border-block-end-color",
			"border-block-end-style",
			"border-block-end-width",
			"border-block-start",
			"border-block-start-color",
			"border-block-start-style",
			"border-block-start-width",
			"border-block-style",
			"border-block-width",
			"border-bottom",
			"border-bottom-color",
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-bottom-style",
			"border-bottom-width",
			"border-collapse",
			"border-color",
			"border-end-end-radius",
			"border-end-start-radius",
			"border-image",
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width",
			"border-inline",
			"border-inline-color",
			"border-inline-end",
			"border-inline-end-color",
			"border-inline-end-style",
			"border-inline-end-width",
			"border-inline-start",
			"border-inline-start-color",
			"border-inline-start-style",
			"border-inline-start-width",
			"border-inline-style",
			"border-inline-width",
			"border-left",
			"border-left-color",
			"border-left-style",
			"border-left-width",
			"border-radius",
			"border-right",
			"border-right-color",
			"border-right-style",
			"border-right-width",
			"border-spacing",
			"border-start-end-radius",
			"border-start-start-radius",
			"border-style",
			"border-top",
			"border-top-color",
			"border-top-left-radius",
			"border-top-right-radius",
			"border-top-style",
			"border-top-width",
			"border-width",
			"bottom",
			"box-align",
			"box-decoration-break",
			"box-direction",
			"box-flex",
			"box-flex-group",
			"box-lines",
			"box-ordinal-group",
			"box-orient",
			"box-pack",
			"box-shadow",
			"box-sizing",
			"break-after",
			"break-before",
			"break-inside",
			"caption-side",
			"caret-color",
			"clear",
			"clip",
			"clip-path",
			"clip-rule",
			"color",
			"color-interpolation",
			"color-interpolation-filters",
			"color-profile",
			"color-rendering",
			"color-scheme",
			"column-count",
			"column-fill",
			"column-gap",
			"column-rule",
			"column-rule-color",
			"column-rule-style",
			"column-rule-width",
			"column-span",
			"column-width",
			"columns",
			"contain",
			"contain-intrinsic-block-size",
			"contain-intrinsic-height",
			"contain-intrinsic-inline-size",
			"contain-intrinsic-size",
			"contain-intrinsic-width",
			"container",
			"container-name",
			"container-type",
			"content",
			"content-visibility",
			"counter-increment",
			"counter-reset",
			"counter-set",
			"cue",
			"cue-after",
			"cue-before",
			"cursor",
			"cx",
			"cy",
			"direction",
			"display",
			"dominant-baseline",
			"empty-cells",
			"enable-background",
			"field-sizing",
			"fill",
			"fill-opacity",
			"fill-rule",
			"filter",
			"flex",
			"flex-basis",
			"flex-direction",
			"flex-flow",
			"flex-grow",
			"flex-shrink",
			"flex-wrap",
			"float",
			"flood-color",
			"flood-opacity",
			"flow",
			"font",
			"font-display",
			"font-family",
			"font-feature-settings",
			"font-kerning",
			"font-language-override",
			"font-optical-sizing",
			"font-palette",
			"font-size",
			"font-size-adjust",
			"font-smooth",
			"font-smoothing",
			"font-stretch",
			"font-style",
			"font-synthesis",
			"font-synthesis-position",
			"font-synthesis-small-caps",
			"font-synthesis-style",
			"font-synthesis-weight",
			"font-variant",
			"font-variant-alternates",
			"font-variant-caps",
			"font-variant-east-asian",
			"font-variant-emoji",
			"font-variant-ligatures",
			"font-variant-numeric",
			"font-variant-position",
			"font-variation-settings",
			"font-weight",
			"forced-color-adjust",
			"gap",
			"glyph-orientation-horizontal",
			"glyph-orientation-vertical",
			"grid",
			"grid-area",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-auto-rows",
			"grid-column",
			"grid-column-end",
			"grid-column-start",
			"grid-gap",
			"grid-row",
			"grid-row-end",
			"grid-row-start",
			"grid-template",
			"grid-template-areas",
			"grid-template-columns",
			"grid-template-rows",
			"hanging-punctuation",
			"height",
			"hyphenate-character",
			"hyphenate-limit-chars",
			"hyphens",
			"icon",
			"image-orientation",
			"image-rendering",
			"image-resolution",
			"ime-mode",
			"initial-letter",
			"initial-letter-align",
			"inline-size",
			"inset",
			"inset-area",
			"inset-block",
			"inset-block-end",
			"inset-block-start",
			"inset-inline",
			"inset-inline-end",
			"inset-inline-start",
			"isolation",
			"justify-content",
			"justify-items",
			"justify-self",
			"kerning",
			"left",
			"letter-spacing",
			"lighting-color",
			"line-break",
			"line-height",
			"line-height-step",
			"list-style",
			"list-style-image",
			"list-style-position",
			"list-style-type",
			"margin",
			"margin-block",
			"margin-block-end",
			"margin-block-start",
			"margin-bottom",
			"margin-inline",
			"margin-inline-end",
			"margin-inline-start",
			"margin-left",
			"margin-right",
			"margin-top",
			"margin-trim",
			"marker",
			"marker-end",
			"marker-mid",
			"marker-start",
			"marks",
			"mask",
			"mask-border",
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width",
			"mask-clip",
			"mask-composite",
			"mask-image",
			"mask-mode",
			"mask-origin",
			"mask-position",
			"mask-repeat",
			"mask-size",
			"mask-type",
			"masonry-auto-flow",
			"math-depth",
			"math-shift",
			"math-style",
			"max-block-size",
			"max-height",
			"max-inline-size",
			"max-width",
			"min-block-size",
			"min-height",
			"min-inline-size",
			"min-width",
			"mix-blend-mode",
			"nav-down",
			"nav-index",
			"nav-left",
			"nav-right",
			"nav-up",
			"none",
			"normal",
			"object-fit",
			"object-position",
			"offset",
			"offset-anchor",
			"offset-distance",
			"offset-path",
			"offset-position",
			"offset-rotate",
			"opacity",
			"order",
			"orphans",
			"outline",
			"outline-color",
			"outline-offset",
			"outline-style",
			"outline-width",
			"overflow",
			"overflow-anchor",
			"overflow-block",
			"overflow-clip-margin",
			"overflow-inline",
			"overflow-wrap",
			"overflow-x",
			"overflow-y",
			"overlay",
			"overscroll-behavior",
			"overscroll-behavior-block",
			"overscroll-behavior-inline",
			"overscroll-behavior-x",
			"overscroll-behavior-y",
			"padding",
			"padding-block",
			"padding-block-end",
			"padding-block-start",
			"padding-bottom",
			"padding-inline",
			"padding-inline-end",
			"padding-inline-start",
			"padding-left",
			"padding-right",
			"padding-top",
			"page",
			"page-break-after",
			"page-break-before",
			"page-break-inside",
			"paint-order",
			"pause",
			"pause-after",
			"pause-before",
			"perspective",
			"perspective-origin",
			"place-content",
			"place-items",
			"place-self",
			"pointer-events",
			"position",
			"position-anchor",
			"position-visibility",
			"print-color-adjust",
			"quotes",
			"r",
			"resize",
			"rest",
			"rest-after",
			"rest-before",
			"right",
			"rotate",
			"row-gap",
			"ruby-align",
			"ruby-position",
			"scale",
			"scroll-behavior",
			"scroll-margin",
			"scroll-margin-block",
			"scroll-margin-block-end",
			"scroll-margin-block-start",
			"scroll-margin-bottom",
			"scroll-margin-inline",
			"scroll-margin-inline-end",
			"scroll-margin-inline-start",
			"scroll-margin-left",
			"scroll-margin-right",
			"scroll-margin-top",
			"scroll-padding",
			"scroll-padding-block",
			"scroll-padding-block-end",
			"scroll-padding-block-start",
			"scroll-padding-bottom",
			"scroll-padding-inline",
			"scroll-padding-inline-end",
			"scroll-padding-inline-start",
			"scroll-padding-left",
			"scroll-padding-right",
			"scroll-padding-top",
			"scroll-snap-align",
			"scroll-snap-stop",
			"scroll-snap-type",
			"scroll-timeline",
			"scroll-timeline-axis",
			"scroll-timeline-name",
			"scrollbar-color",
			"scrollbar-gutter",
			"scrollbar-width",
			"shape-image-threshold",
			"shape-margin",
			"shape-outside",
			"shape-rendering",
			"speak",
			"speak-as",
			"src",
			"stop-color",
			"stop-opacity",
			"stroke",
			"stroke-dasharray",
			"stroke-dashoffset",
			"stroke-linecap",
			"stroke-linejoin",
			"stroke-miterlimit",
			"stroke-opacity",
			"stroke-width",
			"tab-size",
			"table-layout",
			"text-align",
			"text-align-all",
			"text-align-last",
			"text-anchor",
			"text-combine-upright",
			"text-decoration",
			"text-decoration-color",
			"text-decoration-line",
			"text-decoration-skip",
			"text-decoration-skip-ink",
			"text-decoration-style",
			"text-decoration-thickness",
			"text-emphasis",
			"text-emphasis-color",
			"text-emphasis-position",
			"text-emphasis-style",
			"text-indent",
			"text-justify",
			"text-orientation",
			"text-overflow",
			"text-rendering",
			"text-shadow",
			"text-size-adjust",
			"text-transform",
			"text-underline-offset",
			"text-underline-position",
			"text-wrap",
			"text-wrap-mode",
			"text-wrap-style",
			"timeline-scope",
			"top",
			"touch-action",
			"transform",
			"transform-box",
			"transform-origin",
			"transform-style",
			"transition",
			"transition-behavior",
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function",
			"translate",
			"unicode-bidi",
			"user-modify",
			"user-select",
			"vector-effect",
			"vertical-align",
			"view-timeline",
			"view-timeline-axis",
			"view-timeline-inset",
			"view-timeline-name",
			"view-transition-name",
			"visibility",
			"voice-balance",
			"voice-duration",
			"voice-family",
			"voice-pitch",
			"voice-range",
			"voice-rate",
			"voice-stress",
			"voice-volume",
			"white-space",
			"white-space-collapse",
			"widows",
			"width",
			"will-change",
			"word-break",
			"word-spacing",
			"word-wrap",
			"writing-mode",
			"x",
			"y",
			"z-index",
			"zoom",
		]
			.sort()
			.reverse();
	function vc(r) {
		const e = uc(r),
			t = gc,
			n = fc,
			a = "@[a-z-]+",
			i = "and or not only",
			l = {
				className: "variable",
				begin: "(\\$" + "[a-zA-Z-][a-zA-Z0-9_-]*" + ")\\b",
				relevance: 0,
			};
		return {
			name: "SCSS",
			case_insensitive: !0,
			illegal: "[=/|']",
			contains: [
				r.C_LINE_COMMENT_MODE,
				r.C_BLOCK_COMMENT_MODE,
				e.CSS_NUMBER_MODE,
				{ className: "selector-id", begin: "#[A-Za-z0-9_-]+", relevance: 0 },
				{ className: "selector-class", begin: "\\.[A-Za-z0-9_-]+", relevance: 0 },
				e.ATTRIBUTE_SELECTOR_MODE,
				{ className: "selector-tag", begin: "\\b(" + mc.join("|") + ")\\b", relevance: 0 },
				{ className: "selector-pseudo", begin: ":(" + n.join("|") + ")" },
				{ className: "selector-pseudo", begin: ":(:)?(" + t.join("|") + ")" },
				l,
				{ begin: /\(/, end: /\)/, contains: [e.CSS_NUMBER_MODE] },
				e.CSS_VARIABLE,
				{ className: "attribute", begin: "\\b(" + bc.join("|") + ")\\b" },
				{
					begin:
						"\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b",
				},
				{
					begin: /:/,
					end: /[;}{]/,
					relevance: 0,
					contains: [
						e.BLOCK_COMMENT,
						l,
						e.HEXCOLOR,
						e.CSS_NUMBER_MODE,
						r.QUOTE_STRING_MODE,
						r.APOS_STRING_MODE,
						e.IMPORTANT,
						e.FUNCTION_DISPATCH,
					],
				},
				{ begin: "@(page|font-face)", keywords: { $pattern: a, keyword: "@page @font-face" } },
				{
					begin: "@",
					end: "[{;]",
					returnBegin: !0,
					keywords: { $pattern: /[a-z-]+/, keyword: i, attribute: pc.join(" ") },
					contains: [
						{ begin: a, className: "keyword" },
						{ begin: /[a-z-]+(?=:)/, className: "attribute" },
						l,
						r.QUOTE_STRING_MODE,
						r.APOS_STRING_MODE,
						e.HEXCOLOR,
						e.CSS_NUMBER_MODE,
					],
				},
				e.FUNCTION_DISPATCH,
			],
		};
	}
	function yc(r) {
		const e = r.regex,
			t = { begin: /<\/?[A-Za-z_]/, end: ">", subLanguage: "xml", relevance: 0 },
			n = { begin: "^[-\\*]{3,}", end: "$" },
			a = {
				className: "code",
				variants: [
					{ begin: "(`{3,})[^`](.|\\n)*?\\1`*[ ]*" },
					{ begin: "(~{3,})[^~](.|\\n)*?\\1~*[ ]*" },
					{ begin: "```", end: "```+[ ]*$" },
					{ begin: "~~~", end: "~~~+[ ]*$" },
					{ begin: "`.+?`" },
					{
						begin: "(?=^( {4}|\\t))",
						contains: [{ begin: "^( {4}|\\t)", end: "(\\n)$" }],
						relevance: 0,
					},
				],
			},
			i = {
				className: "bullet",
				begin: "^[ 	]*([*+-]|(\\d+\\.))(?=\\s+)",
				end: "\\s+",
				excludeEnd: !0,
			},
			s = {
				begin: /^\[[^\n]+\]:/,
				returnBegin: !0,
				contains: [
					{ className: "symbol", begin: /\[/, end: /\]/, excludeBegin: !0, excludeEnd: !0 },
					{ className: "link", begin: /:\s*/, end: /$/, excludeBegin: !0 },
				],
			},
			l = /[A-Za-z][A-Za-z0-9+.-]*/,
			u = {
				variants: [
					{ begin: /\[.+?\]\[.*?\]/, relevance: 0 },
					{ begin: /\[.+?\]\(((data|javascript|mailto):|(?:http|ftp)s?:\/\/).*?\)/, relevance: 2 },
					{ begin: e.concat(/\[.+?\]\(/, l, /:\/\/.*?\)/), relevance: 2 },
					{ begin: /\[.+?\]\([./?&#].*?\)/, relevance: 1 },
					{ begin: /\[.*?\]\(.*?\)/, relevance: 0 },
				],
				returnBegin: !0,
				contains: [
					{ match: /\[(?=\])/ },
					{
						className: "string",
						relevance: 0,
						begin: "\\[",
						end: "\\]",
						excludeBegin: !0,
						returnEnd: !0,
					},
					{
						className: "link",
						relevance: 0,
						begin: "\\]\\(",
						end: "\\)",
						excludeBegin: !0,
						excludeEnd: !0,
					},
					{
						className: "symbol",
						relevance: 0,
						begin: "\\]\\[",
						end: "\\]",
						excludeBegin: !0,
						excludeEnd: !0,
					},
				],
			},
			d = {
				className: "strong",
				contains: [],
				variants: [
					{ begin: /_{2}(?!\s)/, end: /_{2}/ },
					{ begin: /\*{2}(?!\s)/, end: /\*{2}/ },
				],
			},
			p = {
				className: "emphasis",
				contains: [],
				variants: [
					{ begin: /\*(?![*\s])/, end: /\*/ },
					{ begin: /_(?![_\s])/, end: /_/, relevance: 0 },
				],
			},
			f = r.inherit(d, { contains: [] }),
			v = r.inherit(p, { contains: [] });
		d.contains.push(v), p.contains.push(f);
		let x = [t, u];
		return (
			[d, p, f, v].forEach((O) => {
				O.contains = O.contains.concat(x);
			}),
			(x = x.concat(d, p)),
			{
				name: "Markdown",
				aliases: ["md", "mkdown", "mkd"],
				contains: [
					{
						className: "section",
						variants: [
							{ begin: "^#{1,6}", end: "$", contains: x },
							{
								begin: "(?=^.+?\\n[=-]{2,}$)",
								contains: [{ begin: "^[=-]*$" }, { begin: "^", end: "\\n", contains: x }],
							},
						],
					},
					t,
					i,
					d,
					p,
					{ className: "quote", begin: "^>\\s+", contains: x, end: "$" },
					a,
					n,
					u,
					s,
					{ scope: "literal", match: /&([a-zA-Z0-9]+|#[0-9]{1,7}|#[Xx][0-9a-fA-F]{1,6});/ },
				],
			}
		);
	}
	function xc(r) {
		const e = "true false yes no null",
			t = "[\\w#;/?:@&=+$,.~*'()[\\]]+",
			n = {
				className: "attr",
				variants: [
					{ begin: /[\w*@][\w*@ :()\./-]*:(?=[ \t]|$)/ },
					{ begin: /"[\w*@][\w*@ :()\./-]*":(?=[ \t]|$)/ },
					{ begin: /'[\w*@][\w*@ :()\./-]*':(?=[ \t]|$)/ },
				],
			},
			a = {
				className: "template-variable",
				variants: [
					{ begin: /\{\{/, end: /\}\}/ },
					{ begin: /%\{/, end: /\}/ },
				],
			},
			i = {
				className: "string",
				relevance: 0,
				begin: /'/,
				end: /'/,
				contains: [{ match: /''/, scope: "char.escape", relevance: 0 }],
			},
			s = {
				className: "string",
				relevance: 0,
				variants: [{ begin: /"/, end: /"/ }, { begin: /\S+/ }],
				contains: [r.BACKSLASH_ESCAPE, a],
			},
			l = r.inherit(s, {
				variants: [
					{ begin: /'/, end: /'/, contains: [{ begin: /''/, relevance: 0 }] },
					{ begin: /"/, end: /"/ },
					{ begin: /[^\s,{}[\]]+/ },
				],
			}),
			v = {
				className: "number",
				begin:
					"\\b" +
					"[0-9]{4}(-[0-9][0-9]){0,2}" +
					"([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?" +
					"(\\.[0-9]*)?" +
					"([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?" +
					"\\b",
			},
			x = { end: ",", endsWithParent: !0, excludeEnd: !0, keywords: e, relevance: 0 },
			_ = { begin: /\{/, end: /\}/, contains: [x], illegal: "\\n", relevance: 0 },
			S = { begin: "\\[", end: "\\]", contains: [x], illegal: "\\n", relevance: 0 },
			M = [
				n,
				{ className: "meta", begin: "^---\\s*$", relevance: 10 },
				{
					className: "string",
					begin: "[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*",
				},
				{
					begin: "<%[%=-]?",
					end: "[%-]?%>",
					subLanguage: "ruby",
					excludeBegin: !0,
					excludeEnd: !0,
					relevance: 0,
				},
				{ className: "type", begin: "!\\w+!" + t },
				{ className: "type", begin: "!<" + t + ">" },
				{ className: "type", begin: "!" + t },
				{ className: "type", begin: "!!" + t },
				{ className: "meta", begin: "&" + r.UNDERSCORE_IDENT_RE + "$" },
				{ className: "meta", begin: "\\*" + r.UNDERSCORE_IDENT_RE + "$" },
				{ className: "bullet", begin: "-(?=[ ]|$)", relevance: 0 },
				r.HASH_COMMENT_MODE,
				{ beginKeywords: e, keywords: { literal: e } },
				v,
				{ className: "number", begin: r.C_NUMBER_RE + "\\b", relevance: 0 },
				_,
				S,
				i,
				s,
			],
			O = [...M];
		return (
			O.pop(),
			O.push(l),
			(x.contains = O),
			{ name: "YAML", case_insensitive: !0, aliases: ["yml"], contains: M }
		);
	}
	function wc(r) {
		const e = r.regex,
			t = r.COMMENT("--", "$"),
			n = { scope: "string", variants: [{ begin: /'/, end: /'/, contains: [{ match: /''/ }] }] },
			a = { begin: /"/, end: /"/, contains: [{ match: /""/ }] },
			i = ["true", "false", "unknown"],
			s = ["double precision", "large object", "with timezone", "without timezone"],
			l = [
				"bigint",
				"binary",
				"blob",
				"boolean",
				"char",
				"character",
				"clob",
				"date",
				"dec",
				"decfloat",
				"decimal",
				"float",
				"int",
				"integer",
				"interval",
				"nchar",
				"nclob",
				"national",
				"numeric",
				"real",
				"row",
				"smallint",
				"time",
				"timestamp",
				"varchar",
				"varying",
				"varbinary",
			],
			u = ["add", "asc", "collation", "desc", "final", "first", "last", "view"],
			d = [
				"abs",
				"acos",
				"all",
				"allocate",
				"alter",
				"and",
				"any",
				"are",
				"array",
				"array_agg",
				"array_max_cardinality",
				"as",
				"asensitive",
				"asin",
				"asymmetric",
				"at",
				"atan",
				"atomic",
				"authorization",
				"avg",
				"begin",
				"begin_frame",
				"begin_partition",
				"between",
				"bigint",
				"binary",
				"blob",
				"boolean",
				"both",
				"by",
				"call",
				"called",
				"cardinality",
				"cascaded",
				"case",
				"cast",
				"ceil",
				"ceiling",
				"char",
				"char_length",
				"character",
				"character_length",
				"check",
				"classifier",
				"clob",
				"close",
				"coalesce",
				"collate",
				"collect",
				"column",
				"commit",
				"condition",
				"connect",
				"constraint",
				"contains",
				"convert",
				"copy",
				"corr",
				"corresponding",
				"cos",
				"cosh",
				"count",
				"covar_pop",
				"covar_samp",
				"create",
				"cross",
				"cube",
				"cume_dist",
				"current",
				"current_catalog",
				"current_date",
				"current_default_transform_group",
				"current_path",
				"current_role",
				"current_row",
				"current_schema",
				"current_time",
				"current_timestamp",
				"current_path",
				"current_role",
				"current_transform_group_for_type",
				"current_user",
				"cursor",
				"cycle",
				"date",
				"day",
				"deallocate",
				"dec",
				"decimal",
				"decfloat",
				"declare",
				"default",
				"define",
				"delete",
				"dense_rank",
				"deref",
				"describe",
				"deterministic",
				"disconnect",
				"distinct",
				"double",
				"drop",
				"dynamic",
				"each",
				"element",
				"else",
				"empty",
				"end",
				"end_frame",
				"end_partition",
				"end-exec",
				"equals",
				"escape",
				"every",
				"except",
				"exec",
				"execute",
				"exists",
				"exp",
				"external",
				"extract",
				"false",
				"fetch",
				"filter",
				"first_value",
				"float",
				"floor",
				"for",
				"foreign",
				"frame_row",
				"free",
				"from",
				"full",
				"function",
				"fusion",
				"get",
				"global",
				"grant",
				"group",
				"grouping",
				"groups",
				"having",
				"hold",
				"hour",
				"identity",
				"in",
				"indicator",
				"initial",
				"inner",
				"inout",
				"insensitive",
				"insert",
				"int",
				"integer",
				"intersect",
				"intersection",
				"interval",
				"into",
				"is",
				"join",
				"json_array",
				"json_arrayagg",
				"json_exists",
				"json_object",
				"json_objectagg",
				"json_query",
				"json_table",
				"json_table_primitive",
				"json_value",
				"lag",
				"language",
				"large",
				"last_value",
				"lateral",
				"lead",
				"leading",
				"left",
				"like",
				"like_regex",
				"listagg",
				"ln",
				"local",
				"localtime",
				"localtimestamp",
				"log",
				"log10",
				"lower",
				"match",
				"match_number",
				"match_recognize",
				"matches",
				"max",
				"member",
				"merge",
				"method",
				"min",
				"minute",
				"mod",
				"modifies",
				"module",
				"month",
				"multiset",
				"national",
				"natural",
				"nchar",
				"nclob",
				"new",
				"no",
				"none",
				"normalize",
				"not",
				"nth_value",
				"ntile",
				"null",
				"nullif",
				"numeric",
				"octet_length",
				"occurrences_regex",
				"of",
				"offset",
				"old",
				"omit",
				"on",
				"one",
				"only",
				"open",
				"or",
				"order",
				"out",
				"outer",
				"over",
				"overlaps",
				"overlay",
				"parameter",
				"partition",
				"pattern",
				"per",
				"percent",
				"percent_rank",
				"percentile_cont",
				"percentile_disc",
				"period",
				"portion",
				"position",
				"position_regex",
				"power",
				"precedes",
				"precision",
				"prepare",
				"primary",
				"procedure",
				"ptf",
				"range",
				"rank",
				"reads",
				"real",
				"recursive",
				"ref",
				"references",
				"referencing",
				"regr_avgx",
				"regr_avgy",
				"regr_count",
				"regr_intercept",
				"regr_r2",
				"regr_slope",
				"regr_sxx",
				"regr_sxy",
				"regr_syy",
				"release",
				"result",
				"return",
				"returns",
				"revoke",
				"right",
				"rollback",
				"rollup",
				"row",
				"row_number",
				"rows",
				"running",
				"savepoint",
				"scope",
				"scroll",
				"search",
				"second",
				"seek",
				"select",
				"sensitive",
				"session_user",
				"set",
				"show",
				"similar",
				"sin",
				"sinh",
				"skip",
				"smallint",
				"some",
				"specific",
				"specifictype",
				"sql",
				"sqlexception",
				"sqlstate",
				"sqlwarning",
				"sqrt",
				"start",
				"static",
				"stddev_pop",
				"stddev_samp",
				"submultiset",
				"subset",
				"substring",
				"substring_regex",
				"succeeds",
				"sum",
				"symmetric",
				"system",
				"system_time",
				"system_user",
				"table",
				"tablesample",
				"tan",
				"tanh",
				"then",
				"time",
				"timestamp",
				"timezone_hour",
				"timezone_minute",
				"to",
				"trailing",
				"translate",
				"translate_regex",
				"translation",
				"treat",
				"trigger",
				"trim",
				"trim_array",
				"true",
				"truncate",
				"uescape",
				"union",
				"unique",
				"unknown",
				"unnest",
				"update",
				"upper",
				"user",
				"using",
				"value",
				"values",
				"value_of",
				"var_pop",
				"var_samp",
				"varbinary",
				"varchar",
				"varying",
				"versioning",
				"when",
				"whenever",
				"where",
				"width_bucket",
				"window",
				"with",
				"within",
				"without",
				"year",
			],
			p = [
				"abs",
				"acos",
				"array_agg",
				"asin",
				"atan",
				"avg",
				"cast",
				"ceil",
				"ceiling",
				"coalesce",
				"corr",
				"cos",
				"cosh",
				"count",
				"covar_pop",
				"covar_samp",
				"cume_dist",
				"dense_rank",
				"deref",
				"element",
				"exp",
				"extract",
				"first_value",
				"floor",
				"json_array",
				"json_arrayagg",
				"json_exists",
				"json_object",
				"json_objectagg",
				"json_query",
				"json_table",
				"json_table_primitive",
				"json_value",
				"lag",
				"last_value",
				"lead",
				"listagg",
				"ln",
				"log",
				"log10",
				"lower",
				"max",
				"min",
				"mod",
				"nth_value",
				"ntile",
				"nullif",
				"percent_rank",
				"percentile_cont",
				"percentile_disc",
				"position",
				"position_regex",
				"power",
				"rank",
				"regr_avgx",
				"regr_avgy",
				"regr_count",
				"regr_intercept",
				"regr_r2",
				"regr_slope",
				"regr_sxx",
				"regr_sxy",
				"regr_syy",
				"row_number",
				"sin",
				"sinh",
				"sqrt",
				"stddev_pop",
				"stddev_samp",
				"substring",
				"substring_regex",
				"sum",
				"tan",
				"tanh",
				"translate",
				"translate_regex",
				"treat",
				"trim",
				"trim_array",
				"unnest",
				"upper",
				"value_of",
				"var_pop",
				"var_samp",
				"width_bucket",
			],
			f = [
				"current_catalog",
				"current_date",
				"current_default_transform_group",
				"current_path",
				"current_role",
				"current_schema",
				"current_transform_group_for_type",
				"current_user",
				"session_user",
				"system_time",
				"system_user",
				"current_time",
				"localtime",
				"current_timestamp",
				"localtimestamp",
			],
			v = [
				"create table",
				"insert into",
				"primary key",
				"foreign key",
				"not null",
				"alter table",
				"add constraint",
				"grouping sets",
				"on overflow",
				"character set",
				"respect nulls",
				"ignore nulls",
				"nulls first",
				"nulls last",
				"depth first",
				"breadth first",
			],
			x = p,
			_ = [...d, ...u].filter((q) => !p.includes(q)),
			S = { scope: "variable", match: /@[a-z0-9][a-z0-9_]*/ },
			M = {
				scope: "operator",
				match: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/,
				relevance: 0,
			},
			O = {
				match: e.concat(/\b/, e.either(...x), /\s*\(/),
				relevance: 0,
				keywords: { built_in: x },
			};
		function I(q) {
			return e.concat(/\b/, e.either(...q.map((U) => U.replace(/\s+/, "\\s+"))), /\b/);
		}
		const $ = { scope: "keyword", match: I(v), relevance: 0 };
		function P(q, { exceptions: U, when: Q } = {}) {
			const ne = Q;
			return (
				(U = U || []),
				q.map((te) => (te.match(/\|\d+$/) || U.includes(te) ? te : ne(te) ? `${te}|0` : te))
			);
		}
		return {
			name: "SQL",
			case_insensitive: !0,
			illegal: /[{}]|<\//,
			keywords: {
				$pattern: /\b[\w\.]+/,
				keyword: P(_, { when: (q) => q.length < 3 }),
				literal: i,
				type: l,
				built_in: f,
			},
			contains: [
				{ scope: "type", match: I(s) },
				$,
				O,
				S,
				n,
				a,
				r.C_NUMBER_MODE,
				r.C_BLOCK_COMMENT_MODE,
				t,
				M,
			],
		};
	}
	function kc(r) {
		return { name: "Plain text", aliases: ["text", "txt"], disableAutodetect: !0 };
	}
	const _c = /(!?\[)([^\]]*?)$/,
		Sc = /(\*\*)([^*]*?)$/,
		Ec = /(__)([^_]*?)$/,
		Tc = /(\*\*\*)([^*]*?)$/,
		Mc = /(\*)([^*]*?)$/,
		Ac = /(_)([^_]*?)$/,
		Nc = /(`)([^`]*?)$/,
		Oc = /(~~)([^~]*?)$/,
		fr = (r) => {
			const e = (r.match(/```/g) || []).length;
			return (
				e > 0 &&
				e % 2 === 0 &&
				r.includes(`
`)
			);
		},
		gr = (r) => {
			let e = -1,
				t = !1;
			for (const n of r.matchAll(/```/g)) {
				const a = n.index ?? -1;
				a !== -1 && (t ? ((t = !1), (e = -1)) : ((t = !0), (e = a)));
			}
			return e;
		},
		zc = (r) => {
			const e = /(!?)\[([^\]]+)\]\(([^)]+)$/,
				t = r.match(e);
			if (t) {
				const a = t[1] === "!",
					i = t[2],
					s = t[3],
					l = r.lastIndexOf(`${a ? "!" : ""}[${i}](${s}`),
					u = r.substring(0, l);
				return a ? u : `${u}[${i}](streamdown:incomplete-link)`;
			}
			const n = r.match(_c);
			if (n) {
				if (n[1].startsWith("!")) {
					const i = r.lastIndexOf(n[1]);
					return r.substring(0, i);
				}
				return `${r}](streamdown:incomplete-link)`;
			}
			return r;
		},
		Cc = (r) => {
			if (fr(r)) return r;
			const e = r.match(Sc);
			if (e) {
				const t = e[2];
				if (!t || /^[\s_~*`]*$/.test(t)) return r;
				const n = r.lastIndexOf(e[1]),
					a = gr(r);
				if (a !== -1 && n > a) return r;
				const s = r.substring(0, n).lastIndexOf(`
`),
					l = s === -1 ? 0 : s + 1,
					u = r.substring(l, n);
				if (
					/^[\s]*[-*+][\s]+$/.test(u) &&
					t.includes(`
`)
				)
					return r;
				if ((r.match(/\*\*/g) || []).length % 2 === 1) return `${r}**`;
			}
			return r;
		},
		Rc = (r) => {
			if (fr(r)) return r;
			const e = r.match(Ec);
			if (e) {
				const t = e[2];
				if (!t || /^[\s_~*`]*$/.test(t)) return r;
				const n = r.lastIndexOf(e[1]),
					a = gr(r);
				if (a !== -1 && n > a) return r;
				const s = r.substring(0, n).lastIndexOf(`
`),
					l = s === -1 ? 0 : s + 1,
					u = r.substring(l, n);
				if (
					/^[\s]*[-*+][\s]+$/.test(u) &&
					t.includes(`
`)
				)
					return r;
				if ((r.match(/__/g) || []).length % 2 === 1) return `${r}__`;
			}
			return r;
		},
		Ic = (r) =>
			r.split("").reduce((e, t, n) => {
				if (t === "*") {
					const a = r[n - 1],
						i = r[n + 1];
					if (a === "\\") return e;
					let s = n;
					for (let u = n - 1; u >= 0; u--) {
						if (
							r[u] ===
							`
`
						) {
							s = u + 1;
							break;
						}
						if (u === 0) {
							s = 0;
							break;
						}
					}
					if (r.substring(s, n).trim() === "" && (i === " " || i === "	")) return e;
					if (a !== "*" && i !== "*") return e + 1;
				}
				return e;
			}, 0),
		Dc = (r) => {
			if (fr(r)) return r;
			if (r.match(Mc)) {
				let t = -1;
				for (let s = 0; s < r.length; s++)
					if (r[s] === "*" && r[s - 1] !== "*" && r[s + 1] !== "*") {
						t = s;
						break;
					}
				if (t === -1) return r;
				const n = gr(r);
				if (n !== -1 && t > n) return r;
				const a = r.substring(t + 1);
				if (!a || /^[\s_~*`]*$/.test(a)) return r;
				if (Ic(r) % 2 === 1) return `${r}*`;
			}
			return r;
		},
		zi = (r, e) => {
			let t = !1,
				n = !1;
			for (let a = 0; a < r.length && a < e; a++) {
				if (r[a] === "\\" && r[a + 1] === "$") {
					a++;
					continue;
				}
				r[a] === "$" && (r[a + 1] === "$" ? ((n = !n), a++, (t = !1)) : n || (t = !t));
			}
			return t || n;
		},
		Bc = (r) =>
			r.split("").reduce((e, t, n) => {
				if (t === "_") {
					const a = r[n - 1],
						i = r[n + 1];
					if (
						a === "\\" ||
						zi(r, n) ||
						(a && i && /[\p{L}\p{N}_]/u.test(a) && /[\p{L}\p{N}_]/u.test(i))
					)
						return e;
					if (a !== "_" && i !== "_") return e + 1;
				}
				return e;
			}, 0),
		Lc = (r) => {
			if (fr(r)) return r;
			if (r.match(Ac)) {
				let t = -1;
				for (let s = 0; s < r.length; s++)
					if (
						r[s] === "_" &&
						r[s - 1] !== "_" &&
						r[s + 1] !== "_" &&
						r[s - 1] !== "\\" &&
						!zi(r, s)
					) {
						const l = s > 0 ? r[s - 1] : "",
							u = s < r.length - 1 ? r[s + 1] : "";
						if (l && u && /[\p{L}\p{N}_]/u.test(l) && /[\p{L}\p{N}_]/u.test(u)) continue;
						t = s;
						break;
					}
				if (t === -1) return r;
				const n = gr(r);
				if (n !== -1 && t > n) return r;
				const a = r.substring(t + 1);
				if (!a || /^[\s_~*`]*$/.test(a)) return r;
				if (Bc(r) % 2 === 1) {
					const s = r.match(/\n+$/);
					return s ? `${r.slice(0, -s[0].length)}_${s[0]}` : `${r}_`;
				}
			}
			return r;
		},
		$c = (r, e) => {
			const t = r.substring(e, e + 3) === "```",
				n = e > 0 && r.substring(e - 1, e + 2) === "```",
				a = e > 1 && r.substring(e - 2, e + 1) === "```";
			return t || n || a;
		},
		qc = (r) => {
			let e = 0;
			for (let t = 0; t < r.length; t++) r[t] === "`" && !$c(r, t) && e++;
			return e;
		},
		Pc = (r) => {
			if (
				r.match(/^```[^`\n]*```?$/) &&
				!r.includes(`
`)
			)
				return r.endsWith("``") && !r.endsWith("```") ? `${r}\`` : r;
			const t = (r.match(/```/g) || []).length,
				n = t % 2 === 1;
			if (
				(t > 0 &&
					t % 2 === 0 &&
					r.includes(`
`)) ||
				((r.endsWith("```\n") || r.endsWith("```")) && t % 2 === 0)
			)
				return r;
			const a = r.match(Nc);
			if (a && !n) {
				const i = a[2];
				if (!i || /^[\s_~*`]*$/.test(i)) return r;
				if (qc(r) % 2 === 1) return `${r}\``;
			}
			return r;
		},
		Fc = (r) => {
			const e = r.match(Oc);
			if (e) {
				const t = e[2];
				if (!t || /^[\s_~*`]*$/.test(t)) return r;
				if ((r.match(/~~/g) || []).length % 2 === 1) return `${r}~~`;
			}
			return r;
		},
		Hc = (r) => {
			if ((r.match(/\$\$/g) || []).length % 2 === 0) return r;
			const t = r.indexOf("$$");
			return t !== -1 &&
				r.indexOf(
					`
`,
					t
				) !== -1 &&
				!r.endsWith(`
`)
				? `${r}
$$`
				: `${r}$$`;
		},
		Uc = (r) => {
			let e = 0;
			const t = r.match(/\*+/g) || [];
			for (const n of t) {
				const a = n.length;
				a >= 3 && (e += Math.floor(a / 3));
			}
			return e;
		},
		Gc = (r) => {
			if (fr(r) || /^\*{4,}$/.test(r)) return r;
			const e = r.match(Tc);
			if (e) {
				const t = e[2];
				if (!t || /^[\s_~*`]*$/.test(t)) return r;
				const n = r.lastIndexOf(e[1]),
					a = gr(r);
				if (a !== -1 && n > a) return r;
				if (Uc(r) % 2 === 1) return `${r}***`;
			}
			return r;
		},
		Kc = (r) => {
			if (!r || typeof r != "string") return r;
			let e = r;
			const t = zc(e);
			return t.endsWith("](streamdown:incomplete-link)")
				? t
				: ((e = t),
					(e = Gc(e)),
					(e = Cc(e)),
					(e = Rc(e)),
					(e = Dc(e)),
					(e = Lc(e)),
					(e = Pc(e)),
					(e = Fc(e)),
					(e = Hc(e)),
					e);
		};
	function Vc(r) {
		const e = /\[\^[^\]\s]{1,200}\](?!:)/.test(r),
			t = /\[\^[^\]\s]{1,200}\]:/.test(r);
		if (e || t) return [r];
		const n = it.lex(r, { gfm: !0 }),
			a = [],
			i = [];
		for (let s = 0; s < n.length; s++) {
			const l = n[s],
				u = l.raw;
			if (i.length > 0) {
				if (((a[a.length - 1] += u), l.type === "html")) {
					const d = u.match(/<\/(\w+)>/);
					if (d) {
						const p = d[1];
						i[i.length - 1] === p && i.pop();
					}
				}
				continue;
			}
			if (l.type === "html" && l.block) {
				const d = u.match(/<(\w+)[\s>]/);
				if (d) {
					const p = d[1];
					u.includes(`</${p}>`) || i.push(p);
				}
			}
			if (u.trim() === "$$" && a.length > 0) {
				const d = a.at(-1);
				if (!d) {
					a.push(u);
					continue;
				}
				const p = d.trimStart().startsWith("$$"),
					f = (d.match(/\$\$/g) || []).length;
				if (p && f % 2 === 1) {
					a[a.length - 1] = d + u;
					continue;
				}
			}
			if (a.length > 0 && u.trimEnd().endsWith("$$")) {
				const d = a.at(-1);
				if (!d) {
					a.push(u);
					continue;
				}
				const p = d.trimStart().startsWith("$$"),
					f = (d.match(/\$\$/g) || []).length,
					v = (u.match(/\$\$/g) || []).length;
				if (p && f % 2 === 1 && !u.trimStart().startsWith("$$") && v === 1) {
					a[a.length - 1] = d + u;
					continue;
				}
			}
			a.push(u);
		}
		return a;
	}
	[
		["javascript", Hl],
		["typescript", Gl],
		["json", Kl],
		["bash", Vl],
		["shell", Wl],
		["python", Zl],
		["go", Xl],
		["rust", Yl],
		["java", Ql],
		["csharp", Jl],
		["cpp", jl],
		["c", ec],
		["xml", Oi],
		["html", Oi],
		["css", cc],
		["scss", vc],
		["markdown", yc],
		["yaml", xc],
		["sql", wc],
		["plaintext", kc],
	].forEach(([r, e]) => Jr.registerLanguage(r, e));
	const Wc = {
			name: "katexBlock",
			level: "block",
			start(r) {
				const e = r.match(/(\${2}|\\\[)/);
				return e ? e.index : -1;
			},
			tokenizer(r) {
				const t = /^\${2}([\s\S]+?)\${2}/.exec(r);
				if (t) return { type: "katexBlock", raw: t[0], text: t[1].trim(), displayMode: !0 };
				const a = /^\\\[([\s\S]+?)\\\]/.exec(r);
				if (a) return { type: "katexBlock", raw: a[0], text: a[1].trim(), displayMode: !0 };
			},
			renderer(r) {
				if (r.type === "katexBlock")
					return cr.renderToString(r.text, { throwOnError: !1, displayMode: r.displayMode });
			},
		},
		Zc = {
			name: "katexInline",
			level: "inline",
			start(r) {
				const e = r.match(/(\$|\\\()/);
				return e ? e.index : -1;
			},
			tokenizer(r) {
				const t = /^\$([^$]+?)\$/.exec(r);
				if (t) return { type: "katexInline", raw: t[0], text: t[1].trim(), displayMode: !1 };
				const a = /^\\\(([\s\S]+?)\\\)/.exec(r);
				if (a) return { type: "katexInline", raw: a[0], text: a[1].trim(), displayMode: !1 };
			},
			renderer(r) {
				if (r.type === "katexInline")
					return cr.renderToString(r.text, { throwOnError: !1, displayMode: r.displayMode });
			},
		};
	function Ci(r) {
		return r.replace(
			/[<>&"']/g,
			(e) => ({ "<": "&lt;", ">": "&gt;", "&": "&amp;", "'": "&#39;", '"': "&quot;" })[e] || e
		);
	}
	function Xc(r, e = []) {
		const t = "color: rgb(59, 130, 246); text-decoration: none; hover:text-decoration: underline;";
		return r.replace(/\[(\d+)\]/g, (n) => {
			const i = (n.match(/\d+/g) || [])
				.map(Number)
				.map((s) => {
					if (s === 0) return !1;
					const l = e[s - 1];
					return l
						? `<a href="${l.link}" target="_blank" rel="noreferrer" style="${t}">${s}</a>`
						: "";
				})
				.filter(Boolean)
				.join(", ");
			return i ? ` <sup>${i}</sup>` : n;
		});
	}
	function Yc(r) {
		if (!r) return;
		const e = r.trim(),
			t = e.toLowerCase();
		if (!(t.startsWith("javascript:") || t.startsWith("data:text/html")))
			return e.replace(/>$/, "");
	}
	function Qc(r, e) {
		if (e && Jr.getLanguage(e))
			try {
				return Jr.highlight(r, { language: e, ignoreIllegals: !0 }).value;
			} catch {}
		return Jr.highlightAuto(r).value;
	}
	function Jc(r) {
		return new fi({
			hooks: { postprocess: (e) => Xc(e, r) },
			extensions: [Wc, Zc],
			renderer: {
				link: (e, t, n) => {
					const a = Yc(e);
					return a
						? `<a href="${a}" target="_blank" rel="noreferrer">${n}</a>`
						: `<span>${Ci(n ?? "")}</span>`;
				},
				html: (e) => Ci(e),
			},
			gfm: !0,
			breaks: !0,
		});
	}
	function jc(r) {
		if (!r) return !0;
		const e = r.replace(/[\s\u0000]+$/, ""),
			t = e.match(/^([`~]{3,})/);
		if (!t) return !0;
		const n = t[1];
		return new RegExp(`(?:
|\r
)${n}(?:[	 ]+)?$`).test(e);
	}
	const Ri = new Map();
	function e1(r, e, t) {
		const n = t.map((a) => a.link).join("|");
		return `${r}-${Ii(e)}|${n}`;
	}
	async function t1(r, e) {
		const t = Kc(r),
			n = Jc(e),
			a = n.lexer(t);
		return await Promise.all(
			a.map(async (s) =>
				s.type === "code"
					? {
							type: "code",
							lang: s.lang,
							code: Qc(s.text, s.lang),
							rawCode: s.text,
							isClosed: jc(s.raw ?? ""),
						}
					: { type: "text", html: n.parse(s.raw) }
			)
		);
	}
	function Ii(r) {
		let e = 0;
		for (let t = 0; t < r.length; t++) {
			const n = r.charCodeAt(t);
			(e = (e << 5) - e + n), (e = e & e);
		}
		return Math.abs(e).toString(36);
	}
	async function r1(r, e = []) {
		const t = Vc(r);
		return await Promise.all(
			t.map(async (n, a) => {
				const i = e1(a, n, e),
					s = Ri.get(i);
				if (s) return s;
				const l = await t1(n, e),
					u = { id: `${a}-${Ii(n)}`, content: n, tokens: l };
				return Ri.set(i, u), u;
			})
		);
	}
	let dn = !1,
		br = null;
	async function Di() {
		if (br) {
			const r = br;
			(br = null), (dn = !0);
			try {
				const { content: e, sources: t, requestId: n } = r,
					a = await r1(e, t);
				postMessage(JSON.parse(JSON.stringify({ type: "processed", blocks: a, requestId: n })));
			} finally {
				(dn = !1), await new Promise((e) => setTimeout(e, 100)), Di();
			}
		}
	}
	onmessage = (r) => {
		r.data.type === "process" && ((br = r.data), !dn && br && Di());
	};
})();
